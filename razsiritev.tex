\section{Razširjen \lae{}}\label{sec:razsirjen-lae}

Poglejmo si primer~\ref{prog:razsiritev-1}, ki bi ga lahko napisali v \aeff{}, ki pripada osnovni verziji \lae{}\nobreakdash-računa. V primeru se dve pomožni vrednosti poračunata v drugem procesu, medtem ko se glavni proces nadaljuje. 
Primer si lahko predstavljamo kot program, ki v pomožnem procesu poračuna časovno zahteven del, med tem ko glavni proces nemoteno nadaljuje delo.
%Primer si lahko predstavljamo, kot klient, ki pošlje zahtevo na strežnik, le ta pa mu odgovori. 
%Ali pa kot program, ki v pomožnem procesu poračuna računsko zahteven del, med tem ko glavni proces nemoteno nadaljuje delo.

\jR{Kaj smo potem rekli glede [ ] ki je hkrati seznam in boxed???}

\begin{lstlisting}[caption={Računanje zahtevne funkcije v ozadju.},label={prog:razsiritev-0},float,floatplacement=h]
operation call : int * int * int
operation result : int * int

let callWith =
	fun callCounter fNo x ->
		let callNo = !callCounter in
		send call (callNo, fNO, x);
		callCounter := callNo + 1;
		promise (result (callNo', y) when callNo = callNo' ->
			return <<y>>
		) as p in
		let valueThunk () = awaitValue p in
		return valueThunk

let remote fList =
	let rec loop () =
		promise (call (callNo, fNo, x) ->
			let f = fList[fNo] in
			let y = f x in
			send result (callNo, y);
			loop ()
		) as p in
		return p
	in
	loop ()

run	let callCounter = ref 0 in
	let y1t = callWith callCounter 0 2 in
	let y2t = callWith callCounter 1 3 in
	let z = 42 + 7 in
	return yt () + zt () + z

run remote (fun x |-> 2 * x)::(fun x |-> 7 * x)::[]
\end{lstlisting}

Ta primer, ima nekaj problemov. Prvi je, da, ker ne moremo pošiljati funkcij, mora imeti \emph{remote} vse funkcije v naprej podane. Temu se bomo izognili z prenosljivimi tipi.

\subsection{Prenosljivi tipi}

Ko imamo nek signal, je ključno, da tovor ne vsebuje vrednosti obljuba, kar smo do sedaj rešili tako, da smo omejili signale na osnovne tipe. Glavni problem tega pristopa je, da funkcijski tip ni med osnovnimi tipi in posledično ne moremo poslati funkcij. Ta problem rešimo z uvedbo \emph{zavite vrednosti} in \emph{zaviti tipi}. Zavite vrednosti bodo lahko tudi lambda funkcije, ki ne bodo vsebovale zunanjih obljub. Posledično jih bo varno poslati. Osnovne tipe skupaj z zavitim tipom imenujemo \emph{prenosljivi tipi}. Da bomo lahko zavito vrednost tudi uporabili, dodamo izračun \emph{odvijanje}, ki iz zavite vrednosti odvije pripadajočo vrednost in jo veže na spremenljivko.

Tipi za izračune in procese ostanejo enaki.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Vrednosti}}
	V
	\bnfis& ...                            & &\text{obstoječe vrednosti} \\
	\bnfor& \tmboxed{V}  & &\text{zavita vrednost}
	\intertext{\textbf{Izračuni}}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmunbox{V}{x}{M}  & &\text{odvijanje}
	\end{align*}
	
	\caption{Prenosljivi izrazi.}
	\label{fig:izrazi-prenosljivi}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\text{Prenosljivi tipi vrednosti $\tymobile{A}$, $\tymobile{B}$}
	\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tysum{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tyboxed{A}
	\\%[1ex]
	\text{Tipi vrednosti $A$, $B$}
	\bnfis & \tymobile{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
	\end{align*}
%	\vspace{-5ex}
%	\begin{align*}
%	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_k})
%	\end{align*}
	
	\caption{Prenosljivi tipi.}
	\label{fig:tipi-prenosljivi}
\end{figure}

Sedaj vsaki operaciji namesto osnovnega tipa pripada prenosljiv tip.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_k})
	\end{align*}
	\vspace{-5ex}
	\caption{Operacije z pripadajočimi prenosljivimi tipi.}
	\label{fig:prenosljive-operacije}
\end{figure}

Izračun odvijanje veže vrednost znotraj zavite vrednosti $\tmboxed{V}$ na spremenljivko $x$, ki jo lahko uporabimo v kontinuaciji $M$.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmunbox{[V]}{x}{M} &\reduces M[V/x]
	\end{align*}
	
	\caption{Operacijska semantika odvijanja.}
	\label{fig:semantika-odvijanje}
\end{figure}

Da zagotovimo, da ne bi kakšni vrednosti, ki vsebuje zunanjo obljubo, dodelili zavit tip, nekoliko spremenimo pravilo za izračun tipa spremenljivke in dodamo pravili za zavito vrednost in izračun odvijanje.
Sedaj bo vrstni red v okolju pomemben, zato je okolje od sedaj naprej urejen seznam. Ko določamo tip zavite vrednosti, v okolje dodamo $\bb$. S tem za v bodoče označimo katere spremenljivke so zunanje ali notranje glede na zavito vrednost. 
Če je spremenljivka notranja, torej od kar smo jo dodali v okolje, nismo dodali nobenega $\bb$, je pravilo standardno. Če je spremenljivka zunanja, torej od kar je bila dodana v okolje, je bil v okolje dodan tudi $\bb$, mora biti pripadajoči tip v okolju prenosljiv.

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{}{\text{A prenosljiv ali } \bb \notin \Gamma'
		}{
			\Gamma, x \of A, \Gamma' \types x \of A
		}
		\quad
		\coopinfer{}{\Gamma, \bb \types V \of A
		}{
			\Gamma \types \tmboxed{V} \of \tyboxed{A}
		}
		\quad
		\coopinfer{}{\Gamma \types V \of \tyboxed{A} \\ \Gamma, x \of A \types M \of \tycomp{B}{\o, \i}
		}{
			\Gamma \types \tmunbox{V}{x}{M} \of \tycomp{B}{\o, \i}
		}
	\end{mathpar}
	
	\caption{Dodatna pravila za določanje tipov.}
	\label{fig:tipi-pravila-prenosljivi}
\end{figure} 

Sedaj lahko primer~\ref{prog:razsiritev-0} spremenimo v~\ref{prog:razsiritev-1}. Namesto, da ima \emph{remote} statičen seznam funkcij, ki jih lahko poračuna, preprosto dobi funkcijo, kot del tovora.  

\begin{lstlisting}[caption={Računanje zahtevne funkcije v ozadju.},label={prog:razsiritev-1},float,floatplacement=h]
operation call : int * [int -> int] * int
operation result : int * int

let callWith =
	fun callCounter fBoxed x ->
		let callNo = !callCounter in
		send call (callNo, fBoxed, x);
		callCounter := callNo + 1;
		promise (result (callNo', y) when callNo = callNo' ->
			return <<y>>
		) as p in
		let valueThunk () = awaitValue p in
		return valueThunk

let remote () =
	let rec loop () =
		promise (call (callNo, fBoxed, x) ->
			unbox fBoxed as [f] in
			let y = f x in
			send result (callNo, y);
			loop ()
		) as p in
		return p
	in
	loop ()

run	let callCounter = ref 0 in
let y1t = callWith callCounter [fun x |-> 2 * x] 2 in
let y2t = callWith callCounter [fun x |-> 7 * x] 3 in
let z = 42 + 7 in
return yt () + zt () + z

run remote ()
	
\end{lstlisting}

%\begin{lstlisting}[caption={Primer uporabe prenosljivega tipa.},label={prog:primer-prenosljivega-tipa},float,floatplacement=h]
%run let f = [fun x -> (x, x)] in
%    send op f;
%    promise (op' y -> 
%      <y>)
%    as p in
%    await p until <y'> in
%    return y'
%
%run promise (op f -> 
%    let r = f 3 in
%    send op' r;
%    <()>) 
%    as _ in
%    return ()
%\end{lstlisting}


\subsection{Rekurzivni prestreznik}


%%% v rekurzivni obljubi za efekte je dovolj da so podmnožica ne nujno ekvivalenca kot je v papirju.


Kadar pričakujemo več prekinitev z isto operacijo, je lahko iz različnih razlogov za programerja priročno, če ima na voljo prestreznik, ki se po potrebi ponovno namesti. Lahko, da je namen prestreznika, da na vsako prekinitev odgovori z signalom. Lahko nam prihajajoča prekinitev prinese pravo operacijo, vendar ne pravega pripadajočega tovora, zato obljube še nočemo izpolniti, in čakamo na naslednjo prekinitev.

To funkcionalnost smo do sedaj dosegli tako, da smo obljubo definirali v pomožni rekurzivni funkciji in po potrebi znotraj obljube ponovno klicali to funkcijo, kot lahko vidimo v programu~\ref{prog:razsiritev-2}.


Predvsem z namenom bolj pregledne kode nadomestimo obstoječi prestreznik z rekurzivnim prestreznikom. Le ta ima poleg imena operacije $op$, tovora $x$, obljube $M$ in kontinuacije $N$ tudi spremenljivko $f$. Pripadajočo sintakso vidimo na sliki~\ref{fig:izrazi-prestreznik}.


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmwithrec{op}{f}{x}{M}{p}{N}  & &\text{rekurzivni prestreznik}
	\end{align*}
 
	\caption{Izračuni z rekurzivnim prestreznikom}
	\label{fig:izrazi-prestreznik}
\end{figure}


Operacijska semantika rekurzivnega prestreznika je zelo podobna prejšnji verziji. S to izjemo da, ko ustrezna prekinitev pride do prestreznika, le ta v obljubi $M$ naredi dve substituciji. Tako kot prej spremenljivko $x$ substituira z vrednostjo $V$, dodatno pa spremenljivko $f$ substituira z lambda funkcijo $F$, ki sprejme enoto in vrne svežo kopijo prestreznika. Znotraj $M$ lahko uporabimo $F$ in tako ponovno namestimo prestreznik.   


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmlet{x}{(\tmwithrec{op}{f}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwithrec{op}{f}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\\
	\tmwithrec{op}{f}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x, F/f]}{\tmopin{op}{V}{N}} \\
	F = \;& \tmfunano{y}{(\tmwithrec{op}{f}{x}{M}{p}{\tmreturn{p}})} \\
	\tmopin{op'}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}} &\reduces \tmwithrec{op}{f}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\end{align*}
	
	\caption{Operacijska semantika rekurzivnega prestreznika}
	\label{fig:semantika-prestreznik}
\end{figure}

Tudi pravilo za tip rekurzivnega prestreznika je zelo podobno prvotnemu prestrezniku.

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{}{\i\, (\op) \order{O \times I} ({\o'} , {\i'}) \\
			\Gamma, x \of \tymobile{A}_\op, f \of \tyfun{\tyunit}{\tycomp{\typromise{B}}{\o', \i'}} \types M : \tycomp{\typromise B}{\o',\i'} \\
			\Gamma, p \of \typromise B \types N : \tycomp{C}{\o,\i}
		}{
			\Gamma \types \tmwithrec{op}{x}{f}{M}{p}{N} \of \tycomp{C}{\o, \i}
		}
	\end{mathpar}
	
	\caption{Pravilo za izračun tipa rekurzivnega prestreznika.}
	\label{fig:tipi-pravila-rekurzivni-prestreznik}
\end{figure} 

Program~\ref{prog:razsiritev-2} ima isti semantičen pomen kot program~\ref{prog:razsiritev-1}, le da je tokrat napisan z rekurzivno obljubo.

\begin{lstlisting}[caption={Primer z rekurzivnim prestreznikom},label={prog:razsiritev-2},float,floatplacement=h]
operation call : int * [int -> int] * int
operation result : int * int

let callWith =
	fun callCounter fBoxed x ->
		let callNo = !callCounter in
		send call (callNo, fBoxed, x);
		callCounter := callNo + 1;
		promise (result (callNo', y) when callNo = callNo' ->
			return <<y>>
		) as p in
		let valueThunk () = awaitValue p in
		return valueThunk

let remote () =
	promise (call f (callNo, fBoxed, x) ->
		unbox fBoxed as [f] in
		let y = f x in
		send result (callNo, y);
		f()
	) as _ in
	()

run	let callCounter = ref 0 in
	let y1t = callWith callCounter [fun x |-> 2 * x] 2 in
	let y2t = callWith callCounter [fun x |-> 7 * x] 3 in
	let z = 42 + 7 in
	return yt () + zt () + z

run remote ()
\end{lstlisting}


\subsection{Dinamični procesi}

Funkcije $f$ v remote call se potencialno izvaja zelo počasi. Zato si želimo, da bi vsak $remote klic$ lahko opravili v svojem procesu, da lahko izvajamo vzporedno namesto zaporedno. 
Do sedaj so bili procesi statični v smislu, da smo vse procese morali ustvariti na začetku.
Posledično bi morali vnaprej vedeti, koliko klicov bo remote hkrati dobil, da bi imeli temu primerno pripravljenih procesov.

Da rešimo ta problem, dodamo dinamično ustvarjanje novih procesov s pomočjo izračuna $\tmspawn{M}{N}$. 
Le ta se bo pomikal navzven. Ko bo postal zgornji izračun v procesu, se bo ta proces razcepil v dva procesa. 
Prvi proces bo izvajal izračun $M$, drugi pa bo izvajal nadaljevanje $N$.


\begin{figure}[h]	
	\centering
	\small
	\begin{align*}
	\shortintertext{\textbf{Izračuni}}
	M, N
	\bnfis & ... \,\bnfor\! \tmspawn{M}{N}
	\end{align*}
	
	\caption{Izračun $\tmkw{Spawn}$.}
	\label{fig:izračun-spawn}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmlet{x}{(\tmspawn{M_1}{M_2})}{N} & \reduces \tmspawn{M_1}{\tmlet{x}{M_2}{N}}
	\\
	\tmwithrec{op}{x}{f}{M}{p}{\tmspawn{N_1}{N_2}} & \reduces \tmspawn{N_1}{\tmwithrec{op}{x}{f}{M}{p}{N_2}}
	\\
	\tmopin{op}{V}{\tmspawn{M}{N}} & \reduces \tmspawn{M}{\tmopin{op}{V}{N}}
	\\
	\tmrun{(\tmspawn{M}{N})} & \reduces \tmpar{\tmrun{M}}{\tmrun{N}}
	\end{align*}
	
	\caption{Operacijska semantika dinamičnih procesov.}
	\label{fig:semantika-spawn}
\end{figure}


Ker se izračun $M$ v $\tmspawn{M}{N}$ lahko razširi mimo prestreznikov moramo paziti, da ima $M$ prenosljiv tip in je posledično varen.   

\begin{figure}[h]
	\centering
	\small
	\textbf{Pravila za tipe računov}
	\begin{mathpar}
		\coopinfer{}{\Gamma, \blacksquare \types M : \tycomp{B}{\o', \i'} \\ \Gamma \types N : \tycomp{A}{\o, \i}
		}{
			\Gamma \types \tmspawn{M}{N} : \tycomp{A}{\o, \i}
		}
	\end{mathpar}
\end{figure}


Sedaj ko imamo dinamične procese, lahko obe evalvaciji funkcije $f$ opravimo hkrati v svojem procesu, kar potencialno pohitri izvajanje programa. Primer~\ref{prog:razsiritev-2} lahko sedaj spremenimo v~\ref{prog:razsiritev-3}. 

\begin{lstlisting}[caption={Primer z dinamičnimi procesi},label={prog:razsiritev-3},float,floatplacement=h]
operation call : int * [int -> int] * int
operation result : int * int

let callWith =
	fun callCounter fBoxed x ->
		let callNo = !callCounter in
		send call (callNo, fBoxed, x);
		callCounter := callNo + 1;
		promise (result (callNo', y) when callNo = callNo' ->
			return <<y>>
		) as p in
		let valueThunk () = awaitValue p in
		return valueThunk

let remote () =
	promise (call f (callNo, fBoxed, x) ->
		unbox fBoxed as [f] in
		spawn(
			let y = f x in
			send result (callNo, y)
		);
		f()
	) as _ in
	()

run	let callCounter = ref 0 in
let y1t = callWith callCounter [fun x |-> 2 * x] 2 in
let y2t = callWith callCounter [fun x |-> 7 * x] 3 in
let z = 42 + 7 in
return yt () + zt () + z

run remote ()
\end{lstlisting}


%Na primeru~\ref{prog:primer-dinamičen-proces} imamo program, ki naredi isto kot primer~\ref{prog:primer-prenosljivega-tipa}, le da tokrat uporabimo izračun $\tmkw{Spawn}$.
%\begin{lstlisting}[caption={Primer uporabe dinamičnih procesov.},label={prog:primer-dinamičen-proces},float,floatplacement=h]
%run let f = fun x -> (x, x) in
%    spawn(
%      let r = f 3 in
%      send op r;
%      (),
%      
%      promise (op x -> <x>)
%      as p in
%      await p until <x'> in
%      return x')
%\end{lstlisting}


\subsection{Varnost}

Sedaj dokažemo izrek o varnosti za \lae{} razširjen z rekurzivnimi prestrezniki, prenosljivimi tipi, in dinamičnimi procesi.

\begin{izrek}[o napredku za razširitev]
	Če ...
\end{izrek}



\begin{izrek}[izrek o ohranitvi]
	Če ...
\end{izrek}



