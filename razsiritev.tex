\section{Razširjen \lae{}}\label{sec:razsirjen-lae}

Čeprav lahko v jeziku \aeff{} napišemo že veliko zanimivih primerov\footnote{Osnovni članek~\cite{aeff} omeni kar nekaj primerov.}, se še zmeraj pojavijo določeni problemi.
Poglejmo si primer~\ref{prog:razsiritev-0}, ki bi ga lahko napisali v \aeff{}, ki pripada osnovni verziji \lae{}\nobreakdash-računa. Primer je nekoliko bolj konkretna verzija primera~\ref{prog:primer-1} iz poglavja~\ref{sec:primeri-aeff}.

Imamo dve funkciji, $\mathsf{povezi}$ in $\mathsf{streznik}$.
Funkcija $\mathsf{streznik}$ sprejme seznam funkcij. Ko bo prišla prekinitev $\mathsf{opravilo}$, bo iz seznama vzela ustrezno funkcijo\footnote{$\mathsf{nth}$ je funkcija ki sprejme seznam $\mathsf{s}$ in število $\mathsf{n}$ in vrne n-ti element seznama.}, izračunala vrednost te funkcije v dani vrednosti $\mathsf{x}$ in poslala nazaj signal z id-jem opravila in rezultatom. Na koncu pa bo s pomočjo rekurzivne pomožne funkcije ponovno namestila prestreznik.
Funkcija $\mathsf{povezi}$ sprejme referenco (ki bo predstavljala id opravila), id funkcije (ki jo želimo poračunati) in vrednost (v kateri želimo izračunati funkcijo).
Nato pošlje signal $\mathsf{opravilo}$ z ustreznimi vrednostmi in poveča številko v referenci.
Ni vseeno kateri rezultat prestrežemo, ampak mora biti rezultat z ustreznim id-jem. Zato prestreznik definiramo v pomožni rekurzivni funkciji, ki bo ponovno namestila prestreznik, če bomo ujeli rezultat z napačnim id-jem.
Namesto da sama funkcija $\mathsf{povezi}$ čaka na rezultat in ga vrne, bo takoj vrnila pomožno funkcijo, le ta pa bo po potrebi čakala na rezultat.  

V prvem procesu ustvarimo referenco in s pomočjo $\mathsf{povezi}$ začnemo računati dve pomožni vrednosti, na kateri pa ne čakamo, da se izračunata, ampak nemudoma začnemo z računanjem vrednosti $\mathsf{z}$. Nato kličemo pomožni funkciji $\mathsf{y1}$ in $\mathsf{y2}$, ki bosta po potrebi čakali na rezultat in nato vrnili dejanski rezultat. Na koncu tri vrednosti seštejemo.
V drugem procesu začnemo funkcijo $\mathsf{streznik}$ s seznamom dveh funkcij.
Omenimo, da v primeru uporabljamo izračun $\uparrow\hspace{-0.5ex}\op (V);M$, ki je sintaktičen sladkor za $\tmlet{\_}{\tmopout{op}{V}{\tmreturn{()}}}{M}$.

\begin{lstlisting}[caption={Računanje zahtevne funkcije v ozadju.},label={prog:razsiritev-0},float,floatplacement=h]
operation opravilo : int * int * int
operation rezultat : int * int

let povezi stevecOpravila fID x (*@$\defeq{}$@*)
    let opraviloID (*@$\defeq{}$@*) !stevecOpravila in
    send opravilo (opraviloID, fID, x);
    stevecOpravila := opraviloID + 1;
    let rec pomozna () (*@$\defeq{}$@*)
    	promise (rezultat (opraviloID', y) ->
    		if opraviloID = opraviloID' then
    			return <y>
    		else
    			pomozna ()
    	) as p in
    	return p
    in
    let p' (*@$\defeq{}$@*) pomozna () in
    let pridobiVrednost () (*@$\defeq{}$@*)
    	await p' until <r> in
    	return r'
    in
    return pridobiVrednost

let streznik fSeznam (*@$\defeq{}$@*)
    let rec pomozna () (*@$\defeq{}$@*)
    	promise (opravilo (opraviloID, fID, x) ->
    		let f (*@$\defeq{}$@*) nth fSeznam fID in
    		let y (*@$\defeq{}$@*) f x in
    		send rezultat (opraviloID, y);
    		pomozna ()
    	) as p in
    	return p
    in
    pomozna ()

run	let stevecOpravila (*@$\defeq{}$@*) ref 0 in
    let y1 (*@$\defeq{}$@*) povezi stevecOpravila 0 2 in
    let y2 (*@$\defeq{}$@*) povezi stevecOpravila 1 3 in
    let z (*@$\defeq{}$@*) 42 + 7 in
    return y1 () + y2 () + z

run streznik ((fun x -> 2 * x)::(fun x -> 7 * x)::nil)
\end{lstlisting}


Ta primer ima tri glavne primanjkljaje. Pogosto si moramo pomagati z pomožno rekurzivno funkcijo v navezi s prestreznikom, da slednjega ponovno namestimo. Operacije so omejene na osnovne tipe, zaradi česar ne moremo pošiljati funkcij. In ne moremo po potrebi ustvarjati novih procesov.
Te tri probleme bomo sedaj enega za drugim razrešili, tako da bomo razširili \lae{}-račun in posledično jezik \aeff{}.


\subsection{Rekurzivni prestreznik}


Kadar pričakujemo več prekinitev z isto operacijo, je lahko iz različnih razlogov za programerja priročno, če ima na voljo prestreznik, ki se po potrebi ponovno namesti. Lahko je namen prestreznika, da na vsako prekinitev odgovori z signalom. Lahko nam prihajajoča prekinitev prinese pravo operacijo, vendar ne pravega pripadajočega tovora, zato obljube še nočemo izpolniti, in čakamo na naslednjo prekinitev.
To funkcionalnost smo do sedaj dosegli tako, da smo obljubo definirali v pomožni rekurzivni funkciji in po potrebi znotraj obljube ponovno klicali to funkcijo, kot smo videli v programu~\ref{prog:razsiritev-0}.

Predvsem z namenom bolj pregledne kode nadomestimo obstoječi prestreznik z rekurzivnim prestreznikom $\tmwithrec{op}{x}{r}{M}{p}{N}$. Pripadajočo sintakso vidimo na sliki~\ref{fig:izrazi-prestreznik}. Le ta ima poleg imena operacije $op$, tovora $x$, obljube $M$ in nadaljevanja $N$ tudi spremenljivko $r$, s pomočjo katere lahko ponovno namestimo isti prestreznik.  Seveda je stara oblika poseben primer novega prestreznika v katerem ne uporabimo $r$.


\begin{figure}[H]
	\centering
	\small
	\begin{align*}
		M, N
		\bnfis& ...                            & &\text{obstoječi izračuni} \\
		\bnfor& \tmwithrec{op}{x}{r}{M}{p}{N}  & &\text{rekurzivni prestreznik}
	\end{align*}
	
	\caption{Izračuni z rekurzivnim prestreznikom}
	\label{fig:izrazi-prestreznik}
\end{figure}

Substitucijo prestreznika popravimo, kot vidimo na sliki~\ref{fig:substitucija-prestreznik}. V bodoče bomo uporabljali sledečo okrajšavo $M[V_1/x_1, V_2/x_2] \defeq (M[V_1/x_1])[V_2/x_2]$.

\begin{figure}[H]
	\centering
	\small
	\begin{align*}
		(\tmwithrec{op}{y}{r}{M}{p}{N})[V/x] &= \tmwithrec{op}{y}{r}{M[V/x]}{p}{N[V/x]}
	\end{align*}
	\vspace{-5ex}
	\caption{Substitucija za rekurzivni prestreznik.}
	\label{fig:substitucija-prestreznik}
\end{figure}

Operacijska semantika rekurzivnega prestreznika je podobna prejšnji verziji. S to izjemo da, ko prekinitev $\tmopin{op}{V}{M}$ pride do prestreznika $\tmwithrec{op}{x}{r}{N_1}{p}{N_2}$, le ta v obljubi $M$ naredi dve substituciji. Tako kot prej spremenljivko $x$ substituira z vrednostjo $V$, dodatno pa spremenljivko $r$ substituira z funkcijo $R$, ki sprejme enoto in vrne svežo kopijo prestreznika. Znotraj $M$ lahko uporabimo funkcijo $R$ in tako ponovno namestimo prestreznik. Spremembe vidimo na sliki~\ref{fig:semantika-prestreznik}.

\begin{figure}[H]
	\centering
	\small~
	\begin{align*}
		\tmlet{x}{(\tmwithrec{op}{y}{r}{M}{p}{N_1})}{N_2} \reduces \\
		\tmwithrec{op}{y}{r}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\end{align*}
	\vspace{-5ex}
	\begin{align*}
		\tmwithrec{op}{x}{r}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwithrec{op}{x}{r}{M}{p}{N}}
		\razmik
		\tmopin{op}{V}{\tmwithrec{op}{x}{r}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x, R/r]}{\tmopin{op}{V}{N}} \\
		\text{kjer }R = \;& \tmfunano{\_}{(\tmwithrec{op}{r}{x}{M}{p}{\tmreturn{p}})}
		\razmik
		\tmopin{op'}{V}{\tmwithrec{op}{x}{r}{M}{p}{N}} &\reduces \tmwithrec{op}{x}{r}{M}{p}{\tmopin{op'}{V}{N}} \\
		&\qquad {\color{rulenameColor}(\op \neq \op')}
	\end{align*}
	
	\caption{Operacijska semantika rekurzivnega prestreznika.}
	\label{fig:semantika-prestreznik}
\end{figure}

Tudi pravilo za tip rekurzivnega prestreznika je zelo podobno prvotnemu prestrezniku. Vidimo ga na sliki~\ref{fig:tipi-pravila-rekurzivni-prestreznik}. Spremenljivka $r$ dobi tip $\tyfun{\tyunit}{\tycomp{\typromise{B}}{\emptyset, \op \mapsto (\o', \i')}}$, ki lepo predstavlja izračun, ki ne sproži nobenega signala in prestreže le operacijo $\op$.
Za razliko od prej imamo sedaj v $({\o'} , {\i'}) \order{O \times I} \i\, (\op)$ red namesto enakosti. Ker sedaj v kontekst dodamo tip $\tyfun{\tyunit}{\tycomp{\typromise{B}}{\emptyset, \op \mapsto (\o', \i')}}$ moramo paziti da pripadajoč tip efektov $(\o', \i')$ ni prevelik, saj sicer morda ne bomo mogli določiti tipa za $M$.

\begin{figure}[H]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyComp-RecPromise}{
			({\o'} , {\i'}) \order{O \times I} \i\, (\op)\\
			\Gamma, x \of \tymobile{A}_\op, r \of \tyfun{\tyunit}{\tycomp{\typromise{B}}{\emptyset, \{\op \mapsto (\o', \i')\}}} \types M : \tycomp{\typromise B}{\o',\i'} \\
			\Gamma, p \of \typromise B \types N : \tycomp{C}{\o,\i}
		}{
			\Gamma \types \tmwithrec{op}{x}{r}{M}{p}{N} \of \tycomp{C}{\o, \i}
		}
	\end{mathpar}
	
	\caption{Pravilo za izračun tipa rekurzivnega prestreznika.}
	\label{fig:tipi-pravila-rekurzivni-prestreznik}
\end{figure} 


Ker imamo sedaj v pravilu za tip prestreznika neenakost $(\o', \i') \order{O \times I} \i(\op)$ bomo lemo~\ref{lem:effects-order} dopolnili z sledečo lemo.

\begin{lema}\label{lem:effects-order-2}
	\begin{enumerate}
		\item\label{lem:eo2-1} Če $(\o', \i') \order{O \times I} \i(\op)$, potem $(\o', \i') \order{O \times I} \opincomp{\op}{(\o, \i)}$
		\item\label{lem:eo2-2} Če $\op \neq \op'$ in $(\o', \i') \order{O \times I} \i(\op')$, potem $(\o', \i') \order{O \times I} (\pi_2(\opincomp{\op}{(\o, \i)}))(\op')$
	\end{enumerate}
\end{lema}

\begin{proof}
	Red $\order{O \times I}$ je tranzitivna operacija, zato točki te leme sledita iz ustreznih točk leme~\ref{lem:effects-order}.
\end{proof}


Program~\ref{prog:razsiritev-1} ima isti semantičen pomen kot program~\ref{prog:razsiritev-0}, le da je tokrat napisan z rekurzivno obljubo.
Ker nimamo pomožne funkcije je koda nekoliko krajša in tudi lažje berljiva.

\begin{lstlisting}[caption={Primer z rekurzivnim prestreznikom},label={prog:razsiritev-1},float,floatplacement=h]
operation opravilo : int * int * int
operation rezultat : int * int

let povezi (*@$\defeq{}$@*)
	fun stevecOpravila fID x ->
		let opraviloID (*@$\defeq{}$@*) !stevecOpravila in
		send opravilo (opraviloID, fID, x);
		stevecOpravila := opraviloID + 1;
		promise (rezultat (opraviloID', y) (*@\hlyellow{$r$}@*) ->
			if opraviloID = opraviloID' then
				return <y>
			else
				(*@\hlyellow{$r$}@*) ()
		) as p in
		let pridobiVrednost () (*@$\defeq{}$@*) 
			await p until <r> in
			return r
		in
		return pridobiVrednost

let streznik fSeznam (*@$\defeq{}$@*)
	promise (opravilo (opraviloID, fID, x) (*@\hlyellow{$r$}@*) ->
		let f (*@$\defeq{}$@*) nth fSeznam fID in
		let y (*@$\defeq{}$@*) f x in
		send rezultat (opraviloID, y);
		(*@\hlyellow{$r$}@*) ()
	) as _ in
	()

run	let stevecOpravila (*@$\defeq{}$@*) ref 0 in
	let y1 (*@$\defeq{}$@*) povezi stevecOpravila 0 2 in
	let y2 (*@$\defeq{}$@*) povezi stevecOpravila 1 3 in
	let z (*@$\defeq{}$@*) 42 + 7 in
	return y1 () + y2 () + z

run streznik ((fun x -> 2 * x)::(fun x -> 7 * x)::nil)
\end{lstlisting}


\subsection{Prenosljivi tipi}

Ko imamo nek signal, je ključno, da tovor ne vsebuje vrednosti obljub, kar smo do sedaj rešili tako, da smo omejili signale na osnovne tipe. Glavni problem tega pristopa je, da funkcijski tip ni med osnovnimi tipi in posledično ne moremo poslati funkcij. Ta problem rešimo z uvedbo \emph{zavitih vrednosti} $\tmboxed{V}$ in izračunov \emph{odvijanje} $\tmunbox{V}{x}{M}$, kot vidimo na sliki~\ref{fig:izrazi-prenosljivi}. Zavite vrednosti bodo vrednosti, ki jih bo varno poslati zahvaljujoč drugačnemu preverjanju tipa. Bistveno bodo zavite vrednosti lahko vsebovale tudi funkcije, ki pa same ne bodo vsebovale zunanjih obljub. Da lahko dobimo vrednost v zaviti vrednosti, uporabimo odvijanje, ki iz zavite vrednosti odvije pripadajočo vrednost in jo veže v navadno spremenljivko.

\begin{figure}[H]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Vrednosti}}
	V
	\bnfis& ...                            & &\text{obstoječe vrednosti} \\
	\bnfor& \tmboxed{V}  & &\text{zavita vrednost}
	\intertext{\textbf{Izračuni}}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmunbox{V}{x}{M}  & &\text{odvijanje}
	\end{align*}
	
	\caption{Prenosljivi izrazi.}
	\label{fig:izrazi-prenosljivi}
\end{figure}

Zavite vrednosti dobijo \emph{zaviti tip} $[A]$.  
Osnovne tipe skupaj z zavitim tipom imenujemo \emph{prenosljivi tipi}. 
Tipi za izračune in procese ostanejo enaki.
Spremembe vidimo na sliki~\ref{fig:tipi-prenosljivi}.

\begin{figure}[H]
	\centering
	\small
	\begin{align*}
	\text{Prenosljivi tipi vrednosti $\tymobile{A}$, $\tymobile{B}$}
	\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tysum{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tyboxed{A}
	\\%[1ex]
	\text{Tipi vrednosti $A$, $B$}
	\bnfis & \tymobile{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
	\end{align*}
%	\vspace{-5ex}
%	\begin{align*}
%	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_k})
%	\end{align*}
	
	\caption{Prenosljivi tipi.}
	\label{fig:tipi-prenosljivi}
\end{figure}

Sedaj vsaki operaciji namesto osnovnega tipa pripada prenosljiv tip, kot vidimo na sliki~\ref{fig:prenosljive-operacije}.

\begin{figure}[H]
	\centering
	\small
	\begin{align*}
	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_n})
	\end{align*}
	\vspace{-5ex}
	\caption{Operacije s pripadajočimi prenosljivimi tipi.}
	\label{fig:prenosljive-operacije}
\end{figure}

Obstoječim substitucijam dodamo dve novi za nova izraza, kot vidimo na sliki~\ref{fig:substitucija-box}.

\begin{figure}[H]
	\centering
	\small
	\begin{align*}
		\tmboxed{W}[V/x] &= \tmboxed{W[V/x]} \\
		(\tmunbox{W}{x}{M})[V/x] &= \tmunbox{W[V/x]}{x}{M[V/x]}
	\end{align*}
	\vspace{-5ex}
	\caption{Dodatne substitucije.}
	\label{fig:substitucija-box}
\end{figure}

Kot vidimo na sliki~\ref{fig:semantika-odvijanje} izračun odvijanje veže vrednost znotraj zavite vrednosti $\tmboxed{V}$ na spremenljivko $x$, ki jo lahko uporabimo v nadaljevanju $M$.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmunbox{[V]}{x}{M} &\reduces M[V/x]
	\end{align*}
	
	\caption{Operacijska semantika odvijanja.}
	\label{fig:semantika-odvijanje}
\end{figure}


Da zagotovimo, da ne bi kakšni vrednosti, ki vsebuje zunanjo obljubo, dodelili zavit tip, nekoliko spremenimo pravilo za izračun tipa spremenljivke in dodamo pravili za zavito vrednost in izračun odvijanje. Nekoliko spremenimo tudi kontekst. Uporabimo ideje, ki jih predstavi Clouston~\cite{fitch}. Spremembe prikaže slika~\ref{fig:tipi-pravila-prenosljivi}.
Okolje je imelo že od začetka določen vrstni red, vendar šele sedaj to postane zares pomembno. 
Ko določamo tip zavite vrednosti $\tmboxed{V}$, v okolje dodamo $\bb$. S tem za v bodoče vse spremenljivke že v kontekstu označimo za zunanje. Spremenljivke, ki jih bomo dodajali v kontekst, ko bomo določali tip $V$ pa bodo notranje glede na zavito vrednost. Ko bomo nekje v vrednosti $V$ naleteli na spremenljivko $x$ bomo imeli dve možnosti. Če je spremenljivka notranja, je lahko tudi tipa obljuba, saj je pripadajoči prestreznik prav tako znotraj vrednosti $V$ in se bo premikal skupaj z spremenljivko $x$. Če pa je spremenljivka zunanja, ne sme biti tipa obljuba, saj obstaja možnost, da se bo vrednost $V$ in z njo spremenljivka $x$ premaknila mimo definicije ustreznega prestreznika.
Pri izračunu odvijanje le preverimo da je vrednost $V$ zavitega tipa, sam pa ima isti tip kot njegovo nadaljevanje.

\begin{figure}[H]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyVal-Var'}{
			\text{A prenosljiv ali } \bb \notin \Gamma'
		}{
			\Gamma, x \of A, \Gamma' \types x \of A
		}
		\quad
		\coopinfer{TyVal-Boxed}{
			\Gamma, \bb \types V \of A
		}{
			\Gamma \types \tmboxed{V} \of \tyboxed{A}
		}
		\quad
		\coopinfer{TyComp-Unbox}{
			\Gamma \types V \of \tyboxed{A} \\ \Gamma, x \of A \types M \of \tycomp{B}{\o, \i}
		}{
			\Gamma \types \tmunbox{V}{x}{M} \of \tycomp{B}{\o, \i}
		}
	\end{mathpar}
	
	\caption{Dodatna pravila za določanje tipov.}
	\label{fig:tipi-pravila-prenosljivi}
\end{figure} 

Sedaj lahko program~\ref{prog:razsiritev-1} spremenimo v program~\ref{prog:razsiritev-2}. Namesto, da ima \emph{streznik} statičen seznam funkcij, ki jih lahko poračuna, preprosto dobi funkcijo, kot del tovora. Na ta način smo bolj fleksibilni pri pisanju kode, hkrati pa je tudi bolj jasno kot prej, katera funkcija se bo poračunala.

\begin{lstlisting}[caption={Računanje zahtevne funkcije v ozadju.},label={prog:razsiritev-2},float,floatplacement=h]
operation opravilo : int * (*@\hlyellow{$[int -> int]$}@*) * int
operation rezultat : int * int

let povezi (*@$\defeq{}$@*)
    fun stevecOpravila fZavita x ->
    	let opraviloID (*@$\defeq{}$@*) !stevecOpravila in
    	send opravilo (opraviloID, fZavita, x);
    	stevecOpravila := opraviloID + 1;
    	promise (rezultat (opraviloID', y) ->
    		if opraviloID = opraviloID' then
    			return <y>
    		else
    			r ()
    	) as p in
    	let pridobiVrednost () (*@$\defeq{}$@*) 
    		await p until <r> in
    		return r
    	in
    	return pridobiVrednost

let streznik () (*@$\defeq{}$@*)
    promise (opravilo (opraviloID, fZavita, x) r ->
    	(*@\hlyellow{$unbox fZavita as [f] in$}@*)
    	let y (*@$\defeq{}$@*) f x in
    	send rezultat (opraviloID, y);
    	r ()
    ) as _ in
    ()

run	let stevecOpravila (*@$\defeq{}$@*) ref 0 in
    let y1 (*@$\defeq{}$@*) povezi stevecOpravila (*@\hlyellow{$[fun x -> 2 * x]$}@*) 2 in
    let y2 (*@$\defeq{}$@*) povezi stevecOpravila (*@\hlyellow{$[fun x -> 7 * x]$}@*) 3 in
    let z (*@$\defeq{}$@*) 42 + 7 in
    return y1 () + y2 () + z

run streznik ()
	
\end{lstlisting}

\subsection{Dinamični procesi}

Funkcija $\mathsf{f}$ v $\mathsf{streznik}$ na sliki~\ref{prog:razsiritev-2} se potencialno izvaja zelo počasi. Med ko jo računamo lahko dobimo novo opravilo, ki pa bo moralo čakati. Zato si želimo, da bi vsako opravilo lahko opravili v svojem procesu, da lahko izvajamo vzporedno namesto zaporedno. 
Do sedaj so bili procesi statični v smislu, da smo vse procese morali ustvariti na začetku.
Posledično bi morali vnaprej vedeti, koliko opravil bo $\mathsf{streznik}$ hkrati dobil, da bi imeli temu primerno pripravljenih procesov.

Da rešimo ta problem, dodamo dinamično ustvarjanje novih procesov s pomočjo izračuna $\tmspawn{M}{N}$. Sintakso vidimo na sliki~\ref{fig:izračun-spawn}. 

\begin{figure}[H]	
	\centering
	\small
	\begin{align*}
	\shortintertext{\textbf{Izračuni}}
	M, N
	\bnfis & ... \,\bnfor\! \tmspawn{M}{N}
	\end{align*}
	
	\caption{Izračun $\tmkw{Spawn}$.}
	\label{fig:izračun-spawn}
\end{figure}

Dodamo tudi substitucijo kot na sliki~\ref{fig:substitucija-spawn}.

\begin{figure}[H]
	\centering
	\small
	\begin{align*}
		(\tmspawn{M}{N})[V/x] &= \tmspawn{M[V/x]}{N[V/x]}
	\end{align*}
	\caption{Substitucija za dinamične procese.}
	\label{fig:substitucija-spawn}
\end{figure}

Natančno semantiko dinamičnih procesov vidimo na sliki~\ref{fig:semantika-spawn}. Izračun $\tmkw{spawn}$ se bo pomikal navzven. Ko bo postal zgornji izračun v procesu, se bo ta proces razcepil v dva procesa. 
Prvi proces bo izvajal izračun $M$, drugi pa bo izvajal nadaljevanje $N$.

\begin{figure}[H]
	\centering
	\small
	\begin{align*}
	\tmlet{x}{(\tmspawn{M_1}{M_2})}{N} & \reduces \tmspawn{M_1}{\tmlet{x}{M_2}{N}}
	\end{align*}
	\vspace{-5ex}
	\begin{align*}
	\tmwithrec{op}{x}{r}{M}{p}{\tmspawn{N_1}{N_2}} \reduces \\
	\tmspawn{N_1}{\tmwithrec{op}{x}{r}{M}{p}{N_2}}
	\end{align*}
	\vspace{-5ex}
	\begin{align*}
	\tmopin{op}{V}{\tmspawn{M}{N}} & \reduces \tmspawn{M}{\tmopin{op}{V}{N}}
	\razmik
	\tmrun{(\tmspawn{M}{N})} & \reduces \tmpar{\tmrun{M}}{\tmrun{N}}
	\razmik
	\tmrun{(\tmspawn{M}{N})} & \reduces \tmpar{\tmrun{N}}{\tmrun{M}}
	\end{align*}
	
	\caption{Operacijska semantika dinamičnih procesov.}
	\label{fig:semantika-spawn}
\end{figure}

Ker se izračun $M$ v $\tmspawn{M}{N}$ lahko razširi mimo prestreznikov moramo paziti, da $M$ ne vsebuje zunanjih obljub. V kontekst dodamo $\bb$, ko preverjamo izračun $M$. Točno pravilo vidimo na sliki~\ref{fig:tipi-pravila-spawn}.

\begin{figure}[H]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyComp-Spawn}{
			\Gamma, \blacksquare \types M : \tycomp{B}{\o', \i'} \\ \Gamma \types N : \tycomp{A}{\o, \i}
		}{
			\Gamma \types \tmspawn{M}{N} : \tycomp{A}{\o, \i}
		}
	\end{mathpar}
	\vspace{-5ex}
	\caption{Dodatno pravilo za določitev tipa.}
	\label{fig:tipi-pravila-spawn}
\end{figure}


Sedaj ko imamo dinamične procese, lahko obe evalvaciji funkcije $\mathsf{f}$ v $\mathsf{streznik}$ opravimo hkrati v svojem procesu, kar potencialno pohitri izvajanje programa. 
Tu bi opozorili da ne smemo odviti funkcije $\mathsf{fZavita}$ in nato podati novemu procesu odvito funkcijo $\mathsf{f}$, ampak moramo novemu procesu podati zavito funkcijo, ki si jo mora nov proces sam odviti. 
Primer~\ref{prog:razsiritev-2} lahko sedaj spremenimo v~\ref{prog:razsiritev-3}.
Izračun $\tmkw{spawn}(M);N$ je sintaktičen sladkor za $\tmlet{\_}{\tmspawn{M}{\tmreturn{()}}}{N}$. 

\begin{lstlisting}[caption={Primer z dinamičnimi procesi},label={prog:razsiritev-3},float,floatplacement=H]
operation opravilo : int * [int -> int] * int
operation rezultat : int * int

let povezi (*@$\defeq{}$@*)
	fun stevecOpravila fZavita x ->
		let opraviloID (*@$\defeq{}$@*) !stevecOpravila in
		send opravilo (opraviloID, fZavita, x);
		stevecOpravila := opraviloID + 1;
		promise (rezultat (opraviloID', y) ->
			if opraviloID = opraviloID' then
				return <y>
			else
				r ()
		) as p in
		let pridobiVrednost () (*@$\defeq{}$@*)
			await p until <r> in
			return r
		in
		return pridobiVrednost

let streznik () (*@$\defeq{}$@*)
	promise (opravilo (opraviloID, fZavita, x) r ->
		(*@\hlyellow{$spawn$}@*)(
			unbox fZavita as [f] in
			let y (*@$\defeq{}$@*) f x in
			send rezultat (opraviloID, y)
		);
		r ()
	) as _ in
	()

run	let stevecOpravila (*@$\defeq{}$@*) ref 0 in
let y1 (*@$\defeq{}$@*) povezi stevecOpravila [fun x |-> 2 * x] 2 in
let y2 (*@$\defeq{}$@*) povezi stevecOpravila [fun x |-> 7 * x] 3 in
let z (*@$\defeq{}$@*) 42 + 7 in
return y1 () + y2 () + z

run streznik ()
\end{lstlisting}


\subsection{Varnost}

Sedaj bomo ponovno dokazali izreka o napredku in ohranitvi ter potrebne leme, tokrat za \lae{}-račun razširjen z rekurzivnimi prestrezniki, prenosljivimi tipi, in dinamičnimi procesi. Kadar je dokaz zelo podoben dokazu od prej, bomo dokazali le dele, ki so se spremenili ali so na novo. 

Tudi za vse dinamične procese si želimo, da se razširijo do vrha, zato dodamo pravilo podobno kot za signale. Pravilo za prestreznik je praktično nespremenjeno, le da tokrat z rekurzivnimi prestrezniki. Rezultate za izračune iz slike~\ref{fig:results-rules} dopolnimo z rezultatoma na sliki~\ref{fig:results-rules-2}. 

\begin{figure}[H]
	\centering
	\begin{mathpar}
		\coopinfer{R-Spawn}{
			\CompResult {\Psi} {N}
		}{
			\CompResult {\Psi} {\tmspawn{M}{N}}
		}
		\quad
		\coopinfer{R-Promise}{
			\RunResult {\Psi \cup \{p\}} {N}
		}{
			\RunResult {\Psi} {\tmwithrec {op} x r M p N}
		}
	\end{mathpar}
	\vspace{-5ex}
	\caption{Dodatna rezultata za izračune.}
	\label{fig:results-rules-2}
\end{figure}

Formulacija trditve o napredku je enaka kot prej.

\begin{trditev}[o napredku]\label{trd:gamma-napredek-2}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$, kjer je $\Gamma = x_1 \of \typromise{A_1}, x_2 \of \typromise{A_2},..., x_i \of \typromise{A_i}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\CompResult{\Gamma}{M}$.
\end{trditev}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma \types M \of \tycomp{A}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	Primeri, ki so enaki kot v dokazu~\ref{trd:gamma-napredek} so izpuščeni. V primerih, ki so drugačni, omenimo le spremenjen ali dodan del.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $$\tmlet{x}{N_1}{N_2}.$$
		Če je $N_1$ rezultat, dobimo dodatno možnost.
		\begin{itemize}
			\item Če je zadnje pravilo \rulename{R-Spawn}, potem je $N_1$ enak $\tmspawn{N_3}{N_4}$ in lahko $M$ naredi korak v $\tmspawn{N_3}{(\tmlet{x}{N_4}{N_2})}$.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyComp-Interrupt}, potem je $M$ enak $$\tmopin{op}{V}{N}.$$
		Če je $N$ rezultat, dobimo dodatno možnost.
		\begin{itemize}
			\item Če je zadnje pravilo \rulename{R-Spawn}, potem je $N$ enak $\tmspawn{N_1}{N_2}$ in lahko $M$ naredi korak v $\tmspawn{N_1}{(\tmopin{op}{V}{N_2})}$.
		\end{itemize}
		
		
		\item Če je zadnje pravilo \rulename{TyComp-RecPromise}, potem je $M$ enak $$\tmwithrec{op}{x}{r}{N_1}{p}{N_2}.$$
		Če je $N_2$ rezultat, dobimo dodatno možnost.
		\begin{itemize}
			\item Če je zadnje pravilo \rulename{R-Spawn}, potem je $N_2$ oblike $\tmspawn{N_3}{N_4}$ in lahko $M$ naredi korak v $\tmspawn{N_3}{\tmwith{op}{x}{N_1}{p}{N_4}}$.
		\end{itemize}		
	\end{itemize}	
\end{proof}


\begin{posledica}[o napredku]\label{pos:prazen-napredek-2}
	Naj za izračun $M$ velja $\emptyset \types M \of \tycomp{A}{\o, \i}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\RunResult{\emptyset}{M}$.
\end{posledica}

\begin{proof}
	Trditev \ref{trd:gamma-napredek-2} velja za vsak kontekst $\Gamma$, torej tudi za $\Gamma = \emptyset$.
\end{proof}


\begin{izrek}[o napredku]
	Naj za proces $P$ velja $\emptyset \types P \of C$. Potem ali (i) obstaja proces $P'$, tak da $P \reduces P'$, ali pa (ii) velja $\ProcResult{P}$.
\end{izrek}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\emptyset \types P \of C$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	Primeri, ki so enaki kot v dokazu~\ref{izr:napredek} so izpuščeni. V primerih, ki so drugačni, omenimo le spremenjen ali dodan del.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyProc-Run}, potem je $P$ enak $\tmrun{M}$. Ker ima $M$ tip, po posledici~\ref{pos:prazen-napredek-2} velja da, ali lahko $M$ naredi korak v $M'$ ali pa je $M$ delni rezultat.
		Če je $M$ rezultat, dobimo dodatno možnost.
		\begin{itemize}
			\item Če je zadnje pravilo \rulename{R-Spawn}, potem je $M$ enak $\tmspawn{N_1}{N_2}$ in lahko $P$ naredi korak v $\tmpar{N_1}{N_2}$ ali v $\tmpar{N_2}{N_1}$.
		\end{itemize}		
	\end{itemize}
\end{proof}

Lemi~\ref{lem:weakening-values-2} in~\ref{lem:weakening-comp-2} se navezujeta ena na drugo.

\begin{lema}\label{lem:weakening-values-2}
	Naj za vrednost $V$ velja $\Gamma_1, \Gamma_2 \types V \of A$. Za vsak kontekst $\Gamma_3$, ki vsebuje le sveže spremenljivke glede na $\Gamma_1$ in $\Gamma_2$, velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, \Gamma_2 \types V \of A$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	Primeri, ki so enaki kot v dokazu~\ref{lem:weakening-values} so izpuščeni.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyVal-Var'}, potem je $V = x$ in velja $x \in \Gamma_1$ ali $x \in \Gamma_2$.
		Ker $\Gamma_3$ ne vsebuje $\bb$, velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$ po pravilu \rulename{TyVal-Var'}
		
		\item Če je zadnje pravilo \rulename{TyVal-Boxed}, je $V = \tmboxed{V'}$. Po indukcijski predpostavki ima $V'$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Boxed} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
	\end{itemize}
\end{proof}

\begin{lema}\label{lem:weakening-comp-2}
	Naj za izračun $M$ velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$. Za vsak kontekst $\Gamma_3$, ki vsebuje le sveže spremenljivke glede na $\Gamma_1$ in $\Gamma_2$, velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	Primeri, ki so enaki kot v dokazu~\ref{lem:weakening-comp} so izpuščeni.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-RecPromise}, potem je $M$ enak $$\tmwithrec{op}{x}{r}{N_1}{p}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-RecPromise} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Unbox}, potem je $M$ enak $$\tmunbox{V}{x}{N}.$$
		Po lemi~\ref{lem:weakening-values} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Unbox} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Spawn}, potem je $M$ enak $$\tmspawn{N_1}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Spawn} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
	\end{itemize}potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Run}. Tip $C$ je oblike $\tyrun{A}{\o, \i}$.
Izračun $M$ ima tip $\tycomp{B}{\o', \i'}$ in $N$ tip $\tycomp{A}{\o, \i}$.
Po pravilu \rulename{TyProc-Par} ima $P'$ tip $\typar{\tycomp{A}{\o, \i}}{\tycomp{B}{\o', \i'}}$, kjer je $C$ naredil korak \rulename{TyRedu-Spawn-R}.
\end{proof}

Sledeči lemi o šibitvi konteksta za vrednosti in izračune se nanašata ena na drugo.

\begin{lema}\label{lem:weakening-values-bb}
	Naj za vrednost $V$ velja $\Gamma_1, \Gamma_2 \types V \of A$, kjer $\Gamma_2$ vsebuje $\bb$.
	Za vsak kontekst $\Gamma_3$, ki vsebuje le $\bb$ in sveže spremenljivke glede na $\Gamma_1$ in $\Gamma_2$, velja $\Gamma_1, \Gamma_3, \Gamma_2, \types V \of A$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, \Gamma_2 \types V \of A$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item[\sitem] Če je zadnje pravilo \rulename{TyVal-Var'}, potem je $V = x$ in velja $x \in \Gamma_1$ ali $x \in \Gamma_2$.
		\begin{itemize}
			\item Če je $x \in \Gamma_1$ potem je $A$ prenosljiv tip. Če je $x \in \Gamma_2$ in je za njim $\bb$ je $A$ spet prenosljiv tip.
			Ker je $A$ prenosljiv tip velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$ po pravilu \rulename{TyVal-Var'}.
			\item Če je $x \in \Gamma_2$ in za njim ni $\bb$ potem velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$ po pravilu \rulename{TyVal-Var'}.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyVal-Cons}, potem je $V = n$. Po pravilu \rulename{TyVal-Cons} velja $\Gamma_1, \Gamma_3, \Gamma_2, \types V \of A$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-T}, potem je $V = true$. Po pravilu \rulename{Ty-Cons-T} velja $\Gamma_1, \Gamma_3, \Gamma_2, \bb \types V \of A$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-F}, potem je $V = false$. Po pravilu \rulename{Ty-Cons-F} velja $\Gamma_1, \Gamma_3, \Gamma_2, \bb \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Unit}, potem je $V = ()$. Po pravilu \rulename{TyVal-Unit} velja $\Gamma_1, \Gamma_3, \Gamma_2, \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Pair}, potem je $V =\tmpair{V_1}{V_2}$.
		Po indukcijski predpostavki imata $V_1$ in $V_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Pair} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inl}, potem je $V = \tminl{V_1}$.
		Po indukcijski predpostavki ima $V_1$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Inl} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inr}, potem je $V = \tminl{V_2}$.
		Po indukcijski predpostavki ima $V_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Inr} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun}, potem je $V = \tmfun{x}{M}$.
		Po lemi~\ref{lem:weakening-comp-bb} ima $M$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Fun} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun-Rec}, potem je $V = \tmfun{x}{M}$.
		Po lemi~\ref{lem:weakening-comp-bb} ima $M$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Fun-Rec} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Promise}, potem je $V =\tmpromise{V'}$.
		Po indukcijski predpostavki ima $V'$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Promise} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Boxed}, potem je $V = \tmboxed{V'}$.
		Po indukcijski predpostavki ima $V'$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Boxed} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
	\end{itemize}
\end{proof}

\begin{lema}\label{lem:weakening-comp-bb}
	Naj za izračun $M$ velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$, kjer $\Gamma_2$ vsebuje $\bb$.
	Za vsak kontekst $\Gamma_3$, ki vsebuje le $\bb$ in sveže spremenljivke glede na $\Gamma_1$ in $\Gamma_2$, velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Return}, potem je $M$ enak $$\tmreturn{V}.$$
		Po lemi~\ref{lem:weakening-values-bb} ima $V$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Return} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $$\tmlet{x}{N_1}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Let} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchEmpty}, potem je $M$ enak $$\tmmatch{V}{}.$$
		Po lemi~\ref{lem:weakening-values-bb} ima $V$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-MatchEmpty} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchPair}, potem je $M$ enak $$\tmmatch{V}{(x_1,x_2) \mapsto N}.$$ 
		Po lemi~\ref{lem:weakening-values-bb} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-MatchPair} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchSum}, potem je $M$ enak $$\tmmatch{V}{\tminl{x_1} \mapsto N_1, \tminr{x_2} \mapsto N_2}.$$
		Po lemi~\ref{lem:weakening-values-bb} ima $V$ isti tip v razširjenem kontekstu.potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Run}. Tip $C$ je oblike $\tyrun{A}{\o, \i}$.
		Izračun $M$ ima tip $\tycomp{B}{\o', \i'}$ in $N$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyProc-Par} ima $P'$ tip $\typar{\tycomp{A}{\o, \i}}{\tycomp{B}{\o', \i'}}$, kjer je $C$ naredil korak \rulename{TyRedu-Spawn-R}.
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-MatchSum} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Apply}, potem je $M$ enak $$V_1 V_2.$$
		Po lemi~\ref{lem:weakening-values-bb} imata $V_1$ in $V_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Apply} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Signal}, potem je $M$ enak $$\tmopout{op}{V}{N}.$$
		Po lemi~\ref{lem:weakening-values-bb} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Signal} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Interrupt}, potem je $M$ enak $$\tmopin{op}{V}{N}.$$
		Po lemi~\ref{lem:weakening-values-bb} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Interrupt} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-RecPromise}, potem je $M$ enak $$\tmwithrec{op}{x}{r}{N_1}{p}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-RecPromise} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Await}, potem je $M$ enak $$\tmawait{V}{y}{N}.$$
		Po lemi~\ref{lem:weakening-values-bb} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Await} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Subsume}, ima po indukcijski predpostavki $M$ isti tip v razširjenem kontekstu.
		
	\end{itemize}
\end{proof}


\begin{lema}\label{lem:weakening-values-prenosljiv}
	Naj za vrednost $V$ velja $\Gamma_1, \Gamma_2 \types V \of A$. Če je $A$ prenosljiv tip, velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$ za vsak kontekst $\Gamma_3$, ki vsebuje le $\bb$ in sveže spremenljivke glede na $\Gamma_1$ in $\Gamma_2$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, \Gamma_2 \types V \of A$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item[\sitem] Če je zadnje pravilo \rulename{TyVal-Var'}, potem je $V = x$ in velja $x \in \Gamma_1$ ali $x \in \Gamma_2$.
		Ker je $A$ prenosljiv tip velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$ po pravilu \rulename{TyVal-Var'}
		
		\item Če je zadnje pravilo \rulename{TyVal-Cons}, potem je $V = n$. Po pravilu \rulename{TyVal-Cons} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-T}, potem je $V = true$. Po pravilu \rulename{Ty-Cons-T} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-F}, potem je $V = false$. Po pravilu \rulename{Ty-Cons-F} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Unit}, potem je $V = ()$. Po pravilu \rulename{TyVal-Unit} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Pair}, potem je $V =\tmpair{V_1}{V_2}$. Po indukcijski predpostavki imata $V_1$ in $V_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Pair} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inl}, potem je $V = \tminl{V_1}$. Po indukcijski predpostavki ima $V_1$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Inl} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inr}, potem je $V = \tminl{V_2}$. Po indukcijski predpostavki ima $V_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Inr} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Fun}, saj v tem primeru $A$ ni prenosljiv.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Fun-Rec}, saj v tem primeru $A$ ni prenosljiv.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Promise}, saj v tem primeru $A$ ni prenosljiv.
		
		\item Če je zadnje pravilo \rulename{TyVal-Boxed}, potem je $V = \tmboxed{V'}$.
		Po lemi~\ref{lem:weakening-values-bb} ima $V'$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Boxed} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
	\end{itemize}
\end{proof}

Sledeči lemi o substituciji za vrednosti in izračune se nanašata ena na drugo. Povesta nam, da če v nekem izrazu spremenljivko zamenjamo z neko drugo vrednostjo istega tipa, potem se tip izraza ne spremeni.

\begin{lema}[o substituciji za vrednosti]\label{lem:substitucija-vrednosti-2}
	Naj za vrednost $V$ velja $\Gamma_1 \types V \of A$ in za vrednost $W$ velja $\Gamma_1, x \of A, \Gamma_2 \types W \of B$. Potem velja $\Gamma_1, \Gamma_2 \types W[V/x] \of B$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, x \of A, \Gamma_2 \types W \of B$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	Primeri, ki so enaki kot v dokazu~\ref{lem:substitucija-vrednosti} so izpuščeni.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyVal-Var'}, potem je $W = y$.
		Ločimo dva primera.
		\begin{itemize}
			\item Če je $y = x$, potem je $A = B$ in $W[V/x] = x[V/x] = V$. Če je $A$ prenosljiv tip ima $W[V/x]$ tip $A$ po lemi~\ref{lem:weakening-values-prenosljiv}. Če $A$ ni prenosljiv tip, potem $\Gamma_2$ ne vsebuje $\bb$ in ima $W[V/x]$ tip $A$ po lemi~\ref{lem:weakening-values-2}.
			
			\item Če $y \neq x$, potem je $W[V/x] = y[V/x] = y = W$. Posledično ima $W[V/x]$ tip $B$.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyVal-Boxed}, potem je $W=\tmboxed{W'}$ in $B=\tyboxed{B'}$. Po indukcijski predpostavki ima $W'[V/x]$ tip $B'$. Ker je $W[V/x] = \tmboxed{W'[V/x]}$, ima $W[V/x]$ tip $B$, po pravilu \rulename{TyVal-Boxed}.
		
	\end{itemize}
\end{proof}

\begin{lema}[o substituciji za izračune]\label{lem:substitucija-izračuni-2}
	Naj za vrednost $V$ velja $\Gamma_1 \types V \of A$ in za izračun $M$ velja $\Gamma_1, x \of A, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$. Potem velja $\Gamma_1, \Gamma_2 \types M[V/x] \of \tycomp{B}{\o, \i}$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, x \of A, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	Primeri, ki so enaki kot v dokazu~\ref{lem:substitucija-izračuni} so izpuščeni.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Unbox}, potem je $M$ enak $$\tmunbox{W}{x}{N}.$$ Vrednost $W$ ima tip $B$ in izračun $N$ tip $\tycomp{B}{\o, \i}$.
		Po indukcijski predpostavki velja, da ima $N[V/x]$ isti tip. Po lemi~\ref{lem:substitucija-vrednosti-2} ima $W[V/x]$ isti tip. Ker je $M[V/x]$ enak $\tmunbox{W[V/x]}{x}{N[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Unbox}.
		
		\item Če je zadnje pravilo \rulename{TyComp-RecPromise}, potem je $M$ enak $$\tmwithrec{op}{r}{x}{N_1}{p}{N_2}.$$ Izračun $N_1$ ima tip $\tycomp{C}{\o', \i'}$ in $N_2$ tip $\tycomp{B}{\o, \i}$.
		Po indukcijski predpostavki velja, da imata $N_1[V/x]$ in $N_2[V/x]$ isti tip. Ker je $M[V/x]$ enak $\tmwithrec{op}{r}{x}{N_1[V/x]}{p}{N_2[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-RecPromise}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Spawn}, potem je $M$ enak $$\tmspawn{N_1}{N_2}.$$ Izračun $N_1$ ima tip $\tycomp{C}{\o', \i'}$ in $N_2$ tip $\tycomp{B}{\o, \i}$.
		Po indukcijski predpostavki velja, da imata $N_1[V/x]$ in $N_2[V/x]$ isti tip. Po pravilu \rulename{TyComp-Spawn} ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$.	
	\end{itemize}
	
\end{proof}

Sledeči lemi o krepitvi konteksta za vrednosti in izračune se nanašata ena na drugo.

\begin{lema}\label{lem:strengthening-values-promise}
	Naj za vrednost $V$ velja $\Gamma_1, p \of \typromise{A}, \Gamma_2 \types V \of B$, kjer $\Gamma_2$ vsebuje $\bb$. Potem velja $\Gamma_1, \Gamma_2 \types V \of B$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, p \of \typromise{A}, \Gamma_2 \types V \of B$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item[\sitem] Če je zadnje pravilo \rulename{TyVal-Var'}, potem je $V = x$.
		\begin{itemize}
			\item Če $x \in \Gamma_1$ ali $x \in \Gamma_2$, potem po pravilu \rulename{TyVal-Var'} velja $\Gamma_1, \Gamma_2 \types V \of B$.
			
			\item Primera ko je $x = p$ ne moremo imeti saj tip $\typromise{A}$ ni prenosljiv, v $\Gamma_2$ pa imamo $\bb$.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyVal-Cons}, potem je $V = n$. Po pravilu \rulename{TyVal-Cons} velja $\Gamma_1, \Gamma_2 \types V \of B$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-T}, potem je $V = true$. Po pravilu \rulename{Ty-Cons-T} velja $\Gamma_1, \Gamma_2, \bb \types V \of B$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-F}, potem je $V = false$. Po pravilu \rulename{Ty-Cons-F} velja $\Gamma_1, \Gamma_2, \bb \types V \of B$.

		\item Če je zadnje pravilo \rulename{TyVal-Unit}, potem je $V = ()$. Po pravilu \rulename{TyVal-Unit} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Pair}, potem je $V =\tmpair{V_1}{V_2}$.
		Po indukcijski predpostavki imata $V_1$ in $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Pair} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inl}, potem je $V = \tminl{V_1}$.
		Po indukcijski predpostavki ima $V_1$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Inl} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inr}, potem je $V = \tminl{V_2}$.
		Po indukcijski predpostavki ima $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Inr} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun}, potem je $V = \tmfunano{x}{M}$.
		Po lemi~\ref{lem:strengthening-comp-promise} ima $M$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Fun} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun-Rec}, potem je $V = \tmfunrecano{f}{x}{M}$.
		Po lemi~\ref{lem:strengthening-comp-promise} ima $M$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Fun-Rec} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Promise}, potem je $V = \tmpromise{V'}$.
		Po indukcijski predpostavki ima $V'$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Promise} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Boxed}, potem je $V = \tmboxed{V'}$.
		Po indukcijski predpostavki ima $V'$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Boxed} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
	\end{itemize}
\end{proof}

\begin{lema}\label{lem:strengthening-comp-promise}
	Naj za izračun $M$ velja $\Gamma_1, p \of \typromise{A}, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$, kjer $\Gamma_2$ vsebuje $\bb$. Potem velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, p \of \typromise{A}, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Return}, potem je $M$ enak $$\tmreturn{V}.$$
		Po lemi~\ref{lem:strengthening-values-promise} ima $V$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Return} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $$\tmlet{x}{N_1}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Let} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Apply}, potem je $M$ enak $$V_1 V_2.$$
		Po lemi~\ref{lem:strengthening-values-promise} imata $V_1$ in $V_2$ isti tip v skrčenempotem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Run}. Tip $C$ je oblike $\tyrun{A}{\o, \i}$.
		Izračun $M$ ima tip $\tycomp{B}{\o', \i'}$ in $N$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyProc-Par} ima $P'$ tip $\typar{\tycomp{A}{\o, \i}}{\tycomp{B}{\o', \i'}}$, kjer je $C$ naredil korak \rulename{TyRedu-Spawn-R}. kontekstu.
		Po pravilu \rulename{TyComp-Apply} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchPair}, potem je $M$ enak $$\tmmatch{V}{(x_1,x_2) \mapsto N}.$$ 
		Po lemi~\ref{lem:strengthening-values-promise} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-MatchPair} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchEmpty}, potem je $M$ enak $$\tmmatch{V}{}.$$
		Po lemi~\ref{lem:strengthening-values-promise} ima $V$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-MatchEmpty} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchSum}, potem je $M$ enak $$\tmmatch{V}{\tminl{x_1} \mapsto N_1, \tminr{x_2} \mapsto N_2}.$$
		Po lemi~\ref{lem:strengthening-values-promise} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-MatchSum} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Signal}, potem je $M$ enak $$\tmopout{op}{V}{N}.$$
		Po lemi~\ref{lem:strengthening-values-promise} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Signal} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Interrupt}, potem je $M$ enak $$\tmopin{op}{V}{N}.$$
		Po lemi~\ref{lem:strengthening-values-promise} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Interrupt} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-RecPromise}, potem je $M$ enak $$\tmwithrec{op}{x}{r}{N_1}{p}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-RecPromise} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Await}, potem je $M$ enak $$\tmawait{V}{y}{N}.$$
		Po lemi~\ref{lem:strengthening-values-promise} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Await} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Subsume}, ima po indukcijski predpostavki izračun $M$ isti tip v skrčenem kontekstu.
		
	\end{itemize}
\end{proof}

Prejšnji dve lemi smo potrebovali, da dokažemo sledečo lemo. Slednjo bomo potrebovali, da v korakih, kjer zamenjamo vrstni red recimo $$\tmwithrec{op}{x}{r}{N_1}{p}{\tmopout{op'}{V}{N_2}} \reduces $$ $$\tmopout{op'}{V}{\tmwithrec{op}{x}{r}{N_1}{p}{N_2}},$$ se tip $V$ ne spremeni in posledično ima tudi nov izračun tip.

\begin{lema}\label{lem:tovor-osnovni-tip-skrcitev-2}
	Naj za vrednost $V$ velja $\Gamma_1, p \of \typromise{A}, \Gamma_2 \types V \of B$, kjer je $B$ prenosljiv tip. Potem velja $\Gamma_1, \Gamma_2 \types V \of B$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, p \of \typromise{A}, \Gamma_2 \types V \of B$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item[\sitem] Če je zadnje pravilo \rulename{TyVal-Var'}, potem je $V = x$. Ker $\typromise{A}$ ni prenosljiv tip, velja $x \in \Gamma_1$ ali $x \in \Gamma_2$.
		Po pravilu \rulename{TyVal-Var'} velja $\Gamma_1, \Gamma_2, \bb \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Cons}, potem je $V = n$. Po pravilu \rulename{TyVal-Cons} velja $\Gamma_1, \Gamma_2 \types V \of B$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-T}, potem je $V = true$. Po pravilu \rulename{Ty-Cons-T} velja $\Gamma_1, \Gamma_2 \types V \of B$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-F}, potem je $V = false$. Po pravilu \rulename{Ty-Cons-F} velja $\Gamma_1, \Gamma_2 \types V \of B$.

		\item Če je zadnje pravilo \rulename{TyVal-Unit}, potem je $V = ()$. Po pravilu \rulename{TyVal-Unit} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Pair}, potem je $V =\tmpair{V_1}{V_2}$.
		Po indukcijski predpostavki imata $V_1$ in $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Pair} velja $\Gamma_1, \Gamma_2, \bb \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inl}, potem je $V = \tminl{V_1}$.
		Po indukcijski predpostavki ima $V_1$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Inl} velja $\Gamma_1, \Gamma_2, \bb \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inr}, potem je $V = \tminl{V_2}$.
		Po indukcijski predpostavki ima $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Inr} velja $\Gamma_1, \Gamma_2, \bb \types V \of B$.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Fun}, saj v tem primeru $B$ ni prenosljiv.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Fun-Rec}, saj v tem primeru $B$ ni prenosljiv.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Promise}, saj v tem primeru $B$ ni prenosljiv.
		
		\item Če je zadnje pravilo \rulename{TyVal-Boxed}, potem je $V = \tmboxed{V'}$.
		Po lemi~\ref{lem:strengthening-values-promise} ima $V'$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Boxed} velja $\Gamma_1, \Gamma_2, \bb \types V \of B$.
		
	\end{itemize}
\end{proof}

Sledeči lemi o krepitvi konteksta za vrednosti in izračune se nanašata ena na drugo. Če odstranimo $\bb$, ki nas omejuje na mobilni pogled na kontekst $\Gamma_1$, se tip ne spremeni.

\begin{lema}\label{lem:strengthening-values-bb}
	Naj za vrednost $V$ velja $\Gamma_1, \bb, \Gamma_2 \types V \of A$. Tedaj velja $\Gamma_1, \Gamma_2 \types V \of A$.
\end{lema}


\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, \bb, \Gamma_2 \types V \of A$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item[\sitem] Če je zadnje pravilo \rulename{TyVal-Var'}, potem je $V = x$ in velja $x \in \Gamma_1$ ali $x \in \Gamma_2$.
		Po pravilu \rulename{TyVal-Var'} velja $\Gamma_1, \Gamma_2 \types V \of A$.

		\item Če je zadnje pravilo \rulename{TyVal-Boxed}, potem je $V = \tmboxed{V'}$.
		Po indukcijski predpostavki ima $V'$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Boxed} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Cons}, potem je $V = n$. Po pravilu \rulename{TyVal-Cons} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Unit}, potem je $V = ()$. Po pravilu \rulename{TyVal-Unit} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Pair}, potem je $V =\tmpair{V_1}{V_2}$.
		Po indukcijski predpostavki imata $V_1$ in $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Pair} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Promise}, potem je $V = \tmpromise{V'}$.
		Po indukcijski predpostavki ima $V'$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Promise} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inl}, potem je $V = \tminl{V_1}$.
		Po indukcijski predpostavki ima $V_1$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Inl} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inr}, potem je $V = \tminl{V_2}$.
		Po indukcijski predpostavki ima $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Inr} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun}, potem je $V = \tmfunano{x}{M}$.
		Po lemi~\ref{lem:strengthening-comp-bb} ima $M$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Fun} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun-Rec}, potem je $V = \tmfunrecano{f}{x}{M}$.
		Po lemi~\ref{lem:strengthening-comp-bb} ima $M$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Fun-Rec} velja $\Gamma_1, \Gamma_2 \types V \of A$.
		
	\end{itemize}
\end{proof}

\begin{lema}\label{lem:strengthening-comp-bb}
	Naj za izračun $M$ velja $\Gamma_1, \bb, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$. Tedaj velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma_1, \bb, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Return}, potem je $M$ enak $$\tmreturn{V}.$$
		Po lemi~\ref{lem:strengthening-values-bb} ima $V$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Return} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $$\tmlet{x}{N_1}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Let} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Apply}, potem je $M$ enak $$V_1 V_2.$$
		Po lemi~\ref{lem:strengthening-values-bb} imata $V_1$ in $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Apply} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchPair}, potem je $M$ enak $$\tmmatch{V}{(x_1,x_2) \mapsto N}.$$ 
		Po lemi~\ref{lem:strengthening-values-bb} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-MatchPair} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchEmpty}, potem je $M$ enak $$\tmmatch{V}{}.$$
		Po lemi~\ref{lem:strengthening-values-bb} ima $V$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-MatchEmpty} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchSum}, potem je $M$ enak $$\tmmatch{V}{\tminl{x_1} \mapsto N_1, \tminr{x_2} \mapsto N_2}.$$
		Po lemi~\ref{lem:strengthening-values-bb} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-MatchSum} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Signal}, potem je $M$ enak $$\tmopout{op}{V}{N}.$$
		Po lemi~\ref{lem:strengthening-values-bb} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Signal} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Interrupt}, potem je $M$ enak $$\tmopin{op}{V}{N}.$$
		Po lemi~\ref{lem:strengthening-values-bb} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Interrupt} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-RecPromise}, potem je $M$ enak $$\tmwithrec{op}{x}{r}{N_1}{p}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-RecPromise} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Await}, potem je $M$ enak $$\tmawait{V}{y}{N}.$$
		Po lemi~\ref{lem:strengthening-values-bb} ima $V$ isti tip v skrčenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyComp-Await} velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Subsume}, ima po indukcijski predpostavki izračun $M$ isti tip v skrčenem kontekstu.
		
	\end{itemize}
\end{proof}

Tudi sedaj bomo potrebovali lemo o inverziji. Vse točke iz leme~\ref{lem:inversion-lema} veljajo tudi sedaj, vendar jih ne naštejemo še enkrat.

\begin{lema}\label{lem:inversion-lema-2}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$. Potem obstaja $(\o', \i') \order{O, I} (\o, \i)$.
	\begin{itemize}
		\item Če je $M$ oblike $\tmwithrec{op}{x}{r}{N_1}{p}{N_2}$, potem velja $\Gamma, x \of B_{op}, r \of \tyfun{\tyunit}{\tycomp{\typromise{B}}{\emptyset, \op \mapsto (\o'', \i'')}} \types N_1 \of \tycomp{\typromise{B}}{\o'', \i''}$ in $\Gamma, p \of \typromise{B} \types N_1 \of \tycomp{A}{\o', \i'}$ in $(\o'',\i'') \order{O \times I} i'(op)$.
		
		\item Če je $M$ oblike $\tmunbox{V}{x}{N}$, potem velja $\Gamma \types V \of \tyboxed{B}$ in $\Gamma, x \of A \types N \of \tycomp{A}{\o', \i'}$.
		
		\item Če je $M$ oblike $\tmspawn{N_1}{N_2}$, potem velja $\Gamma, \bb \types N_1 \of \tycomp{B}{\o'', \i''}$ in $\Gamma \types N_2 \of \tycomp{A}{\o', \i'}$.
	\end{itemize}
\end{lema}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave za $\Gamma \types M \of \tycomp{A}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-RecPromise}, \rulename{TyComp-Unbox} ali \rulename{TyComp-Spawn}, potem ustrezna točka leme sledi za $(\o', \i') = (\o, \i)$.
		
		\item Če je zadnje uporabljeno pravilo \rulename{TyComp-Subsume}, potem ima $M$ tudi tip $\tycomp{A}{\o', \i'}$. Po indukcijski predpostavki direktno na $M$ lema sledi, saj je $\order{O, I}$ tranzitiven.
	\end{itemize}
\end{proof}


\begin{trditev}[o ohranitvi]\label{trd:ohranitev-izracuni-2}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$. Če izračun $M$ naredi korak $M \reduces M'$, potem velja $\Gamma \types M' \of \tycomp{A}{\o, \i}$.
\end{trditev}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave koraka $M \reduces M'$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	Primeri, ki so enaki kot v dokazu~\ref{trd:ohranitev-izracuni} so izpuščeni.

	\begin{itemize}
		\item Če je zadnje pravilo $$\tmunbox{[V]}{x}{N} \reduces N[V/x],$$ potem ima po lemi~\ref{lem:inversion-lema-2} vrednost $\tmboxed{V}$ tip $\tyboxed{B}$ in $N$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:strengthening-values-bb} ima $V$ tip $B$ tudi v kontekstu brez $\bb$.
		Po lemi~\ref{lem:substitucija-izračuni-2} ima $M' = N[V/x]$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmlet{x}{(\tmwithrec{op}{y}{r}{N_1}{p}{N_2})}{N_3} \reduces $$ $$ \tmwithrec{op}{y}{r}{N_1}{p}{(\tmlet{x}{N_2}{N_3})},$$ potem ima po lemi~\ref{lem:inversion-lema-2} izračun $N_1$ tip $\tycomp{B_1}{\o'', \i''}$, $N_2$ tip $\tycomp{B_2}{\o', \i'}$ in $N_3$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Let} in lemi~\ref{lem:weakening-comp-2} ima $\tmlet{x}{N_2}{N_3}$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-RecPromise} ima $M'$ tip $\tycomp{A}{\o', \i'}$.
		
		\item Če je zadnje pravilo $$\tmwithrec{op}{x}{r}{N_1}{p}{\tmopout{op'}{V}{N_2}} \reduces $$ $$\tmopout{op'}{V}{\tmwithrec{op}{x}{r}{N_1}{p}{N_2}},$$ potem ima po lemi~\ref{lem:inversion-lema-2} izračun $N_1$ tip $\tycomp{B}{\o'', \i''}$, $V$ tip $C_{op'}$ in $N_2$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-RecPromise} ima $\tmwithrec{op}{x}{r}{N_1}{p}{N_2}$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:tovor-osnovni-tip-skrcitev-2} ima $V$ še zmeraj tip $C_{op}$ tudi v manjšem kontekstu.
		Po pravilu \rulename{TyComp-Signal} ima $M'$ tip $\tycomp{A}{\o', \i'}$.
		
		\item Če je zadnje pravilo $$\tmopin{op}{V}{\tmwithrec{op}{x}{r}{N_1}{p}{N_2}} \reduces $$ $$ \tmlet{p}{N_1[V/x, R/r]}{\tmopin{op}{V}{N_2}},$$ potem ima po lemi~\ref{lem:inversion-lema-2} vrednost $V$ tip $B_{op}$, $N_1$ tip $\tycomp{\typromise{B}}{\o'', \i''}$, $N_2$ tip $\tycomp{A}{\o', \i'}$, $(\o'', \i'') \order{O \times I} i'(\op)$ in $\opincomp{op}{(\o', \i')} \order{O \times I} (\o, \i)$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N_2}$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
		Ker velja $(\o'', \i'') \order{O \times I} \i'(op)$, velja $(\o'', \i'') \order{O \times I} \opincomp{op}{(\o', \i')}$ po lastnosti~\ref{lem:eo2-1} leme~\ref{lem:effects-order-2}.
		Posledično ima po pravilu \rulename{TyComp-Subsume} in lemi~\ref{lem:substitucija-izračuni-2} izračun $N_1[V/x]$ tip $\tycomp{\typromise{B}}{\opincomp{op}{(\o', \i')}}$.
		Po lemi~\ref{lem:substitucija-izračuni-2} ima $(N_1[V/x])[R/r]$ tip $\tycomp{\typromise{B}}{\opincomp{op}{(\o', \i')}}$, saj ima $R$ isti tip kot spremenljivka $r$.
		Po pravilu \rulename{TyComp-Let} ima $M'$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmopin{op'}{V}{\tmwithrec{op}{x}{r}{N_1}{p}{N_2}} \reduces $$ $$ \tmwithrec{op}{x}{r}{N_1}{p}{\tmopin{op'}{V}{N_2}},$$ potem ima po lemi~\ref{lem:inversion-lema-2} vrednost $V$ tip $B_{op}$, $N_1$ tip $\tycomp{\typromise{B}}{\o'', \i''}$, $N_2$ tip $\tycomp{A}{\o', \i'}$, $(\o'', \i'') \order{O \times I} i'(\op)$ in $\opincomp{op}{(\o', \i')} \order{O \times I} (\o, \i)$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N_2}$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
		Po točki~\ref{lem:eo2-2} leme~\ref{lem:effects-order-2} velja $(\o'', \i'') \order{O \times I} (\pi_2(\opincomp{\op}{(\o', \i')}))(\op)$.
		Po pravilu \rulename{TyComp-RecPromise} ima $M'$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.

		\item Če je zadnje pravilo $$\tmlet{x}{(\tmspawn{N_1}{N_2})}{N_3} \reduces \tmspawn{N_1}{\tmlet{x}{N_2}{N_3}},$$ potem ima po lemi~\ref{lem:inversion-lema-2} izračun $N_1$ tip $\tycomp{\typromise{B'}}{\o'', \i''}$, $N_2$ tip $\tycomp{B}{\o', \i'}$ in $N_3$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Let} ima $\tmlet{x}{N_2}{N_3}$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Spawn} ima $M'$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.

		\item Če je zadnje pravilo $$\tmwithrec{op}{x}{r}{N_1}{p}{\tmspawn{N_2}{N_3}} \reduces $$ $$ \tmspawn{N_2}{\tmwithrec{op}{x}{r}{N_1}{p}{N_3}},$$ potem ima po lemi~\ref{lem:inversion-lema-2} izračun $N_1$ tip $\tycomp{\typromise{B}}{\o'', \i''}$, $N_2$ tip $\tycomp{C}{\o''', \i'''}$ in $N_3$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-RecPromise} ima $\tmwithrec{op}{x}{r}{N_1}{p}{N_3}$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:strengthening-comp-promise} ima $N_2$ tip $\tycomp{C}{\o''', \i'''}$ tudi v manjšem kontekstu.
		Po pravilu \rulename{TyComp-Spawn} ima $M'$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.

		\item Če je zadnje pravilo $$\tmopin{op}{V}{\tmspawn{N_1}{N_2}} \reduces \tmspawn{N_1}{\tmopin{op}{V}{N_2}},$$ potem ima po lemi~\ref{lem:inversion-lema-2} vrednost $V$ tip $B$, $N_1$ tip $\tycomp{C}{\o'', \i''}$, $N_2$ tip $\tycomp{A}{\o', \i'}$ in $\opincomp{op}{(\o', \i')} \order{O \times I} (\o, \i)$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N_2}$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
		Po pravilu \rulename{TyComp-Spawn} ima $M'$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
	\end{itemize}
	
\end{proof}


Ko iz enega procesa ustvarimo dva paralelna procesa, se temu primerno tip spremeni v paralelni tip. 
Pravilom za spremembo tipa na sliki~\ref{fig:process-type-reductions} dodamo pravili na sliki~\ref{fig:process-type-reductions-spawn}.
V pravilih namenoma ni uporabljen splošen tip procesa, saj le proces $\tmrun{M}$ lahko ustvari nov proces. Prav tako mora novo ustvarjeni proces biti oblike $\tmrun{N}$. 

\begin{figure}[H]
	\centering
	\begin{mathpar}
		\coopinfer{TyRedu-Spawn-L}{
		}{
			\tyrun{A}{\o, \i} \tyreduces \typar{\tyrun{A'}{\o', \i'}}{\tyrun{A}{\o, \i}}
		}	
		\quad
		\coopinfer{TyRedu-Spawn-R}{
		}{
			\tyrun{A}{\o, \i} \tyreduces \typar{\tyrun{A}{\o, \i}}{\tyrun{A'}{\o', \i'}}
		}
	\end{mathpar}
	\caption{Dodatna pravila za spremembo tipov.}
	\label{fig:process-type-reductions-spawn}
	
\end{figure}

\begin{izrek}[o ohranitvi]\label{izr:ohranitev-2}
	Naj za proces $P$ velja $\Gamma \types P \of C$. Če proces $P$ naredi korak $P \reduces P'$, potem obstaja tak $C'$, da velja $C \tyreduces C'$ in $\Gamma \types P' \of C'$.
\end{izrek}


\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave koraka $P \reduces P'$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	Primeri, ki so enaki kot v dokazu~\ref{izr:ohranitev} so izpuščeni.
	
	\begin{itemize}
		
		\item Če je zadnje uporabljeno pravilo
		$$\tmrun{(\tmspawn{M}{N})} \reduces \tmpar{\tmrun{M}}{\tmrun{N}},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Run}. Tip $C$ je oblike $\tyrun{A}{\o, \i}$.
		Izračun $M$ ima tip $\tycomp{B}{\o', \i'}$ in $N$ tip $\tycomp{A}{\o, \i}$.
		Po lemi~\ref{lem:strengthening-comp-bb} ima $M$ isti tip tudi v kontekstu brez $\bb$.
		Po pravilu \rulename{TyProc-Par} ima $P'$ tip $\typar{\tycomp{B}{\o', \i'}}{\tycomp{A}{\o, \i}}$, kjer je $C$ naredil korak \rulename{TyRedu-Spawn-L}.
		
		\item Če je zadnje uporabljeno pravilo
		$$\tmrun{(\tmspawn{M}{N})} \reduces \tmpar{\tmrun{N}}{\tmrun{M}},$$
		je dokaz podoben, kot v prejšnji točki.
	\end{itemize}

\end{proof}



