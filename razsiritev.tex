\section{Razširjen \lae{}}\label{sec:razsirjen-lae}

Poglejmo si primer~\ref{prog:razsiritev-0}, ki bi ga lahko napisali v \aeff{}, ki pripada osnovni verziji \lae{}\nobreakdash-računa. V primeru se dve pomožni vrednosti poračunata v drugem procesu, medtem ko se glavni proces nadaljuje. 
Primer si lahko predstavljamo kot program, ki v pomožnem procesu poračuna časovno zahteven del, med tem ko glavni proces nemoteno nadaljuje delo.
%Primer si lahko predstavljamo, kot klient, ki pošlje zahtevo na strežnik, le ta pa mu odgovori. 
%Ali pa kot program, ki v pomožnem procesu poračuna računsko zahteven del, med tem ko glavni proces nemoteno nadaljuje delo.

\jR{Kaj smo potem rekli glede [ ] ki je hkrati seznam in boxed???}

\begin{lstlisting}[caption={Računanje zahtevne funkcije v ozadju.},label={prog:razsiritev-0},float,floatplacement=h]
operation call : int * int * int
operation result : int * int

let callWith =
	fun callCounter fNo x ->
		let callNo = !callCounter in
		send call (callNo, fNo, x);
		callCounter := callNo + 1;
		promise (result (callNo', y) when callNo = callNo' ->
			return <y>
		) as p in
		let valueThunk () = awaitValue p in
		return valueThunk

let remote fList =
	let rec loop () =
		promise (call (callNo, fNo, x) ->
			let f = fList[fNo] in
			let y = f x in
			send result (callNo, y);
			loop ()
		) as p in
		return p
	in
	loop ()

run	let callCounter = ref 0 in
	let y1 = callWith callCounter 0 2 in
	let y2 = callWith callCounter 1 3 in
	let z = 42 + 7 in
	return y1 () + y2 () + z

run remote (fun x |-> 2 * x)::(fun x |-> 7 * x)::[]
\end{lstlisting}

Ta primer, ima nekaj problemov. Prvi je, da, ker ne moremo pošiljati funkcij, mora imeti \emph{remote} vse funkcije v naprej podane. Temu se bomo izognili z prenosljivimi tipi.

\subsection{Prenosljivi tipi}

Ko imamo nek signal, je ključno, da tovor ne vsebuje vrednosti obljuba, kar smo do sedaj rešili tako, da smo omejili signale na osnovne tipe. Glavni problem tega pristopa je, da funkcijski tip ni med osnovnimi tipi in posledično ne moremo poslati funkcij. Ta problem rešimo z uvedbo \emph{zavite vrednosti} in \emph{zaviti tipi}. Zavite vrednosti bodo lahko tudi lambda funkcije, ki ne bodo vsebovale zunanjih obljub. Posledično jih bo varno poslati. Osnovne tipe skupaj z zavitim tipom imenujemo \emph{prenosljivi tipi}. Da bomo lahko zavito vrednost tudi uporabili, dodamo izračun \emph{odvijanje}, ki iz zavite vrednosti odvije pripadajočo vrednost in jo veže na spremenljivko.

Tipi za izračune in procese ostanejo enaki.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Vrednosti}}
	V
	\bnfis& ...                            & &\text{obstoječe vrednosti} \\
	\bnfor& \tmboxed{V}  & &\text{zavita vrednost}
	\intertext{\textbf{Izračuni}}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmunbox{V}{x}{M}  & &\text{odvijanje}
	\end{align*}
	
	\caption{Prenosljivi izrazi.}
	\label{fig:izrazi-prenosljivi}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\text{Prenosljivi tipi vrednosti $\tymobile{A}$, $\tymobile{B}$}
	\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tysum{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tyboxed{A}
	\\%[1ex]
	\text{Tipi vrednosti $A$, $B$}
	\bnfis & \tymobile{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
	\end{align*}
%	\vspace{-5ex}
%	\begin{align*}
%	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_k})
%	\end{align*}
	
	\caption{Prenosljivi tipi.}
	\label{fig:tipi-prenosljivi}
\end{figure}

Sedaj vsaki operaciji namesto osnovnega tipa pripada prenosljiv tip.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_k})
	\end{align*}
	\vspace{-5ex}
	\caption{Operacije z pripadajočimi prenosljivimi tipi.}
	\label{fig:prenosljive-operacije}
\end{figure}

Izračun odvijanje veže vrednost znotraj zavite vrednosti $\tmboxed{V}$ na spremenljivko $x$, ki jo lahko uporabimo v kontinuaciji $M$.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmunbox{[V]}{x}{M} &\reduces M[V/x]
	\end{align*}
	
	\caption{Operacijska semantika odvijanja.}
	\label{fig:semantika-odvijanje}
\end{figure}

Da zagotovimo, da ne bi kakšni vrednosti, ki vsebuje zunanjo obljubo, dodelili zavit tip, nekoliko spremenimo pravilo za izračun tipa spremenljivke in dodamo pravili za zavito vrednost in izračun odvijanje.
Sedaj bo vrstni red v okolju pomemben, zato je okolje od sedaj naprej urejen seznam. Ko določamo tip zavite vrednosti, v okolje dodamo $\bb$. S tem za v bodoče označimo katere spremenljivke so zunanje ali notranje glede na zavito vrednost. 
Če je spremenljivka notranja, torej od kar smo jo dodali v okolje, nismo dodali nobenega $\bb$, je pravilo standardno. Če je spremenljivka zunanja, torej od kar je bila dodana v okolje, je bil v okolje dodan tudi $\bb$, mora biti pripadajoči tip v okolju prenosljiv.

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{Ty-Var'}{
			\text{A prenosljiv ali } \bb \notin \Gamma'
		}{
			\Gamma, x \of A, \Gamma' \types x \of A
		}
		\quad
		\coopinfer{Ty-Boxed}{
			\Gamma, \bb \types V \of A
		}{
			\Gamma \types \tmboxed{V} \of \tyboxed{A}
		}
		\quad
		\coopinfer{TyComp-Unbox}{
			\Gamma \types V \of \tyboxed{A} \\ \Gamma, x \of A \types M \of \tycomp{B}{\o, \i}
		}{
			\Gamma \types \tmunbox{V}{x}{M} \of \tycomp{B}{\o, \i}
		}
	\end{mathpar}
	
	\caption{Dodatna pravila za določanje tipov.}
	\label{fig:tipi-pravila-prenosljivi}
\end{figure} 

Sedaj lahko program~\ref{prog:razsiritev-0} spremenimo v program~\ref{prog:razsiritev-1}. Namesto, da ima \emph{remote} statičen seznam funkcij, ki jih lahko poračuna, preprosto dobi funkcijo, kot del tovora.  

\begin{lstlisting}[caption={Računanje zahtevne funkcije v ozadju.},label={prog:razsiritev-1},float,floatplacement=h]
operation call : int * [int -> int] * int
operation result : int * int

let callWith =
	fun callCounter fBoxed x ->
		let callNo = !callCounter in
		send call (callNo, fBoxed, x);
		callCounter := callNo + 1;
		promise (result (callNo', y) when callNo = callNo' ->
			return <y>
		) as p in
		let valueThunk () = awaitValue p in
		return valueThunk

let remote () =
	let rec loop () =
		promise (call (callNo, fBoxed, x) ->
			unbox fBoxed as [f] in
			let y = f x in
			send result (callNo, y);
			loop ()
		) as p in
		return p
	in
	loop ()

run	let callCounter = ref 0 in
let y1 = callWith callCounter [fun x |-> 2 * x] 2 in
let y2 = callWith callCounter [fun x |-> 7 * x] 3 in
let z = 42 + 7 in
return y1 () + y2 () + z

run remote ()
	
\end{lstlisting}


\subsection{Rekurzivni prestreznik}


%%% v rekurzivni obljubi za efekte je dovolj da so podmnožica ne nujno ekvivalenca kot je v papirju.


Kadar pričakujemo več prekinitev z isto operacijo, je lahko iz različnih razlogov za programerja priročno, če ima na voljo prestreznik, ki se po potrebi ponovno namesti. Lahko, da je namen prestreznika, da na vsako prekinitev odgovori z signalom. Lahko nam prihajajoča prekinitev prinese pravo operacijo, vendar ne pravega pripadajočega tovora, zato obljube še nočemo izpolniti, in čakamo na naslednjo prekinitev.

To funkcionalnost smo do sedaj dosegli tako, da smo obljubo definirali v pomožni rekurzivni funkciji in po potrebi znotraj obljube ponovno klicali to funkcijo, kot lahko vidimo v programu~\ref{prog:razsiritev-2}.


Predvsem z namenom bolj pregledne kode nadomestimo obstoječi prestreznik z rekurzivnim prestreznikom. Le ta ima poleg imena operacije $op$, tovora $x$, obljube $M$ in kontinuacije $N$ tudi spremenljivko $f$. Pripadajočo sintakso vidimo na sliki~\ref{fig:izrazi-prestreznik}.


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmwithrec{op}{r}{x}{M}{p}{N}  & &\text{rekurzivni prestreznik}
	\end{align*}
 
	\caption{Izračuni z rekurzivnim prestreznikom}
	\label{fig:izrazi-prestreznik}
\end{figure}


Operacijska semantika rekurzivnega prestreznika je zelo podobna prejšnji verziji. S to izjemo da, ko ustrezna prekinitev pride do prestreznika, le ta v obljubi $M$ naredi dve substituciji. Tako kot prej spremenljivko $x$ substituira z vrednostjo $V$, dodatno pa spremenljivko $f$ substituira z lambda funkcijo $F$, ki sprejme enoto in vrne svežo kopijo prestreznika. Znotraj $M$ lahko uporabimo $F$ in tako ponovno namestimo prestreznik.   


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmlet{x}{(\tmwithrec{op}{r}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwithrec{op}{r}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\\
	\tmwithrec{op}{r}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwithrec{op}{r}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmwithrec{op}{r}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x, R/r]}{\tmopin{op}{V}{N}} \\
	R = \;& \tmfunano{y}{(\tmwithrec{op}{r}{x}{M}{p}{\tmreturn{p}})} \\
	\tmopin{op'}{V}{\tmwithrec{op}{r}{x}{M}{p}{N}} &\reduces \tmwithrec{op}{r}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\end{align*}
	
	\caption{Operacijska semantika rekurzivnega prestreznika}
	\label{fig:semantika-prestreznik}
\end{figure}

Tudi pravilo za tip rekurzivnega prestreznika je zelo podobno prvotnemu prestrezniku.

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyComp-RecPromise}{
			\i\, (\op) \order{O \times I} ({\o'} , {\i'}) \\
			\Gamma, x \of \tymobile{A}_\op, r \of \tyfun{\tyunit}{\tycomp{\typromise{B}}{\o', \i'}} \types M : \tycomp{\typromise B}{\o',\i'} \\
			\Gamma, p \of \typromise B \types N : \tycomp{C}{\o,\i}
		}{
			\Gamma \types \tmwithrec{op}{x}{r}{M}{p}{N} \of \tycomp{C}{\o, \i}
		}
	\end{mathpar}
	
	\caption{Pravilo za izračun tipa rekurzivnega prestreznika.}
	\label{fig:tipi-pravila-rekurzivni-prestreznik}
\end{figure} 

Program~\ref{prog:razsiritev-2} ima isti semantičen pomen kot program~\ref{prog:razsiritev-1}, le da je tokrat napisan z rekurzivno obljubo.

\begin{lstlisting}[caption={Primer z rekurzivnim prestreznikom},label={prog:razsiritev-2},float,floatplacement=h]
operation call : int * [int -> int] * int
operation result : int * int

let callWith =
	fun callCounter fBoxed x ->
		let callNo = !callCounter in
		send call (callNo, fBoxed, x);
		callCounter := callNo + 1;
		promise (result (callNo', y) when callNo = callNo' ->
			return <y>
		) as p in
		let valueThunk () = awaitValue p in
		return valueThunk

let remote () =
	promise (call f (callNo, fBoxed, x) ->
		unbox fBoxed as [f] in
		let y = f x in
		send result (callNo, y);
		f()
	) as _ in
	()

run	let callCounter = ref 0 in
	let y1 = callWith callCounter [fun x |-> 2 * x] 2 in
	let y2 = callWith callCounter [fun x |-> 7 * x] 3 in
	let z = 42 + 7 in
	return y1 () + y2 () + z

run remote ()
\end{lstlisting}


\subsection{Dinamični procesi}

Funkcije $f$ v remote call se potencialno izvaja zelo počasi. Zato si želimo, da bi vsak $remote klic$ lahko opravili v svojem procesu, da lahko izvajamo vzporedno namesto zaporedno. 
Do sedaj so bili procesi statični v smislu, da smo vse procese morali ustvariti na začetku.
Posledično bi morali vnaprej vedeti, koliko klicov bo remote hkrati dobil, da bi imeli temu primerno pripravljenih procesov.

Da rešimo ta problem, dodamo dinamično ustvarjanje novih procesov s pomočjo izračuna $\tmspawn{M}{N}$. 
Le ta se bo pomikal navzven. Ko bo postal zgornji izračun v procesu, se bo ta proces razcepil v dva procesa. 
Prvi proces bo izvajal izračun $M$, drugi pa bo izvajal nadaljevanje $N$.


\begin{figure}[h]	
	\centering
	\small
	\begin{align*}
	\shortintertext{\textbf{Izračuni}}
	M, N
	\bnfis & ... \,\bnfor\! \tmspawn{M}{N}
	\end{align*}
	
	\caption{Izračun $\tmkw{Spawn}$.}
	\label{fig:izračun-spawn}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmlet{x}{(\tmspawn{M_1}{M_2})}{N} & \reduces \tmspawn{M_1}{\tmlet{x}{M_2}{N}}
	\\
	\tmwithrec{op}{x}{r}{M}{p}{\tmspawn{N_1}{N_2}} & \reduces \tmspawn{N_1}{\tmwithrec{op}{x}{r}{M}{p}{N_2}}
	\\
	\tmopin{op}{V}{\tmspawn{M}{N}} & \reduces \tmspawn{M}{\tmopin{op}{V}{N}}
	\\
	\tmrun{(\tmspawn{M}{N})} & \reduces \tmpar{\tmrun{M}}{\tmrun{N}}
	\\
	\tmrun{(\tmspawn{M}{N})} & \reduces \tmpar{\tmrun{N}}{\tmrun{M}}
	\end{align*}
	
	\caption{Operacijska semantika dinamičnih procesov.}
	\label{fig:semantika-spawn}
\end{figure}


Ker se izračun $M$ v $\tmspawn{M}{N}$ lahko razširi mimo prestreznikov moramo paziti, da ima $M$ prenosljiv tip in je posledično varen.   

\begin{figure}[h]
	\centering
	\small
	\textbf{Pravila za tipe računov}
	\begin{mathpar}
		\coopinfer{TyComp-Spawn}{
			\Gamma, \blacksquare \types M : \tycomp{B}{\o', \i'} \\ \Gamma \types N : \tycomp{A}{\o, \i}
		}{
			\Gamma \types \tmspawn{M}{N} : \tycomp{A}{\o, \i}
		}
	\end{mathpar}
\end{figure}


Sedaj ko imamo dinamične procese, lahko obe evalvaciji funkcije $f$ opravimo hkrati v svojem procesu, kar potencialno pohitri izvajanje programa. Primer~\ref{prog:razsiritev-2} lahko sedaj spremenimo v~\ref{prog:razsiritev-3}. 

\begin{lstlisting}[caption={Primer z dinamičnimi procesi},label={prog:razsiritev-3},float,floatplacement=H]
operation call : int * [int -> int] * int
operation result : int * int

let callWith =
	fun callCounter fBoxed x ->
		let callNo = !callCounter in
		send call (callNo, fBoxed, x);
		callCounter := callNo + 1;
		promise (result (callNo', y) when callNo = callNo' ->
			return <y>
		) as p in
		let valueThunk () = awaitValue p in
		return valueThunk

let remote () =
	promise (call f (callNo, fBoxed, x) ->
		unbox fBoxed as [f] in
		spawn(
			let y = f x in
			send result (callNo, y)
		);
		f()
	) as _ in
	()

run	let callCounter = ref 0 in
let y1 = callWith callCounter [fun x |-> 2 * x] 2 in
let y2 = callWith callCounter [fun x |-> 7 * x] 3 in
let z = 42 + 7 in
return y1 () + y2 () + z

run remote ()
\end{lstlisting}


\subsection{Varnost}

Sedaj dokažemo izrek o varnosti za \lae{} razširjen z rekurzivnimi prestrezniki, prenosljivimi tipi, in dinamičnimi procesi.


\begin{figure}[H]
	\centering
	
	\textbf{Delni rezultati}
	\begin{mathpar}
		\coopinfer{R-Spawn}{
			\RunResult {\Psi} {N}
		}{
			\RunResult {\Psi} {\tmspawn{M}{N}}
		}
	\end{mathpar}
	

	\caption{Rezultati in delni rezultati.}
	\label{fig:results-rules}
\end{figure}


\begin{izrek}[o napredku]
	Naj za proces $P$ velja $\emptyset \types P \of C$. Potem ali (i) obstaja proces $P'$, tak da $P \reduces P'$, ali pa (ii) velja $\ProcResult{P}$.
\end{izrek}


\begin{lema}\label{lem:razsiritev-konteksta-2}
	Naj za vrednost $V$ velja $\Gamma_1 \types V \of A$. Če je $A$ prenosljiv tip velja $\Gamma_1, \Gamma_2 \types V \of A$ za vsak $\Gamma_2$.
	\begin{itemize}
		\item Če je $A$ prenosljiv tip velja $\Gamma_1, \Gamma_2 \types V \of A$ za "vsak smiseln" $\Gamma_2$.
		\item Če $A$ ni prenosljiv tip velja $\Gamma_1, \Gamma_2 \types V \of A$ za "vsak smiseln" $\Gamma_2$, ki ne vsebuje $\bb$.
	\end{itemize}
\end{lema}

\begin{proof}
	...TODO
\end{proof}

\begin{lema}[o substituciji za vrednosti]\label{lem:substitucija-vrednosti-2}
	Naj za vrednost $V$ velja $\Gamma_1 \types V \of A$ in za vrednost $W$ velja $\Gamma_1, x \of A, \Gamma_2 \types W \of B$. Potem velja $\Gamma_1, \Gamma_2 \types W[V/x] \of B$.
\end{lema}

\begin{proof}
	Ker ima vrednost $W$ tip, obstaja drevo izpeljave za njegov tip.
	Dokazujemo z strukturno indukcijo na drevo izpeljave za vrednosti.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{Ty-Var'}, potem je $W = y$.
		Ločimo dva primera.
		\begin{itemize}
			\item Če je $y = x$, potem je $A = B$ in $W[V/x] = x[V/x] = V$. Če je $A$ prenosljiv tip ima $W[V/x]$ tip $A$ po lemi~\ref{lem:razsiritev-konteksta-2}. Če $A$ ni prenosljiv tip, potem $\Gamma_2$ ne vsebuje $\bb$ in ima $W[V/x]$ tip $A$ po lemi~\ref{lem:razsiritev-konteksta-2}.
			
			\item Če $Y \neq x$, potem je $W[V/x] = y[V/x] = y = W$. Posledično ima $W[V/x]$ tip $B$.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{Ty-Boxed}, potem je $W=\tmboxed{W'}$ in $B=\tyboxed{B'}$. Po $IP$ ima $W'[V/x]$ tip $B'$. Ker je $W[V/x] = \tmboxed{W'[V/x]}$, ima $W[V/x]$ tip $B$, po pravilu \rulename{Ty-Boxed}.
		
	\end{itemize}
\end{proof}

\begin{lema}[o substituciji za izračune]\label{lem:substitucija-izračuni-2}
	Naj za vrednost $V$ velja $\Gamma_1 \types V \of A$ in za izračun $M$ velja $\Gamma_1, x \of A, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$. Potem velja $\Gamma_1, \Gamma_2 \types M[V/x] \of \tycomp{B}{\o, \i}$.
\end{lema}

\begin{proof}
	Ker ima izračun $M$ tip, obstaja drevo izpeljave za njegov tip.
	Dokazujemo z strukturno indukcijo na drevo izpeljave za izračune.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Unbox}, potem je $M$ enak $\tmunbox{W}{x}{N}$. Vrednost $W$ ima tip $B$ in izračun $N$ tip $\tycomp{B}{\o, \i}$.
		Po $IP$ velja, da ima $N[V/x]$ isti tip. Po lemi~\ref{lem:substitucija-vrednosti-2} ima $W[V/x]$ isti tip. Ker je $M[V/x]$ enak $\tmunbox{W[V/x]}{x}{N[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Unbox}.
		
		\item Če je zadnje pravilo \rulename{TyComp-RecPromise}, potem je $M$ enak $\tmwithrec{op}{x}{r}{N_1}{p}{N_2}$. Izračun $N_1$ ima tip $\tycomp{C}{\o', \i'}$ in $N_2$ tip $\tycomp{B}{\o, \i}$.
		Po $IP$ velja, da imata $N_1[V/x]$ in $N_2[V/x]$ isti tip. Ker je $M[V/x]$ enak $\tmwithrec{op}{x}{r}{N_1[V/x]}{p}{N_2[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-RecPromise}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Spawn}, potem je $M$ enak $\tmspawn{N_1}{N_2}$. Izračun $N_1$ ima tip $\tycomp{C}{\o', \i'}$ in $N_2$ tip $\tycomp{B}{\o, \i}$.
		Po $IP$ velja, da imata $N_1[V/x]$ in $N_2[V/x]$ isti tip. Ker je $M[V/x]$ enak $\tmspawn{N_1[V/x]}{N_2[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Spawn}.	
	\end{itemize}
	
\end{proof}

\begin{lema}\label{lem:promise-blackbox}
	Naj za izračun $M$ velja $\Gamma, p \of \typromise{A}, \bb \types M \of B$. Potem velja $\Gamma, \bb \types M \of B$.
\end{lema}

\begin{proof}
	...TODO
\end{proof}

\begin{trditev}[o ohranitvi]\label{trd:ohranitev-izracuni-2}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$. Če izračun $M$ naredi korak $M \reduces M'$, potem velja $\Gamma \types M' \of \tycomp{A}{\o, \i}$.
\end{trditev}

\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave koraka $M \reduces M'$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo $$\tmunbox{[V]}{x}{N} \reduces N[V/x],$$ potem je bilo zadnje pravilo za določitev tipa $M$ \rulename{TyComp-Unbox}. Posledično ima $\tmboxed{V}$ tip $\tyboxed{B}$, $V$ tip $B$ in $N$ tip $\tycomp{A}{\o, \i}$. Po lemi~\ref{lem:substitucija-izračuni-2} ima $M' = N[V/x]$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmlet{x}{(\tmwithrec{op}{r}{y}{N_1}{p}{N_2})}{N_3} \reduces \tmwithrec{op}{r}{y}{N_1}{p}{(\tmlet{x}{N_2}{N_3})},$$ potem je bilo zadnje pravilo za določitev tipa $M$ \rulename{TyComp-Let}.
		Posledično ima $N_1$ tip $\tycomp{B_1}{\o', \i'}$, $N_2$ tip $\tycomp{B_2}{\o, \i}$ in $N_3$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-Let} ima $\tmlet{x}{N_2}{N_3}$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-RecPromise} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmwithrec{op}{r}{x}{N_1}{p}{\tmopout{op'}{V}{N_2}} \reduces \tmopout{op'}{V}{\tmwithrec{op}{r}{x}{N_1}{p}{N_2}},$$ potem je bilo zadnje pravilo za določitev tipa $M$ \rulename{TyComp-RecPromise}.
		Posledično ima  $N_1$ tip $\tycomp{B}{\o', \i'}$, $V$ tip $C_{op'}$ in $N_2$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-RecPromise} ima $\tmwithrec{op}{r}{x}{N_1}{p}{N_2}$ tip $\tycomp{A}{\o, \i}$.
		Po lemi~\ref{lem:tovor-osnovni-tip-skrcitev} ima $V$ še zmeraj tip $C_{op}$ tudi v manjšem kontekstu.
		Po pravilu \rulename{TyComp-Signal} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmopin{op}{V}{\tmwithrec{op}{r}{x}{N_1}{p}{N_2}} \reduces \tmlet{p}{N_1[V/x, F/f]}{\tmopin{op}{V}{N_2}},$$ potem je bilo zadnje pravilo za določitev tipa $M$ \rulename{TyComp-Interrupt}.
		Posledično ima $V$ tip $B_{op}$, $N_1$ tip $\tycomp{\typromise{B}}{\o', \i'}$, $N_2$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N_2}$ tip $\tycomp{A}{\o, \i}$.
		Po lemi~\ref{lem:substitucija-izračuni-2} ima $N_1[V/x, F/f]$ tip $\tycomp{B}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Let} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmopin{op'}{V}{\tmwithrec{op}{r}{x}{N_1}{p}{N_2}} \reduces \tmwithrec{op}{r}{x}{N_1}{p}{\tmopin{op'}{V}{N_2}},$$ potem je bilo zadnje pravilo za določitev tipa $M$ \rulename{TyComp-Interrupt}.
		Posledično ima $V$ tip $B_{op}$, $N_1$ tip $\tycomp{\typromise{B}}{\o', \i'}$, $N_2$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N_2}$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-RecPromise} ima $M'$ tip $\tycomp{A}{\o, \i}$.

		\item Če je zadnje pravilo $$\tmlet{x}{(\tmspawn{N_1}{N_2})}{N_3} \reduces \tmspawn{N_1}{\tmlet{x}{N_2}{N_3}},$$ potem je bilo zadnje pravilo za določitev tipa $M$ \rulename{TyComp-Let}.
		Posledično ima $N_1$ tip $\tycomp{\typromise{B'}}{\o', \i'}$, $N_2$ tip $\tycomp{B}{\o, \i}$ in $N_3$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-Let} ima $\tmlet{x}{N_2}{N_3}$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-Spawn} ima $M'$ tip $\tycomp{A}{\o, \i}$.


		\item Če je zadnje pravilo $$\tmwithrec{op}{x}{r}{N_1}{p}{\tmspawn{N_2}{N_3}} \reduces \tmspawn{N_2}{\tmwithrec{op}{x}{r}{N_1}{p}{N_3}},$$ potem je bilo zadnje pravilo za določitev tipa $M$ \rulename{TyComp-RecPromise}.
		Posledično ima $N_1$ tip $\tycomp{\typromise{B}}{\o', \i'}$, $N_2$ tip $\tycomp{C}{\o'', \i''}$ in $N_3$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-RecPromise} ima $\tmwithrec{op}{x}{r}{N_1}{p}{N_3}$ tip $\tycomp{A}{\o, \i}$.
		Po lemi~\ref{lem:promise-blackbox} ima $N_2$ tip $\tycomp{C}{\o'', \i''}$ tudi v manjšem kontekstu.
		Po pravilu \rulename{TyComp-Spawn} ima $M'$ tip $\tycomp{A}{\o, \i}$.

		\item Če je zadnje pravilo $$\tmopin{op}{V}{\tmspawn{N_1}{N_2}} \reduces \tmspawn{N_1}{\tmopin{op}{V}{N_2}},$$ potem je bilo zadnje pravilo za določitev tipa $M$ \rulename{TyComp-Interrupt}.
		Posledično ima $V$ tip $B$, $N_1$ tip $\tycomp{C}{\o', \i'}$ in $N_2$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N_2}$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-Spawn} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
	\end{itemize}
	
\end{proof}


Ko iz enega procesa ustvarimo dva paralelna procesa se temu primerno tip spremeni v paralelni tip. 
Redukcijskim pravilom na sliki~\ref{fig:process-type-reductions}, dodamo pravili na sliki~\ref{fig:process-type-reductions-spawn}.

\begin{figure}[H]
	\centering
	\begin{mathpar}
		\coopinfer{TyRedu-Spawn-L}{
		}{
			\tyrun{A}{\o, \i} \tyreduces \typar{\tyrun{A'}{\o', \i'}}{\tyrun{A}{\o, \i}}
		}	
		\quad
		\coopinfer{TyRedu-Spawn-R}{
		}{
			\tyrun{A}{\o, \i} \tyreduces \typar{\tyrun{A}{\o, \i}}{\tyrun{A'}{\o', \i'}}
		}
	\end{mathpar}
	\caption{Dodatna pravila za redukcijo tipov.}
	\label{fig:process-type-reductions-spawn}
	
\end{figure}

\begin{izrek}[o ohranitvi]
	Naj za proces $P$ velja $\Gamma \types P \of C$. Če proces $P$ naredi korak $P \reduces P'$, potem obstaja tak $C'$, da velja $C \tyreduces C'$ in $\Gamma \types P' \of C'$.
\end{izrek}


\begin{proof}
	Dokazujemo z strukturno indukcijo na drevo izpeljave koraka $P \reduces P'$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		
		\item Če je zadnje uporabljeno pravilo
		$$\tmrun{(\tmspawn{M}{N})} \reduces \tmpar{\tmrun{M}}{\tmrun{N}},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Run}. Tip $C$ je oblike $\tyrun{A}{\o, \i}$.
		Izračun $M$ ima tip $\tycomp{B}{\o', \i'}$ in $N$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyProc.Par} ima $P'$ tip $\typar{\tycomp{B}{\o', \i'}}{\tycomp{A}{\o, \i}}$, kjer je $C$ naredil korak \rulename{TyRedu-Spawn-L}.
		
		\item Če je zadnje uporabljeno pravilo
		$$\tmrun{(\tmspawn{M}{N})} \reduces \tmpar{\tmrun{N}}{\tmrun{M}},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Run}. Tip $C$ je oblike $\tyrun{A}{\o, \i}$.
		Izračun $M$ ima tip $\tycomp{B}{\o', \i'}$ in $N$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyProc.Par} ima $P'$ tip $\typar{\tycomp{A}{\o, \i}}{\tycomp{B}{\o', \i'}}$, kjer je $C$ naredil korak \rulename{TyRedu-Spawn-R}.
		

		
		\item Preostali primeri so identični kot v dokazu ???
	\end{itemize}

\end{proof}





