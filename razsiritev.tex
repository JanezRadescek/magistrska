\section{Razširjen \lae{}}\label{sec:razsirjen-lae}


\subsection{Prenosljivi tipi}

Ko imamo nek signal, je ključno, da tovor ne vsebuje vrednosti obljuba, kar smo do sedaj rešili tako, da smo omejili signale na osnovne tipe. Glavni problem tega pristopa je, da funkcijski tip ni med osnovnimi tipi in posledično ne moremo poslati funkcij. Ta problem rešimo z uvedbo \emph{zavite vrednosti} in \emph{zaviti tipi}. Zavite vrednosti bodo lahko tudi lambda funkcije, ki ne bodo vsebovale zunanjih obljub. Posledično jih bo varno poslati. Osnovne tipe skupaj z zavitim tipom imenujemo \emph{prenosljivi tipi}. Da bomo lahko zavito vrednost tudi uporabili, dodamo izračun \emph{odvijanje}, ki iz zavite vrednosti odvije pripadajočo vrednost in jo veže na spremenljivko.

Tipi za izračune in procese ostanejo enaki.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Vrednosti}}
	V
	\bnfis& ...                            & &\text{obstoječe vrednosti} \\
	\bnfor& \tmboxed{V}  & &\text{zavita vrednost}
	\intertext{\textbf{Izračuni}}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmunbox{V}{x}{M}  & &\text{odvijanje}
	\end{align*}
	
	\caption{Prenosljivi izrazi.}
	\label{fig:izrazi-prenosljivi}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\text{Prenosljivi tipi vrednosti $\tymobile{A}$, $\tymobile{B}$}
	\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tysum{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tyboxed{A}
	\\%[1ex]
	\text{Tipi vrednosti $A$, $B$}
	\bnfis & \tymobile{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
	\end{align*}
%	\vspace{-5ex}
%	\begin{align*}
%	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_k})
%	\end{align*}
	
	\caption{Prenosljivi tipi.}
	\label{fig:tipi-prenosljivi}
\end{figure}

Sedaj vsaki operaciji namesto osnovnega tipa pripada prenosljiv tip.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_k})
	\end{align*}
	\vspace{-5ex}
	\caption{Operacije z pripadajočimi prenosljivimi tipi.}
	\label{fig:prenosljive-operacije}
\end{figure}

Izračun odvijanje veže vrednost znotraj zavite vrednosti $\tmboxed{V}$ na spremenljivko $x$, ki jo lahko uporabimo v kontinuaciji $M$.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmunbox{[V]}{x}{M} &\reduces M[V/x]
	\end{align*}
	
	\caption{Operacijska semantika odvijanja.}
	\label{fig:semantika-odvijanje}
\end{figure}

Da zagotovimo, da ne bi kakšni vrednosti, ki vsebuje zunanjo obljubo, dodelili zavit tip, nekoliko spremenimo pravilo za izračun tipa spremenljivke in dodamo pravili za zavito vrednost in izračun odvijanje.
Sedaj bo vrstni red v okolju pomemben, zato je okolje od sedaj naprej urejen seznam. Ko določamo tip zavite vrednosti, v okolje dodamo $\bb$. S tem za v bodoče označimo katere spremenljivke so zunanje ali notranje glede na zavito vrednost. 
Če je spremenljivka notranja, torej od kar smo jo dodali v okolje, nismo dodali nobenega $\bb$, je pravilo standardno. Če je spremenljivka zunanja, torej od kar je bila dodana v okolje, je bil v okolje dodan tudi $\bb$, mora biti pripadajoči tip v okolju prenosljiv.

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{}{\text{A prenosljiv ali } \bb \notin \Gamma'
		}{
			\Gamma, x \of A, \Gamma' \types x \of A
		}
		\quad
		\coopinfer{}{\Gamma, \bb \types V \of A
		}{
			\Gamma \types \tmboxed{V} \of \tyboxed{A}
		}
		\quad
		\coopinfer{}{\Gamma \types V \of \tyboxed{A} \\ \Gamma, x \of A \types M \of \tycomp{B}{\o, \i}
		}{
			\Gamma \types \tmunbox{V}{x}{M} \of \tycomp{B}{\o, \i}
		}
	\end{mathpar}
	
	\caption{Dodatna pravila za določanje tipov.}
	\label{fig:tipi-pravila-prenosljivi}
\end{figure} 


\begin{lstlisting}[caption={Primer uporabe prenosljivega tipa.},label={prog:primer-prenosljivega-tipa},float,floatplacement=h]
run let f = [fun x -> (x, x)] in
    send op f;
    promise (op' y -> 
      <y>)
    as p in
    await p until <y'> in
    return y'

run promise (op f -> 
    let r = f 3 in
    send op' r;
    <()>) 
    as _ in
    return ()
\end{lstlisting}


\subsection{Rekurzivni prestreznik}


Kadar pričakujemo več prekinitev z isto operacijo, je lahko iz različnih razlogov za programerja priročno, če ima na voljo prestreznik, ki se po potrebi ponovno namesti. Lahko, da je namen prestreznika, da na vsako prekinitev odgovori z signalom. Lahko nam prihajajoča prekinitev prinese pravo operacijo, vendar ne pravega pripadajočega tovora, zato obljube še nočemo izpolniti, in čakamo na naslednjo prekinitev.

To funkcionalnost smo do sedaj dosegli tako, da smo obljubo definirali v pomožni rekurzivni funkciji in po potrebi znotraj obljube ponovno klicali to funkcijo, kot lahko vidimo v programu~\ref{prog:obljuba-v-rekurzivni-funkciji}.


\begin{lstlisting}[caption={Obljuba v rekurzivni funkciji.},label={prog:obljuba-v-rekurzivni-funkciji},float,floatplacement=h]
	let f = rec fun x ->
	  (promise (op y -> 
	    send op y;
	    f()) 
	  as _ in ()) in
	f ()
\end{lstlisting}

Predvsem z namenom bolj pregledne kode nadomestimo obstoječi prestreznik z rekurzivnim prestreznikom. Le ta ima poleg imena operacije $op$, tovora $x$, obljube $M$ in kontinuacije $N$ tudi spremenljivko $f$. Pripadajočo sintakso vidimo na sliki~\ref{fig:izrazi-prestreznik}.


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmwithrec{op}{f}{V}{M}{p}{N}  & &\text{rekurzivni prestreznik}
	\end{align*}
 
	\caption{Izračuni z rekurzivnim prestreznikom}
	\label{fig:izrazi-prestreznik}
\end{figure}


Operacijska semantika rekurzivnega prestreznika je zelo podobna prejšnji verziji. S to izjemo da, ko ustrezna prekinitev pride do prestreznika, le ta v obljubi $M$ naredi dve substituciji. Tako kot prej spremenljivko $x$ substituira z vrednostjo $V$, dodatno pa spremenljivko $f$ substituira z lambda funkcijo $F$, ki sprejme enoto in vrne svežo kopijo prestreznika. Znotraj $M$ lahko uporabimo $F$ in tako ponovno namestimo prestreznik.   


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmlet{x}{(\tmwithrec{op}{f}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwithrec{op}{f}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\\
	\tmwithrec{op}{f}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x, F/f]}{\tmopin{op}{V}{N}} \\
	F = \;& \tmfunano{y}{(\tmwithrec{op}{f}{x}{M}{p}{\tmreturn{p}})} \\
	\tmopin{op'}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}} &\reduces \tmwithrec{op}{f}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\end{align*}
	
	\caption{Operacijska semantika rekurzivnega prestreznika}
	\label{fig:semantika-prestreznik}
\end{figure}

Tudi pravilo za tip rekurzivnega prestreznika je zelo podobno prvotnemu prestrezniku.

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{}{\i\, (\op) = ({\o'} , {\i'}) \\
			\Gamma, x \of \tymobile{A}_\op, f \of \tyfun{\tyunit}{\tycomp{\typromise{B}}{\o', \i'}} \types M : \tycomp{\typromise B}{\o',\i'} \\
			\Gamma, p \of \typromise B \types N : \tycomp{C}{\o,\i}
		}{
			\Gamma \types \tmwithrec{op}{x}{f}{M}{p}{N} \of \tycomp{C}{\o, \i}
		}
	\end{mathpar}
	
	\caption{Pravilo za izračun tipa rekurzivnega prestreznika.}
	\label{fig:tipi-pravila-rekurzivni-prestreznik}
\end{figure} 

Program~\ref{prog:rekurzivna-obljuba} ima isti semantičen pomen kot program~\ref{prog:obljuba-v-rekurzivni-funkciji}, le da je tokrat napisan z rekurzivno obljubo.

\begin{lstlisting}[caption={Rekurzivna obljuba.},label={prog:rekurzivna-obljuba},float,floatplacement=h]
promise (op x f -> 
send op x;
f())
as _ in ()
\end{lstlisting}


\subsection{Dinamični procesi}

Do sedaj so bili procesi statični v smislu, da smo vse procese morali ustvariti na začetku. Da odstranimo to omejitev, dodamo dinamično ustvarjanje procesov s pomočjo izračuna $\tmspawn{M}{N}$. Le ta se bo pomikal navzven. Ko bo postal zgornji izračun v procesu, se bo ta proces razcepil v dva procesa. Prvi proces bo izvajal izračun $M$, drugi pa bo izvajal nadaljevanje $N$.


\begin{figure}[h]	
	\centering
	\small
	\begin{align*}
	\shortintertext{\textbf{Izračuni}}
	M, N
	\bnfis & ... \,\bnfor\! \tmspawn{M}{N}
	\end{align*}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\shortintertext{\textbf{Operacijska semantika}}
	\tmlet{x}{(\tmspawn{M_1}{M_2})}{N} & \reduces \tmspawn{M_1}{\tmlet{x}{M_2}{N}}
	\\
	\tmwithrec{op}{x}{f}{M}{p}{\tmspawn{N_1}{N_2}} & \reduces \tmspawn{N_1}{\tmwithrec{op}{x}{f}{M}{p}{N_2}}
	\\
	\tmopin{op}{V}{\tmspawn{M}{N}} & \reduces \tmspawn{M}{\tmopin{op}{V}{N}}
	\\
	\tmrun{(\tmspawn{M}{N})} & \reduces \tmpar{\tmrun{M}}{\tmrun{N}}
	\end{align*}
\end{figure}


Ker se izračun $M$ v $\tmspawn{M}{N}$ lahko razširi mimo prestreznikov moramo paziti, da ima $M$ prenosljiv tip in je posledično varen.   

\begin{figure}[h]
	\centering
	\small
	\textbf{Pravila za tipe računov}
	\begin{mathpar}
		\coopinfer{}{\Gamma, \blacksquare \types M : \tycomp{B}{\o', \i'} \\ \Gamma \types N : \tycomp{A}{\o, \i}
		}{
			\Gamma \types \tmspawn{M}{N} : \tycomp{A}{\o, \i}
		}
	\end{mathpar}
\end{figure}


Na primeru~\ref{prog:primer-dinamičen-proces} imamo program, ki naredi isto kot primer~\ref{prog:primer-prenosljivega-tipa}, le da tokrat uporabimo izračun $\tmkw{Spawn}$.

\begin{lstlisting}[caption={Primer uporabe dinamičnih procesov.},label={prog:primer-dinamičen-proces},float,floatplacement=h]
run let f = fun x -> (x, x) in
    spawn(
      let r = f 3 in
      send op r;
      (),
      
      promise (op x -> <x>)
      as p in
      await p until <x'> in
      return x')
\end{lstlisting}



\subsection{Poenostavljeni rezultati}

V operacijsko semantiko dodamo dve novi pravili. Prvo potegne $\tmkw{Await}$ ven iz zaporedja. Drugo pravilo prestavi prekinitev takoj za $\tmkw{Await}$. Obe pravili skupaj dosežeta dvoje. Malenkost večji del prvotnega izračuna je postal asinhron. Kar nam lahko v nekaterih primerih nekoliko pohitri izvajanje, če bo obljuba izpolnjena in bomo nadaljevali z izvajanjem tega dela. Druga prednost pa je, da izračun, ki je v čakajočem stanju, se vedno začne z izračunom $\tmkw{Await}$. Posledično je prepoznati ali je izračun v čakajočem stanju trivialno in se delni rezultati nekoliko poenostavijo. 

Rezultati ostanejo nespremenjeni.


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Algebraičnost blokade}}
	\tmlet{x}{(\tmawait{V}{y}{M})}{N} & \reduces \tmawait{V}{y}{(\tmlet{x}{M}{N})}
	\\[1ex]
	\intertext{\textbf{Komutativnost blokade in prekinitve}}
	\tmopin{op}{V}{\tmawait{W}{x}{M}} &\reduces \tmawait{W}{x}{\tmopin{op}{V}{M}}
	\end{align*}
	
	\caption{Dodatna pravila operacijske semantike.}
	\label{fig:operacijska-semantika-poenostavitev}
\end{figure}


\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
	\coopinfer{}{
	}{
		\RunResult {\Psi} {\tmreturn V}
	}
	\\
	\coopinfer{}{
		\RunResult {\Psi \cup \{p\}} {N}
	}{
		\RunResult {\Psi} {\tmwith {op} x M p N}
	}
	\quad
	\coopinfer{}{
		p \in \Psi \\
		\tmawait p x M
	}{
		\RunResult {\Psi} {M}
	}
	\end{mathpar}

	\caption{Poenostavljeni delni rezultati.}
	\label{fig:rezultati-poenostavitev}
\end{figure}



\subsection{Varnost}

Sedaj dokažemo izrek o varnosti za \lae{} razširjen z rekurzivnimi prestrezniki, prenosljivimi tipi, in dinamičnimi procesi.

\begin{izrek}[o napredku za razširitev]
	Če ...
\end{izrek}



\begin{izrek}[izrek o ohranitvi]
	Če ...
\end{izrek}



