\section{Račun \lae{}}\label{sec:lae}

Račun $\lambda$ je preprost teoretičen programski jezik. Leta 1930 ga je uvedel Alonzo Chuch z namenom formalizacije koncepta izračunljivosti~\cite{rojas2015tutorial}. Račun lambda je Turingovo poln.


Račun \lae{} je razširitev računa $\lambda$. Posledično je tudi \lae{}-račun Turingovo poln. Računu \lae{} dodamo izraze, ki poosebijo bistvo asinhrono vzporednega programiranja z pomočjo učinkov. Da \lae{}-račun čim bolj približamo vsakdanjim programskim jezikom, mu dodamo tudi izraze za  naravna števila, par, ujemanje vzorca...


\subsection{Izrazi}

Izraze v \lae{}-računu razdelimo na vrednosti, izračune in procese. 


Vrednosti so sledeče.
Konstante vrednosti naravna števila in logični vrednosti resnica in neresnica.
% TOLE DODAJ ČE BO MAGISTRSKA PREKRATKA DA BODO DALJŠI DOKAZI in nekatere aritmetične in logične funkcije kot so $+$, $-$, $*$, $/$, $=$, $<$...
Spremenljivke, ki so simbolična imena povezana z vrednostmi v danem kontekstu.
Enote in pare.
leve in desne inkluzije vsote.
Lambda abstrakcije.
Rekurzivne lambda abstrakcije.
Izpolnjena obljuba. Ta vrednost je edina zares nova. Je vrednost, ki jo je vrnil prestreznik in jo posebej označimo, da bomo kasneje lahko pravilno določili tip.


Izračuni so sledeči.
Vrni ki drži neko vrednost.
Zaporedje dveh izračunov.
Aplikacija ki v prvi izraz substituira drugi izraz.
Ujemanje ki glede na vzorec izraza izbere izračun. 
Signal vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prekinitev vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prestreznik vsebuje ime operacije, ime spremeljivke, Izračun M in izračun N.
blokada


Pripadajočo sintakso vidimo na~\ref{fig:izrazi} v Backus-Naurjevi obliki (BNF).



\begin{figure}[h]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\intertext{\textbf{Vrednosti}}
		V, W
		\bnfis& n \bnfor\! \true \bnfor\! \false        & &\text{konstantne vrednosti} \\
		\bnfor& x                                       & &\text{spremenljivka} \\
		\bnfor& \tmunit \bnfor\! \tmpair{V}{W}          & &\text{enota in par} \\
		\bnfor& \tminl[Y]{V} \bnfor\! \tminr[X]{V}      & &\text{leva in desna inkluzija} \\
		\bnfor& \tmfun{x}{M}                        & &\text{lambda} \\
		\bnfor& \tmfunrec{f}{x : X}{M}                        & &\text{rekurzivna lambda} \\
		\bnfor& \tmpromise V                            & &\text{izpolnjena obljuba}
		\\[1ex]
		\intertext{\textbf{Izračuni}}
		M, N
		\bnfis& \tmreturn{V}                            & &\text{vrnjena vrednost} \\
		\bnfor& \tmlet{x}{M}{N}                         & &\text{zaporedje} \\
	%	\bnfor& \tmletrec[: \tyfun{X}{Y}]{f}{x}{M}{N} & &\text{rekurzivna definicija} \\
		\bnfor& V\,W                                    & &\text{aplikacija} \\
		\bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    & &\text{ujemanje produkta} \\
		\bnfor& \tmmatch[]{V}{}                        & &\text{prazno ujemanje} \\
		\bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}	& &\text{ujemanje vsote} \\
		\bnfor& \tmopout{op}{V}{M}       & &\text{signal} \\
		\bnfor& \tmopin{op}{V}{M}          & &\text{prekinitev} \\
		\bnfor& \tmwith{op}{x}{M}{p}{N}      & &\text{prestreznik} \\
		\bnfor& \tmawait{V}{x}{M}             & &\text{blokada}
			\\[1ex]
		\intertext{\textbf{Procesi}}
	%	P \bnfis & ...
		  P, Q
		\bnfis & \tmrun M & & \text{run} \\
		\bnfor & \tmpar P Q & & \text{vzporedna procesa} \\
		\bnfor & \tmopout{op}{V}{P} & & \text{proces signal} \\
		\bnfor & \tmopin{op}{V}{P} & & \text{proces prekinitev}
		\end{align*}
	} 
	\caption{Vrednosti, izračuni in procesi.}
	\label{fig:izrazi}
\end{figure}


\subsection{Operacijska semantika}

Račun \lae\ opremimo z operacijsko semantiko malih korakov, ki je definirana z relacijo korak $M \reduces N$. Redukcijska pravila za izračune so podana na sliki~\ref{fig:small-step-semantics-of-computations}. Redukcijska pravila za procese so podana na sliki~\ref{fig:small-step-semantics-of-processes}.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Pravila osnovnih izračunov}}
	\tmapp{(\tmfun{x \of X}{M})}{V} &\reduces M[V/x]
	\\
	\tmapp{(\tmfunrec{f}{x \of X}{M})}{V} &\reduces M[V/x, (\tmfunrec{f}{x \of X}{M})/f]
	\\
	\tmlet{x}{(\tmreturn V)}{N} &\reduces N[V/x]
	\\
	\tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto M} &\reduces M[V/x, W/y]
	\\
	\mathllap{\tmmatch{(\tminl[Y]{V})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	M[V/x]
	\\
	\mathllap{\tmmatch{(\tminr[X]{W})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	N[W/y]
	\\[1ex]
	\intertext{\textbf{Algebraičnost signala in prestreznika}}
	\tmlet{x}{(\tmopout{op}{V}{M})}{N} &\reduces \tmopout{op}{V}{\tmlet{x}{M}{N}}
	\\
	\tmlet{x}{(\tmwith{op}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwith{op}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\\[1ex]
	\intertext{\textbf{Komutativnost operacij}}
	\tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmopout{op'}{W}{M}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{M}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmreturn W} &\reduces \tmreturn W
	\\
	\tmopin{op}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}
	\\
	\tmopin{op'}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmwith{op}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\\[1ex]
	\intertext{\textbf{Čakanje na izpolnitev obljube}}
	\tmawait{\tmpromise V}{x}{M} &\reduces M[V/x]
	\\[-8ex]
	\end{align*}
	
	\begin{align*}
	\intertext{\textbf{Evalvacija v okolju}}
	\coopinfer{}{
		M \reduces N
	}{
		\E[M] \reduces \E[N]
	}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{kjer}}
	\text{$\E$}
	\bnfis [~]
	\bnfor \tmlet{x}{\E}{N}
	\bnfor \tmopout{op}{V}{\E}
	\bnfor \tmopin{op}{V}{\E} 
	\bnfor \tmwith{op}{x}{M}{p}{\E}
	\end{align*}
	
	\caption{Operacijska semantika malih korakov za izračune.}
	\label{fig:small-step-semantics-of-computations}
\end{figure}

\begin{figure}[h]
    \centering
	\small
	\begin{minipage}[t]{0.4\textwidth}
		\centering
		\begin{align*}
		\intertext{\textbf{Posamezen proces}}
		\coopinfer{}{
			M \reduces N
		}{
			\tmrun M \reduces \tmrun N
		}
		\end{align*}
	\end{minipage}
	\qquad
	\begin{align*}
	\intertext{\textbf{Prehod}}
	\tmrun {(\tmopout{op}{V}{M})}  &\reduces \tmopout{op}{V}{\tmrun M}
	\\
	\tmopin{op}{V}{\tmrun M} &\reduces \tmrun {(\tmopin{op}{V}{M})}
	\\[1ex]
	\intertext{\textbf{Oddajanje signala}}
	\tmpar{\tmopout{op}{V}{P}}{Q} &\reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
	\\
	\tmpar{P}{\tmopout{op}{V}{Q}} &\reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{P}}{Q}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmpar P Q} &\reduces \tmpar {\tmopin{op}{V}{P}} {\tmopin{op}{V}{Q}}
	\\[1ex]
	\intertext{\textbf{Komutativnost signala in prekinitve}}
	\tmopin{op}{V}{\tmopout{op'}{W}{P}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{P}}
	\end{align*}
	\vspace{-4ex}
	\begin{align*}
	\shortintertext{\quad\textbf{Evalvacija v okolju}}
	\quad
	\coopinfer{}{
		P \reduces Q
	}{
		\F[P] \reduces \F[Q]
	}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{kjer}}
	\text{$\F$}
	\bnfis& [~]
	\bnfor \tmpar \F Q \bnfor\! \tmpar P \F
	\bnfor \tmopout{op}{V}{\F}
	\bnfor \tmopin{op}{V}{\F}
	\end{align*}
	
	\caption{Operacijska semantika malih korakov za procese.}
	\label{fig:small-step-semantics-of-processes}
\end{figure}

Poleg teh pravil, ki so identična pravilom iz \cite{aeff}, dodamo še dve novi.
Prvo pravilo potegne blokado ven iz zaporedja. Drugo pravilo prestavi prekinitev takoj za blokado. Obe pravili skupaj dosežeta dvoje. Malenkost večji del prvotnega izračuna je postal asinhron. Kar nam lahko v primeru, da bo obljuba izpolnjena in bomo nadaljevali z izvajanjem tega dela, nekoliko pohitri izvajanje. Druga prednost pa je, da izračun, ki je v čakajočem stanju, se vedno začne z izračunom $\tmkw{Await}$. Posledično je prepoznati ali je izračun v čakajočem stanju trivialno in se bodo delni rezultati nekoliko poenostavili. 

Rezultati ostanejo enaki kot v \cite{aeff}.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
		\intertext{\textbf{Algebraičnost blokade}}
		\tmlet{x}{(\tmawait{V}{y}{M})}{N} & \reduces \tmawait{V}{y}{(\tmlet{x}{M}{N})}
		\\[1ex]
		\intertext{\textbf{Komutativnost blokade in prekinitve}}
		\tmopin{op}{V}{\tmawait{W}{x}{M}} &\reduces \tmawait{W}{x}{\tmopin{op}{V}{M}}
	\end{align*}
	
	\caption{Dodatni pravili operacijske semantike.}
	\label{fig:operacijska-semantika-poenostavitev}
\end{figure}

\subsection{Sistem tipov}


Da se izognemo nekaterim napakam ob izvajanju uvedemo sistem tipov.
Tipe ločimo na tipe za vrednosti, izračune in procese.
Večina vrednosti dobi standardne tipe, kot so naravno število, boolean, enota, par, vsota in funkcijski tip. 


%%Predolga/grda poved
Ker funkcijski tip označuje funkcijo, ki vzame argument in mu priredi izračun, le tej pa imajo, kot bomo kasneje videli, poleg standardnih tipov, še tipe za učinke, ima tudi funkcijski tip dodane tipe za učinke.


Dodatno za vrednost obljuba uvedemo tip \emph{obljuba} $\typromise{A}$. 
Tipom za vrednosti, ki ne vsebujejo funkcijskega tipa ali obljube, pravimo osnovni tipi. 


Izračunom poleg standardnega tipa dodamo še tipe signalov, ki jih lahko sprožimo, označene z $\o$ in tipe prekinitev, ki jih lahko prestrežemo, označene z $\i$.
Tipi učinkov $\o$ in $\i$ so elementi množice $O$ oziroma $I$.
Množica $\sig$ je množica vseh operacij, ki jih imamo na voljo.
Množica $O$ je preprosto potenčna množica množice $\sig$ in posledično $\o$ predstavlja množico signalov, ki jih izračun lahko sproži.

Ko prestrežemo neko prekinitev lahko ustrezen izračun obljuba začne sprožati nove signale in prestrezati nove prekinitve. Zato $I$ definiramo kot največjo fiksno točko preslikave $\omega$ definirane kot 
$$\Omega(X) = \sig \Rightarrow (O \times X)_\bot $$,
kjer je $\Rightarrow$ potenciranje, $\times$ je kartezični produkt in $(-)_\bot$ je dvig.


Tipi procesov so odvisni od tipov izračunov in posledično vsebujejo tipe učinkov.

Pravila za dodelitev tipa vidimo na sliki~\ref{fig:value-typing-rules} in~\ref{fig:computation-typing-rules}.


\begin{figure}[h]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\text{Osnovni tipi vrednosti $\bar{A}$, $\bar{B}$}
		\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\bar{A}}{\bar{B}} \,\bnfor\! \tysum{\bar{A}}{\bar{B}}
		\\%[1ex]
		\text{Tipi vrednosti $A$, $B$}
		\bnfis & \bar{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
		\\
		\text{Tip izračuna} \bnfis& \tycomp{A}{\o,\i}
		\\
		\text{Tip procesa \tyC, \tyD}  \bnfis & \tyrun{A}{\o, \i} \,\bnfor\! \typar{\tyC}{\tyD}
		\end{align*}
	} 
	\caption{Tipi izrazov}
	\label{fig:tipi}
\end{figure}

Vsaki operaciji priredimo nek tip, kot vidimo na sliki~\ref{fig:operacije}. Ker izračun 
$$ \tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} $$
lahko naredi korak v izračun
$$ \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}} $$,
je ključno da vrednost $V$ ne vsebuje spremenljivke $p$, saj v drugem izračunu spremenljivka $p$ v vrednosti $V$ ni več dobro definiran. Da zagotovimo, da vrednost $V$ ne vsebuje spremenljivke $p$, omejimo tipe, ki pripadajo operacijam, na osnovne tipe.

\begin{figure}[t]
	\centering
	\small
	\begin{align*}
	(op_1, \bar{A}_{op_1}),\, (op_2, \bar{A}_{op_2}),\, ... ,\, (op_n, \bar{A}_{op_k})
	\end{align*}
\vspace{-5ex}
	\caption{Operacije in pripadajoči osnovni tipi.}
	\label{fig:operacije}
\end{figure}



\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{Ty-Cons}{
		}{
			\Gamma \types n : int
		}
		\qquad
		\coopinfer{Ty-Cons}{
		}{
			\Gamma \types true : bool
		}
		\qquad
		\coopinfer{Ty-Cons}{
		}{
			\Gamma \types false : bool
		}
		\quad
		\coopinfer{Ty-Var}{
		}{
			\Gamma, x \of X, \Gamma' \types x : X
		}
		\quad
		\coopinfer{Ty-Unit}{
		}{
			\Gamma \types \tmunit : \tyunit
		}
		\\
		\coopinfer{Ty-Pair}{
			\Gamma \types V : X \\
			\Gamma \types W : Y
		}{
			\Gamma \types \tmpair{V}{W} : \typrod{X}{Y}
		}
		\quad
		\coopinfer{Ty-Promise}{
			\Gamma \types V : X
		}{
			\Gamma \types \tmpromise V : \typromise X
		}
		\quad
		\coopinfer{Ty-Inl}{
			\Gamma \types V : X
		}{
			\Gamma \types \tminl[Y]{V} : X + Y
		}
		\quad
		\coopinfer{Ty-Inr}{
			\Gamma \types W : Y
		}{
			\Gamma \types \tminr[X]{W} : X + Y
		}
		\\
		\coopinfer{Ty-Fun}{
			\Gamma, x \of X \types M : \tycomp{Y}{\o,\i}
		}{
			\Gamma \types \tmfun{x : X}{M} : \tyfun{X}{\tycomp{Y}{\o,\i}}
		}
		\quad
		\coopinfer{Ty-Fun-Rec}{
			\Gamma,f \of \tyfun{X}{\tycomp{Y}{\o,\i}}, x \of X \types M : \tycomp{Y}{\o,\i}
		}{
			\Gamma \types \tmfunrec{f}{x : X}{M} : \tyfun{X}{\tycomp{Y}{\o,\i}}
		}
	\end{mathpar}
	\caption{Pravila za izračun tipov za vrednosti.}
	\label{fig:value-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyComp-Return}{
			\Gamma \types V : X
		}{
			\Gamma \types \tmreturn{V} : \tycomp{X}{(\o,\i)} 
		}
		\qquad
		\coopinfer{TyComp-Let}{
			\Gamma \types M : \tycomp{X}{(\o,\i)}
			\\
			\Gamma, x \of X \types N : \tycomp{Y}{(\o,\i)} 
		}{												
			\Gamma \types
			\tmlet{x}{M}{N} : \tycomp{Y}{(\o,\i)}       
		}											
		\\
		\coopinfer{TyComp-Apply}{
			\Gamma \types V : \tyfun{X}{\tycomp{Y}{(\o,\i)}} \\
			\Gamma \types W : X
		}{
			\Gamma \types \tmapp{V}{W} : \tycomp{Y}{(\o,\i)}
		}
		\quad
		\coopinfer{TyComp-MatchPair}{
			\Gamma \types V : \typrod{X}{Y} \\
			\Gamma, x \of X, y \of Y \types M : \tycomp{Z}{(\o,\i)}
		}{
			\Gamma \types \tmmatch{V}{\tmpair{x}{y} \mapsto M} : \tycomp{Z}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-MatchEmpty}{
			\Gamma \types V : \tyempty
		}{
			\Gamma \types \tmmatch[\tycomp{Z}{(\o,\i)}]{V}{} : \tycomp{Z}{(\o,\i)}
		}
		\quad
		\coopinfer{TyComp-MatchSum}{
			\Gamma \types V : X + Y \\\\
			\Gamma, x \of X \types M : \tycomp{Z}{(\o,\i)} \\
			\Gamma, y \of Y \types N : \tycomp{Z}{(\o,\i)} \\
		}{
			\Gamma \types \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} : \tycomp{Z}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-Signal}{
			\op \in \o \\
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{X}{(\o,\i)} 
		}{
			\Gamma \types \tmopout{op}{V}{M} : \tycomp{X}{(\o,\i)}
		}
		\qquad
		\coopinfer{TyComp-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{X}{(\o,\i)} 
		}{
			\Gamma \types \tmopin{op}{V}{M} : \tycomp{X}{\opincomp {op} (\o,\i)}
		}
		\\
		\coopinfer{TyComp-Promise}{
			\i\, (\op) = ({\o'} , {\i'}) \\
			\Gamma, x \of A_\op \types M : \tycomp{\typromise X}{(\o',\i')} \\
			\Gamma, p \of \typromise X \types N : \tycomp{Y}{(\o,\i)} 
		}{
			\Gamma \types \tmwith{op}{x}{M}{p}{N} : \tycomp{Y}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-Await}{
			\Gamma \types V : \typromise X \\
			\Gamma, x \of X \types M : \tycomp{Y}{(\o,\i)} 
		}{
			\Gamma \types \tmawait{V}{x}{M} : \tycomp{Y}{(\o,\i)}
		}
		\qquad
		\coopinfer{TyComp-Subsume}{
			\Gamma \types M : \tycomp{X}{(\o, \i)} \\
			(\o,\i) \order {O \times I} (\o',\i')
		}{
			\Gamma \types M : \tycomp{X}{(\o', \i')}
		}
	\end{mathpar}
	\caption{Pravila za izračun tipov za izračune.}
	\label{fig:computation-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyProc-Run}{
			\Gamma \types M : \tycomp{X}{\o,\i}
		}{
			\Gamma \types \tmrun{M} : \tyrun{X}{\o, \i}
		}
		\quad
		\coopinfer{TyProc-Par}{
			\Gamma \types P : \tyC \\
			\Gamma \types Q : \tyD
		}{
			\Gamma \types \tmpar{P}{Q} : \typar{\tyC}{\tyD}
		}
		\\
		\coopinfer{TyProc-Signal}{
			\op \in \mathsf{signals\text{-}of}{(\tyC)} \\\\
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopout{op}{V}{P} : \tyC
		}
		\quad
		\coopinfer{TyProc-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopin{op}{V}{P} : \opincomp{op}{\tyC}
		}  
	\end{mathpar}
	\caption{Pravila za izračun tipov za procese.}
	\label{fig:process-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering

	\textbf{Delni rezultati}
	\begin{mathpar}
		\coopinfer{R-Return}{
		}{
			\RunResult {\Psi} {\tmreturn V}
		}
		\qquad
		\coopinfer{R-Signal}{
		}{
			\RunResult {\Psi} {\tmopout{op}{V}{M}}
		}
		\\
		\coopinfer{R-Promise}{
			\RunResult {\Psi \cup \{p\}} {N}
		}{
			\RunResult {\Psi} {\tmwith {op} x M p N}
		}
		\qquad
		\coopinfer{R-Await}{
			p \in \Psi
		}{
			\RunResult {\Psi} {\tmawait{p}{x}{M}}
		}
	\end{mathpar}

	\textbf{Rezultati}
	\begin{mathpar}
		\coopinfer{R-Out}{
			\ProcResult {P}
		}{
			\ProcResult {\tmopout {op} V P}
		}
		\qquad
		\coopinfer{R-Process}{
			\ParResult {P}
		}{
			\ProcResult {P}
		}
		\\
		\coopinfer{R-Parallel}{
			\ParResult P \\
			\ParResult Q
		}{
			\ParResult {\tmpar P Q}
		}
		\qquad
		\coopinfer{R-Run}{
			\RunResult {\emptyset} {M}
		}{
			\ParResult {\tmrun M}
		}
	\end{mathpar}
	\caption{Rezultati in delni rezultati.}
	\label{fig:results-rules}
\end{figure}


Izrek o varnosti, ki je sestavljen iz izreka o ohranitvi in izreka o napredku nam zagotavlja, da ne moremo dobiti runtime, če imamo tipe, kot smo jih definirali.

\begin{lema}\label{lem:ni-spremenljivka}
	Če za vrednost $V$ velja $\Gamma \types V \of A$, kjer je $A$ tip, ki se ne pojavi v kontekstu $\Gamma$, potem vrednost $V$ ni spremenljivka.
	\begin{itemize}
		\item Če je $A$ enak $B_1 \times B_2$, potem je $V$ enak $(W_1,W_2)$.
		\item Če je $A$ enak $B_1 + B_2$, potem je $V$ ali enak $\tminl{W_1}$ ali $\tminr{W_2}$.
		\item Če je $A$ enak $\tyfun{B_1}{\tycomp{B_2}{\o, \i}}$, potem je $V$ ali enak $\tmfunano{x}{M}$ ali $\tmfunrecano{f}{x}{M}$.
	\end{itemize}
\end{lema}

\begin{proof}
	Predpostavimo, da je $V$ spremenljivka. Edino pravilo za določitev tipa spremenljivke je \rulename{TIP-VAR}. Od tod sledi, da je tip $A$ v kontekstu $\Gamma$. Kar je v protislovju z predpostavko izreka, da se tip $A$ ne pojavi v kontekstu $\Gamma$.
	\begin{itemize}
		\item Edini pravili za tip $B_1 \times B_2$ sta \rulename{Ty-Var} in \rulename{Ty-Pair}. Ker $V$ ni spremenljivka, je bilo uporabljeno pravilo \rulename{Ty-Pair}. Posledično je $V$ oblike $\tmpair{W_1}{W_2}$.
		
		\item Edina pravila za tip $B_1 + B_2$ so \rulename{Ty-Var}, \rulename{Ty-Inl} in \rulename{Ty-Inr}. Ker $V$ ni spremenljivka, je bilo uporabljeno pravilo \rulename{Ty-Inl} ali \rulename{Ty-Inr}. Posledično je $V$ oblike $\tminl{W_1}$ ali $\tminr{W_2}$.
		
		\item Edina pravila za tip $\tyfun{B_1}{\tycomp{B_2}{\o, \i}}$ so \rulename{Ty-Var}, \rulename{Ty-Fun} in \rulename{Ty-Fun-Rec}. Ker $V$ ni spremenljivka, je bilo uporabljeno pravilo \rulename{Ty-Fun} ali \rulename{Ty-Fun-Rec}. Posledično je $V$ oblike $\tmfunano{x}{M}$ ali $\tmfunrecano{f}{x}{M}$.
	\end{itemize}
\end{proof}


\begin{trditev}[o napredku]\label{trd:gamma-napredek}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$, kjer je $\Gamma = x_1 \of \typromise{A_1}, x_2 \of \typromise{A_2},..., x_i \of \typromise{A_i}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\RunResult{\Gamma}{M}$.
\end{trditev}

\begin{proof}
	Ker ima izračun $M$ tip, obstaja drevo izpeljave za njegov tip.
	Dokazujemo z strukturno indukcijo na drevo izpeljave za izračune.
	
	Osnovni primer je en sam, ko je uprabljeno pravilo \rulename{TyComp-Return} in je $M$ enak $\tmreturn{V}$. 
	Po pravilu \rulename{R-Return} sledi, da je $M$ delni rezultat in velja (ii).
	
	Sedaj pokažimo, da trditev velja tudi za rekurzivno definirane izračune.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	
	\begin{itemize}
		
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $\tmlet{x}{N_1}{N_2}$.
		Izračun $N_1$ ima tip in po $IP$ lahko naredi korak ali pa je delni rezultat. Če $N_1$ lahko naredi korak v $N_1'$, potem lahko po pravilu za evalvacijo v okolju tudi $M$ naredi korak v $\tmlet{x}{N_1'}{N_2}$.
		Če pa je $N_1$ delni rezultat, ločimo štiri možnosti. 
		\begin{itemize}
			\item Če je $N_1$ enak $\tmreturn{V}$, potem lahko $M$ naredi korak v izračun $N_2[V/x]$.
			\item Če je $N_1$ enak $\tmopout{op}{V}{N_3}$, potem lahko $M$ naredi korak v $\tmopout{op}{V}{(\tmlet{x}{N_3}{N_2})}$.
			\item Če je $N_1$ enak $\tmwith{op}{x}{N_3}{p}{N_4}$, lahko $M$ naredi korak v $\tmwith{op}{x}{N_3}{p}{(\tmlet{x}{N_4}{N_2})}$.
			\item Če pa je $N_1$ enak $\tmawait{p}{y}{N_3}$, lahko $M$ naredi korak v $\tmawait{p}{y}{(\tmlet{x}{N_3}{N_2})}$.
		\end{itemize}
	
		\item Če je uporabljeno pravilo \rulename{TyComp-Apply}, potem je $M$ enak $V W$. Ker ima vrednost $V$ tip $\tyfun{B_1}{B_2}$ in v kontekstu nobena spremenljivka nima tipa $X \times Y$, je po lemi~\ref{lem:ni-spremenljivka} vrednost $V$ oblike $\tmfunano{x}{M}$ ali $\tmfunrecano{f}{x}{M}$. Posledično lahko naredimo korak v $M[W/x]$ ali $M[V/x, (\tmfunrec{f}{x \of X}{M})/f]$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchPair}, potem je $M$ enak $\tmmatch{V}{(x,y) \mapsto N}$. Ker ima vrednost $V$ tip $X \times Y$ in v kontekstu nobena spremenljivka nima tipa $X \times Y$, je po lemi~\ref{lem:ni-spremenljivka} vrednost $V$ oblike $(W_1,W_2)$. Posledično lahko $M$ naredi korak v izračun $N[W_1/x,W_2/y]$.
		
		\item Zadnje pravilo ne more biti \rulename{TyComp-MatchEmpty}. Če bi bilo zadnje pravilo \rulename{TyComp-MatchEmpty}, bi vrednost $V$ imela tip $0$. 
		Ker v kontekstu nobena spremenljivka nima tipa $0$, $V$ ne more biti spremenljivka po lemi~\ref{lem:ni-spremenljivka}.
		Ker ne obstaja nobeno drugo pravilo za tip $0$, take vrednosti ne moremo imeti, in posledično zadnje uporabljeno pravilo ne more biti \rulename{TyComp-MatchEmpty}.

		
		\item Če je zadnje pravilo \rulename{TyComp-MatchSum}, potem je $M$ enak $\tmmatch{V}{\tminl{x} \mapsto N_1, \tminr{y} \mapsto N_2}$.
		Ker ima vrednost $V$ tip $X + Y$ in v kontekstu nobena spremenljivka nima tipa $X + Y$, je po lemi~\ref{lem:ni-spremenljivka} vrednost $V$ oblike $\tminl{W_1}$ ali $\tminr{W_2}$.
		\begin{itemize}
			\item Če je oblike $\tminl{W_1}$ lahko $M$ naredi korak v $N_1[W_1/x]$.
			\item Sicer je oblike $\tminr{W_2}$ in lahko $M$ naredi korak v $N[W_2/y]$.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyComp-Signal}, potem je $M$ enak $\tmopout{op}{V}{N}$ in po pravilu $R-Signal$ dokažemo (ii).
		
		\item Če je zadnje pravilo \rulename{TyComp-Interupt}, potem je $M$ enak $\tmopin{op}{V}{N}$. Izračun $N$ ima tip in po $IP$ lahko naredi korak ali pa je že delna vrednost. Če $N$ lahko naredi korak v $N'$, potem po pravilu za evalvacijo v okolju tudi $M$ lahko naredi korak v $\tmopin{op}{V}{N'}$. 
		Če pa je $N$ delni rezultat ločimo štiri možnosti.
		\begin{itemize}
			\item Če je $N$ enak $\tmreturn{V}$, potem lahko $M$ naredi korak v $\tmreturn{V}$.
			\item Če je $N$ enak $\tmopout{op'}{W}{O}$, potem lahko $M$ naredi korak v $\tmopout{op'}{W}{(\tmopin{op}{V}{O})}$.
			\item Če je $N$ enak $\tmwith{op'}{x}{O}{p}{O'}$, potem lahko $M$ naredi ali korak v $\tmlet{p}{O[V/x]}{O'}$, če velja $op = op'$, ali v $\tmwith{op'}{x}{O}{p}{\tmopin{op}{V}{O'}}$ sicer.
			\item Če pa je $N$ enak $\tmawait{p}{x}{O}$, lahko $M$ naredi korak v $\tmawait{p}{x}{(\tmopin{op}{V}{O})}$.
		\end{itemize}
		
		
		\item Če je zadnje pravilo \rulename{TyComp-promise}, potem je $M$ enak $\tmwith{op}{x}{N_1}{p}{N_2}$. Izračun $N_2$ ima tip in po $IP$ lahko $N_2$ naredi korak ali pa je že delna vrednost. Če $N_2$ lahko naredi korak v $N_2'$, potem po pravilu za evalvacijo v okolju tudi $M$ lahko naredi korak v $\tmwith{op}{x}{N_1}{p}{N_2'}$.
		Če pa je $N_2$ delni rezultat, je tudi $M$ delni rezultat po pravilu \rulename{R-Promise}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Await}, potem je $M$ oblike $\tmawait{V}{p}{N}$.
		Ločimo dva primera.
		Če je $V$ spremenljivka v kontekstu $\Gamma$, potem je $M$ po pravilu $R-Await$ delni rezultat.
		Sicer je $V$ enak $\tmpromise{W}$. Tedaj lahko $M$ naredi korak v $N[W/p]$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Subsume}, lahko $IP$ uporabimo direktno na $M$ in posledično lahko $M$ naredi korak ali pa je $M$ delni rezultat.
			
	\end{itemize}
	
\end{proof}


\begin{posledica}[o napredku]\label{pos:prazen-napredek}
	Naj za izračun $M$ velja $\emptyset \types M \of \tycomp{A}{\o, \i}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\RunResult{\emptyset}{M}$.
\end{posledica}

\begin{proof}
	Trditev \ref{trd:gamma-napredek} velja za vsak kontekst $\Gamma$, torej tudi za $\Gamma = \emptyset$.
\end{proof}


\begin{izrek}[o napredku]
	Naj za proces $P$ velja $\emptyset \types P \of C$. Potem ali (i) obstaja proces $P'$, tak da $P \reduces P'$, ali pa (ii) velja $\ProcResult{P}$.
\end{izrek}

\begin{proof}
	Ker ima proces $P$ tip, obstaja drevo izpeljave za njegov tip.
	Dokazujemo z strukturno indukcijo na drevo izpeljave za procese.
	
	Osnovni primer je en sam, ko je $P$ enak $\tmrun{M}$. Ker ima $M$ tip, po posledici~\ref{pos:prazen-napredek} velja da, ali lahko $M$ naredi korak v $M'$ ali pa je $M$ delni rezultat.
	Če $M$ lahko naredi korak v $M'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmrun{M'}$.
	Sicer je $M$ delna vrednost in ločimo dva primera.
	Če je $M$ enak $\tmopout{op}{V}{N}$, potem lahko $P$ naredi korak v $\tmopout{op}{V}{\tmrun{N}}$.
	Sicer je tudi $P$ rezultat.
	
	Sedaj pokažimo, da izrek velja tudi za rekurzivno definirane procese.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyProc-Par}, potem je $P$ enak $\tmpar{Q_1}{Q_2}$. Ker imata $Q_1$ in $Q_2$ tip, lahko po $IP$ naredita korak ali pa sta že rezultata.
		Če lahko eden izmed njiju naredi korak, recimo $Q_1$ lahko naredi korak v $Q_1'$, lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmpar{Q_1'}{Q_2}$. Podobno dokažemo, če lahko $Q_2$ naredi korak.
		Sicer sta $Q_1$ in $Q_2$ rezultata. Ločimo dva primera.
		Če je eden izmed njiju enak $\tmopout{op}{V}{Q'}$, recimo $Q_1$. Potem lahko $P$ naredi korak v $\tmopout{op}{V}{(\tmpair{Q'}{\tmopin{op}{V}{Q_2}})}$. Podobno za $Q_2$.
		Sicer je tudi $P$ rezultat.
		
		\item Če je zadnje pravilo \rulename{TyProc-Signal}, potem je $P$ enak $\tmopout{op}{V}{Q}$. Proces $Q$ ima tip in po $IP$ lahko naredi korak ali pa je rezultat.
		Če $Q$ lahko naredi korak v $Q'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmopout{op}{V}{Q'}$.
		Sicer je tudi $P$ rezultat.
		
		\item Če je zadnje pravilo \rulename{TyProc-Interrupt}, potem je $P$ enak $\tmopin{op}{V}{Q}$. Proces $Q$ ima tip in po $IP$ lahko naredi korak ali pa je rezultat.
		Če $Q$ lahko naredi korak v $Q'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmopin{op}{V}{Q'}$.
		Če pa je $Q$ rezultat ločimo tri primere.
		\begin{itemize}
			\item Če je $Q$ enak $\tmrun{M}$, potem lahko $P$ naredi korak v $\tmrun{\tmopin{op}{V}{M}}$.
			\item Če je $Q$ enak $\tmopout{op'}{V'}{Q'}$, potem lahko $P$ naredi korak v $\tmopout{op'}{V'}{(\tmopin{op}{V}{Q'})}$.
			\item Če je $Q$ enak $\tmpar{Q_1}{Q_2}$, potem lahko $P$ naredi korak v $\tmpar{\tmopin{op}{V}{Q_1}}{\tmopin{op}{V}{Q_2}}$.
		\end{itemize}
		
	\end{itemize}
		
\end{proof}


\begin{lema}\label{lem:enolicnost-osnovnega-tipa}
	Če velja $\Gamma \types M \of \tycomp{A}{\o, \i}$ in $\Gamma \types M \of \tycomp{A'}{\o', \i'}$, potem velja $A = A'$.
\end{lema}

\begin{proof}
	content...
\end{proof}


\begin{lema}[o substituciji za vrednosti]\label{lem:substitucija-vrednosti}
	Naj za vrednost $V$ velja $\Gamma \types V \of A$ in za vrednost $W$ velja $\Gamma, x \of A \types W \of B$. Potem velja $\Gamma \types W[V/x] \of B$.
\end{lema}

\begin{proof}
	content...
\end{proof}


\begin{lema}[o substituciji za izračune]\label{lem:substitucija-izračuni}
	Naj za vrednost $V$ velja $\Gamma \types V \of A$ in za izračun $M$ velja $\Gamma, x \of A \types M \of \tycomp{B}{\o, \i}$. Potem velja $\Gamma \types M[V/x] \of \tycomp{B}{\o, \i}$.
\end{lema}

\begin{proof}
	Ker ima izračun $M$ tip, obstaja drevo izpeljave za njegov tip.
	Dokazujemo z strukturno indukcijo na drevo izpeljave za izračune.
	
	Osnovni primer je en sam, ko je $M$ enak $\tmreturn{W}$. Ker ima $\tmreturn{W}$ tip $\tycomp{B}{\o, \i}$, ima $W$ tip $B$.
	Po lemi~\ref{lem:substitucija-vrednosti} ima $W[V/x]$ tip $B$. Po pravilu \rulename{TyComp-Return} ima $\tmreturn{W[V/x]}$ tip $\tycomp{B}{\o, \i}$. Ker je $M[V/x]$ enak $\tmreturn{W[V/x]}$, ima tudi $M[V/x]$ tip $\tycomp{B}{\o, \i}$.
%	\begin{itemize}
%		\item Če je $W = x$, potem je $M$ enak  $\tmreturn{x}$ in ima tip $\tycomp{A}{\o, \i}$. Po lemi~\ref{lem:enolicnost-osnovnega-tipa} velja $B = A$ in posledično $\tycomp{A}{\o, \i} = \tycomp{B}{\o, \i}$. Izraz $M[V/x]$ je enak $\tmreturn{V}$. Ker ima $V$ tip $A$, ima $\tmreturn{V}$ tip $\tycomp{A}{\o, \i}$. Ker je $\tycomp{A}{\o, \i} = \tycomp{B}{\o, \i}$, ima $M[V/x]$ tip $\tycomp{B}{\o, \i}$.
%		\item Če je $W \neq x$, potem je $M[V/x] = M$ in posledično ima $M[V/x]$ tip $\tycomp{B}{\o, \i}$.
%	\end{itemize}
	
	
	Sedaj pokažimo, da lema velja tudi za rekurzivno definirane izračune.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $\tmlet{x}{N_1}{N_2}$. Izračuna $N_1$ in $N_2$ imata tip $\tycomp{C}{\o, \i}$ in $\tycomp{B}{\o, \i}$.
		Po $IP$ velja, da imata $N_1[V/x]$ in $N_2[V/x]$ isti tip. Ker je $M[V/x]$ enak $\tmlet{x}{N_1[V/x]}{N_2[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Let}.
		
		\item Če je uporabljeno pravilo \rulename{TyComp-Apply}, potem je $M$ enak $W_1 W_2$. Vrednost $W_1$ ima tip $\tyfun{C}{\tycomp{B}{\o, \i}}$ in vrednost $W_2$ ima tip $C$.
		Po lemi~\ref{lem:substitucija-vrednosti} imata $W_1[V/x]$ in $W_2[V/]$ isti tip. Ker je $M[V/x]$ enak $W_1[V/x] W_2[V/x]$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Apply}.
		
		\item ...TODO
	\end{itemize}




\end{proof}

\begin{trditev}[o ohranitvi]
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$. Če izračun $M$ naredi korak v izračun $M'$, potem velja $\Gamma \types M' \of A'$, kjer je $A' = $.
\end{trditev}

\begin{proof}
	...
\end{proof}

\begin{izrek}[o ohranitvi]
	Naj za proces $P$ velja $\Gamma \types P \of C$. Če proces $P$ naredi korak v proces $P'$, potem velja $\Gamma \types P' \of C'$, kjer je $C' = $.
\end{izrek}

\begin{proof}
	...
\end{proof}