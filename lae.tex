\section{Račun \lae{}}\label{sec:lae}

Leta 1930 je Alonzo Chuch z namenom formalizacije koncepta izračunljivosti uvedel preprost teoretičen programski jezik imenovan $\lambda$-račun, ki je tudi Turingovo poln~\cite{rojas2015tutorial}.
Od takrat je nastalo še mnogo drugih različnih verzij $\lambda$-računa.
Račun \lae{} je osnovan na Levy $\lambda$-računu iz članka~\cite{levy}. Računu \lae{} dodamo izraze, ki poosebijo bistvo asinhrono vzporednega programiranja s pomočjo učinkov. Da \lae{}-račun nekoliko približamo vsakdanjim programskim jezikom, mu dodamo tudi izraze za  naravna števila, par, ujemanje vzorca... Še vedno pa izpustimo veliko izrazov, ki jih sicer imamo v jeziku \aeff{}.


\subsection{Izrazi}

Izraze v \lae{}-računu razdelimo na vrednosti, izračune in procese. Pripadajočo sintakso vidimo na sliki~\ref{fig:izrazi} v Backus-Naurjevi obliki (BNF).

Imamo običajne vrednosti, kot so spremenljivke, naravna števila, enote, pari, leve in desne inkluzije, funkcije in rekurzivne funkcije.
Nova vrednost je \emph{obljuba}\footnote{Tudi nekateri drugi programski jeziki imajo obljube za namene \emph{asinhronega} izvajanja, kot na primer Scala~\cite{scala} ali Alice~\cite{lambdapf}. Kljub temu pa običajno ne v navezi z učinki.}. Je vrednost, ki jo je vrnil prestreznik in jo posebej označimo, da ji lažje pravilno določimo tip.

Imamo običajne izračune, kot so vračanje vrednosti, zaporedje, ujemanje za pare in vsote in aplikacija.
Poleg teh imamo tudi sledeče.

\emph{Signal} $\tmopout{op}{V}{M}$ vsebuje operacijo $\op$, pripadajočo vrednost $V$ imenovano \emph{tovor} in nadaljevanje $M$\footnote{V \lae{}-računu ima signal eksplicitno kontinuacijo in obliko algebraične operacije. Nasprotno ima signal v jeziku \aeff{} (primer~\ref{prog:primer-1}) kontinuacijo implicitno in obliko generičnega učinka. Predstavitev operacij z učinki upravičita Plotkin in Power~\cite{op-eff}.}. Signal se razširi navzgor po izračunih, dokler ne pride na nivo procesov. Nakar se bo razširil v vse druge procese in ob tem spremenil v \emph{prekinitev} $\tmopin{op}{V}{M}$\footnote{Ni mišljeno da programer eksplicitno uporabi prekinitev, ampak nastane le s pretvorbo iz signala.}. Prekinitev je simetrična signalu, prav tako ima operacijo $\op$, vrednost $V$ in nadaljevanje $M$. Le da prekinitev potuje po izračunih navznoter namesto navzgor. Na ta način smo informacijo $V$ prenesli iz enega procesa na vse preostale in tako imamo vzpostavljeno komunikacijo med procesi. Da imamo asinhrono izvajanje lahko, namesto da se signal in prekinitev širita, delamo korake tudi v njunem nadaljevanju $M$.

S pomočjo \emph{prestreznika} $\tmwith{op}{x}{M}{p}{N}$ prestrežemo tovor v prekinitvi. Prestreznik je sestavljen iz operacije $\op$, spremenljivke $x$, izračunom $M$ imenovanim \emph{sproženi izračun}, spremenljivko $p$ imenovano \emph{obljuba} in nadaljevanje $N$.
Običajno se izvaja nadaljevanje $N$, med tem ko preostali deli čakajo. Ko pride prekinitev z istim imenom operacije, se spremenljivka $x$ substituira z tovorom $V$ v obljubi $M$. Nakar se prestreznik spremeni v zaporedje $\tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}$. Čeprav je prestreznik ujel prekinitev, se slednja vseeno naprej širi navznoter na nadaljevanju $N$. Ko prestreznik ujame ustrezno prekinitev rečemo, da se je izpolnila obljuba $p$.
Da preprečimo uporabo spremenljivke $p$ preden se je izpolnila, jo lahko uporabi le \emph{blokada} $\tmawait{V}{x}{M}$. V primeru da se obljuba $p$ še ni izpolnila in je vrednost $V$ v blokadi le $p$, bo blokada preprečevala izvajanje svojega nadaljevanja $M$. Če pa se je izpolnila, se bo pripadajoča vrednost vezala v novo navadno spremenljivko $x$. Nakar se bo izvajanje nadaljevalo.

Osnovni proces je \emph{zagon} $\tmrun{M}$. Vsebuje le izračun $M$, ki se izvaja.
\emph{Signal procesa} $\tmopout{op}{V}{P}$ in \emph{prekinitev procesa} $\tmopin{op}{V}{P}$ delujeta enako kot signal izračuna in prekinitev izračuna, le da delujeta na procesih. Njuna naloga je, da preneseta učinke iz enega procesa na preostale.
\emph{Vzporeden proces} $\tmpar{P}{Q}$ vsebuje dva procesa. Vzporedne procese lahko gnezdimo in tako dobimo drevo procesov s signali, prekinitvami in vzporednimi procesi za veje in zagoni za liste. Na ta način imamo lahko kot del programa več procesov, ki se potencialno izvajajo hkrati.



\begin{figure}[H]

	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Vrednosti}}
	V, W
	\bnfis& x                                       & &\text{spremenljivka} \\
	\bnfor& n    							        & &\text{naravno število} \\
	\bnfor& \tmunit \bnfor\! \tmpair{V}{W}          & &\text{enota in par} \\
	\bnfor& \tminl[B]{V} \bnfor\! \tminr[A]{V}      & &\text{leva in desna inkluzija} \\
	\bnfor& \tmfun{x \of A}{M}                      & &\text{funkcija} \\
	\bnfor& \tmfunrec{f}{x \of A}{M}                  & &\text{rekurzivna funkcija} \\
	\bnfor& \tmpromise V                            & &\text{obljuba}
	\\[1ex]
	\intertext{\textbf{Izračuni}}
	M, N
	\bnfis& \tmreturn{V}                            & &\text{vračanje vrednosti} \\
	\bnfor& \tmlet{x}{M}{N}                         & &\text{zaporedje} \\
	\bnfor& \tmmatch[]{V}{}                         & &\text{prazno ujemanje} \\
	\bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    & &\text{ujemanje produkta} \\
	\bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}	& &\text{ujemanje vsote} \\
	\bnfor& V\,W                                    & &\text{aplikacija} \\
	\bnfor& \tmopout{op}{V}{M}       & &\text{signal izračuna} \\
	\bnfor& \tmopin{op}{V}{M}          & &\text{prekinitev izračuna} \\
	\bnfor& \tmwith{op}{x}{M}{p}{N}      & &\text{prestreznik} \\
	\bnfor& \tmawait{V}{x}{M}             & &\text{blokada}
		\\[1ex]
	\intertext{\textbf{Procesi}}
 	P, Q
	\bnfis & \tmrun M & & \text{zagon} \\
	\bnfor & \tmpar P Q & & \text{vzporedna procesa} \\
	\bnfor & \tmopout{op}{V}{P} & & \text{signal procesa} \\
	\bnfor & \tmopin{op}{V}{P} & & \text{prekinitev procesa}
	\end{align*}

	\caption{Vrednosti, izračuni in procesi.}
	\label{fig:izrazi}
\end{figure}


\subsection{Operacijska semantika}

Sedaj ko poznamo izraze v \lae{}-računu si poglejmo kaj z njimi početi. Definirali bomo pravila kako spreminjati izračune, s čimer bomo izvajali program. 

V nadaljevanju bomo uporabljali substitucije.  Substitucije na vrednostih in izračunih definiramo, kot vidimo na sliki~\ref{fig:substitucije}. Sledimo konvenciji, da če se v nekem kontekstu pojavijo vezane spremenljivke, jih izberemo drugače od prostih spremenljivk~\cite{barendregt}.

\begin{figure}[H]
	\centering
	\small
	\textbf{Vrednosti}
	\begin{mathpar}
		x[V/x] = V \qquad y[V/x] = y\ {\color{rulenameColor}(y \neq x)} \qquad n[V/x] = n \\
		()[V/x] = () \qquad	\tmpair{W_1}{W_2}[V/x] = \tmpair{W_1[V/x]}{W_2[V/x]} \\
		(\tminl{W})[V/x] = \tminl{(W[V/x])} \qquad (\tminr{W})[V/x] = \tminr{(W[V/x])} \\
		(\tmfunano{y}{M})[V/x] = \tmfunano{y}{(M[V/x])} \\
		(\tmfunrecano{f}{y}{M})[V/x] = \tmfunrecano{f}{y}{(M[V/x])} \\
		\tmpromise{W}[V/x] = \tmpromise{W[V/x]}
	\end{mathpar}
	\textbf{Izračuni}
	\begin{align*}
		(\tmreturn{W})[V/x] &= \tmreturn{(W[V/x])}
		\razmik
		(\tmlet{y}{M}{N})[V/x] &= \tmlet{y}{(M[V/x])}{(N[V/x])}
		\razmik
		(\tmmatch{W}{\tmpair{y_1}{y_2} \mapsto M})[V/x] &= \tmmatch{W[V/x]}{\tmpair{y_1}{y_2} \mapsto (M[V/x])}
		\razmik
		(\tmmatch{W}{\tminl{y_1} \mapsto M_1, \tminr{y_2} \mapsto& M_2})[V/x] = \\  
		\tmmatch{W[V/x]&}{\tminl{y_1} \mapsto (M_1[V/x]), \tminr{y_2} \mapsto (M_2[V/x])}
		\razmik
		(\tmapp{W_1}{W_2})[V/x] &= \tmapp{(W_1[V/x])}{(W_2[V/x])}
		\razmik
		(\tmopout{op}{W}{M})[V/x] &= \tmopout{op}{W[V/x]}{M[V/x]}
		\razmik
		(\tmopin{op}{W}{M})[V/x] &= \tmopin{op}{W[V/x]}{M[V/x]}
		\razmik
		(\tmwith{op}{y}{M}{p}{N})[V/x] &= \tmwith{op}{y}{M[V/x]}{p}{N[V/x]}
		\razmik
		(\tmawait{W}{y}{M})[V/x] &= \tmawait{W[V/x]}{y}{M[V/x]}
	\end{align*}
	\caption{Substitucije za vrednosti in izračune.}
	\label{fig:substitucije}
\end{figure}


Račun \lae{} opremimo z operacijsko semantiko malih korakov, ki je definirana z relacijo korak $M \reduces N$. Koraki za izračune so podani na sliki~\ref{fig:small-step-semantics-of-computations}. 

\begin{figure}[H]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Pravila osnovnih izračunov}}
	\tmlet{x}{(\tmreturn V)}{N} &\reduces N[V/x]
	\\
	\tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto M} &\reduces M[V/x, W/y]
	\\
	\mathllap{\tmmatch{(\tminl[B]{V})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	M[V/x]
	\\
	\mathllap{\tmmatch{(\tminr[A]{W})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	N[W/y]
	\\
	\tmapp{(\tmfun{x \of A}{M})}{V} &\reduces M[V/x]
	\\
	\tmapp{(\tmfunrec{f}{x \of A}{M})}{V} &\reduces M[V/x, (\tmfunrec{f}{x \of A}{M})/f]
	\\[1ex]
	\intertext{\textbf{Algebraičnost signala in prestreznika}}
	\tmlet{x}{(\tmopout{op}{V}{M})}{N} &\reduces \tmopout{op}{V}{\tmlet{x}{M}{N}}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\tmlet{x}{(\tmwith{op}{y}{M}{p}{N_1})}{N_2} \reduces \\
	\tmwith{op}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{Komutativnost operacij}}
	\tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmopout{op'}{W}{M}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{M}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmreturn W} &\reduces \tmreturn W
	\\
	\tmopin{op}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}
	\\
	\tmopin{op'}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmwith{op}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\\[1ex]
	\intertext{\textbf{Čakanje na izpolnitev obljube}}
	\tmawait{\tmpromise V}{x}{M} &\reduces M[V/x]
	\end{align*}
	
	\textbf{Evalvacija v okolju}
	\begin{align*}
	\coopinfer{}{
		M \reduces M'
	}{
		\tmlet{x}{M}{N} \reduces \tmlet{x}{M'}{N}
	}
	\end{align*}
\vspace{-4ex}
	\begin{align*}
	\coopinfer{}{
		M \reduces M'
	}{
		\tmopout{op}{V}{M} \reduces \tmopout{op}{V}{M'}
	}
	\qquad
	\coopinfer{}{
		M \reduces M'
	}{
		\tmopin{op}{V}{M} \reduces \tmopin{op}{V}{M'}
	}
	\end{align*}
\vspace{-4ex}
	\begin{align*}
	\coopinfer{}{
		N \reduces N'
	}{
		\tmwith{op}{x}{M}{p}{N} \reduces \tmwith{op}{x}{M}{p}{N'}
	}
	\end{align*}
	
	\caption{Koraki za izračune.}
	\label{fig:small-step-semantics-of-computations}
\end{figure}


Poleg teh pravil, ki so identična pravilom od Ahmana in Pretnarja~\cite{aeff}, dodamo še dve novi pravili, ki ju lahko vidimo na sliki~\ref{fig:operacijska-semantika-poenostavitev}.
Prvo pravilo potegne blokado ven iz zaporedja. Drugo pravilo prestavi prekinitev takoj za blokado. Obe pravili skupaj dosežeta dvoje. Malenkost večji del prvotnega izračuna je postal asinhron. Kar nam lahko v primeru, da bo obljuba izpolnjena in bomo nadaljevali z izvajanjem tega dela, nekoliko pohitri izvajanje. Druga prednost pa je, da se izračun, ki je v čakajočem stanju, vedno začne z blokado, kar nam bo prišlo prav kasneje, ko bomo preverjali ali je izračun v obliki rezultata.


\begin{figure}[H]
	\centering
	\small
	\begin{align*}
		\intertext{\textbf{Algebraičnost blokade}}
		\tmlet{x}{(\tmawait{V}{y}{M})}{N} & \reduces \tmawait{V}{y}{(\tmlet{x}{M}{N})}
		\\[1ex]
		\intertext{\textbf{Komutativnost blokade in prekinitve}}
		\tmopin{op}{V}{\tmawait{W}{x}{M}} &\reduces \tmawait{W}{x}{\tmopin{op}{V}{M}}
	\end{align*}
	
	\caption{Dodatni pravili operacijske semantike.}
	\label{fig:operacijska-semantika-poenostavitev}
\end{figure}

Zagon dela korake tako, da dela korake na pripadajočem izračunu.
Ko se signal širi navzgor se kopija pretvori v prekinitev in razširi na vzporedne procese. Lahko se izvaja tudi njegovo nadaljevanje.
Prekinitev se širi navznoter. Kadar naleti na dva vzporedna procesa se razširi v oba. Lahko se izvaja njeno nadaljevanje. 
Par procesov lahko naredi korak, če lahko eden izmed procesov naredi korak.
Koraki za procese so podani na sliki~\ref{fig:small-step-semantics-of-processes}.

\begin{figure}[H]
    \centering
	\small
	\begin{minipage}[t]{0.4\textwidth}
		\centering
		\begin{align*}
		\intertext{\textbf{Posamezen proces}}
		\coopinfer{}{
			M \reduces N
		}{
			\tmrun M \reduces \tmrun N
		}
		\end{align*}
	\end{minipage}
	\qquad
	\begin{align*}
	\intertext{\textbf{Prehod}}
	\tmrun {(\tmopout{op}{V}{M})}  &\reduces \tmopout{op}{V}{\tmrun M}
	\\
	\tmopin{op}{V}{\tmrun M} &\reduces \tmrun {(\tmopin{op}{V}{M})}
	\\[1ex]
	\intertext{\textbf{Oddajanje signala}}
	\tmpar{\tmopout{op}{V}{P}}{Q} &\reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
	\\
	\tmpar{P}{\tmopout{op}{V}{Q}} &\reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{P}}{Q}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmpar P Q} &\reduces \tmpar {\tmopin{op}{V}{P}} {\tmopin{op}{V}{Q}}
	\\[1ex]
	\intertext{\textbf{Komutativnost signala in prekinitve}}
	\tmopin{op}{V}{\tmopout{op'}{W}{P}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{P}}
	\end{align*}
	
	\textbf{Evalvacija v okolju}
	\begin{align*}
	\coopinfer{}{
		P \reduces P'
	}{
		\tmpar{P}{Q}  \reduces \tmpar{P'}{Q}
	}
	\qquad
	\coopinfer{}{
		Q \reduces Q'
	}{
		\tmpar{P}{Q}  \reduces \tmpar{P}{Q'}
	}
	\end{align*}
\vspace{-4ex}
	\begin{align*}
		\coopinfer{}{
			P \reduces P'
		}{
			\tmopout{op}{V}{P}  \reduces \tmopout{op}{V}{P'}
		}
		\qquad
		\coopinfer{}{
			P \reduces P'
		}{
			\tmopin{op}{V}{P}  \reduces \tmopin{op}{V}{P'}
		}
	\end{align*}
	
	\caption{Koraki za procese.}
	\label{fig:small-step-semantics-of-processes}
\end{figure}



\subsection{Sistem tipov}

Da se izognemo programom, ki bi se ustavili v neželeni obliki, uvedemo sistem tipov.
Tipe ločimo na tipe za vrednosti, izračune in procese. Vidimo jih na sliki~\ref{fig:tipi}.

\begin{figure}[H]
	\centering
	\small
	\textbf{Tipi}
	\begin{align*}
		\text{Osnovni tipi vrednosti $\bar{A}$, $\bar{B}$}
		\bnfis & \tysym{int} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\bar{A}}{\bar{B}} \,\bnfor\! \tysum{\bar{A}}{\bar{B}}
		\\%[1ex]
		\text{Tipi vrednosti $A$, $B$}
		\bnfis & \bar{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
		\\
		\text{Tip izračuna $A$} \bnfis& \tycomp{A}{\o,\i}
		\\
		\text{Tip procesa $\tyC$, $\tyD$}  \bnfis & \tyrun{A}{\o, \i} \,\bnfor\! \typar{\tyC}{\tyD}
	\end{align*}
	\textbf{Operacije in pripadajoči osnovni tipi}
	\begin{align*}
		(op_1, \bar{A}_{op_1}),\, (op_2, \bar{A}_{op_2}),\, ... ,\, (op_n, \bar{A}_{op_k})
	\end{align*}
	\caption{Tipi izrazov in tipi, ki pripadajo določenim operacijam.}
	\label{fig:tipi}
\end{figure}

Večina vrednosti dobi standardne tipe, kot so naravno število, enota, par, vsota in funkcijski tip. 
Ker funkcijski tip označuje funkcijo, ki vzame argument in mu priredi izračun, le tej pa imajo, kot bomo kasneje videli, poleg standardnih tipov, še tipe za učinke, ima tudi funkcijski tip dodane tipe za učinke.
Dodatno uvedemo \emph{tip obljub} $\typromise{A}$, ki predstavlja obljube, izpolnjene z vrednostmi tipa A. 
Tipom za vrednosti, ki ne vsebujejo funkcijskega tipa ali obljube, pravimo \emph{osnovni tipi}.
Danim operacijam dodelimo osnovni tip, kar bo kasneje ključno, ko bomo hoteli dokazati ohranitev.

Pravila za določitev tipa vrednosti vidimo na sliki~\ref{fig:value-typing-rules}.

\begin{figure}[H]
	\centering
	\small
	\begin{mathpar}
		\quad
		\coopinfer{TyVal-Var}{
		}{
			\Gamma, x \of A, \Gamma' \types x : A
		}
		\quad
		\coopinfer{TyVal-Cons}{
		}{
			\Gamma \types n : \tysym{int}
		}
		\qquad
		\coopinfer{TyVal-Unit}{
		}{
			\Gamma \types \tmunit : \tyunit
		}
		\quad
		\coopinfer{TyVal-Pair}{
			\Gamma \types V : A \\
			\Gamma \types W : B
		}{
			\Gamma \types \tmpair{V}{W} : \typrod{A}{B}
		}
		\\
		\coopinfer{TyVal-Inl}{
			\Gamma \types V : A
		}{
			\Gamma \types \tminl[B]{V} : A + B
		}
		\quad
		\coopinfer{TyVal-Inr}{
			\Gamma \types W : B
		}{
			\Gamma \types \tminr[A]{W} : A + B
		}
		\quad
		\coopinfer{TyVal-Fun}{
			\Gamma, x \of A \types M : \tycomp{B}{\o,\i}
		}{
			\Gamma \types \tmfun{x : A}{M} : \tyfun{A}{\tycomp{B}{\o,\i}}
		}
		\\
		\coopinfer{TyVal-Fun-Rec}{
			\Gamma,f \of \tyfun{A}{\tycomp{B}{\o,\i}}, x \of A \types M : \tycomp{B}{\o,\i}
		}{
			\Gamma \types \tmfunrec{f}{x : A}{M} : \tyfun{A}{\tycomp{B}{\o,\i}}
		}
		\quad
		\coopinfer{TyVal-Promise}{
			\Gamma \types V : A
		}{
			\Gamma \types \tmpromise V : \typromise A
		}
	\end{mathpar}
	\caption{Pravila za določitev tipov za vrednosti.}
	\label{fig:value-typing-rules}
\end{figure}

Izračunom poleg standardnega tipa dodamo še tipe signalov, ki jih lahko sprožijo, označene z $\o$ in tipe prekinitev, ki jih lahko prestrežejo, označene z $\i$.
Tipi učinkov $\o$ in $\i$ so elementi množice $O$ oziroma $I$.
Ko se signal sproži, le to nima direktnega vpliva na nadaljevanje izračuna. Naj bo $\sig = \{\op_1, ..., \op_n\}$ množica vseh operacij, ki jih imamo na voljo. Potem je množica $O$ preprosto potenčna množica množice $\sig$ in $\o$ predstavlja množico signalov, ki jih izračun lahko sproži. Tu bistveno ne zahtevamo, da izračun tudi dejansko sproži vse signale, ki bi jih lahko glede na $\o$.  
Množica $I$ je nekoliko bolj zakomplicirana. Ko prestreznik ujame prekinitev, se bo nadaljevanju dodal sproženi izračun iz prestreznika. Slednji lahko vsebuje nove signale in prestreznike. Posledično lahko sedaj spremenjeni izračun začne oddajati nove signale in prestrezati nove prekinitve. Toda tudi novi prestrezniki lahko ponovno namestijo nove signale in nove prestreznike in tako naprej.
To (potencialno neskončno) rekurzivno ponavljanje prestreznikov želimo prikazati v tipu.
Množico $I$ definiramo kot največjo fiksno točko preslikave $\Omega$, definirane kot 
$$\Omega(X) = \sig \Rightarrow (O \times X)_\bot ,$$
kjer je $\Rightarrow$ potenciranje, $\times$ je kartezični produkt in $(-)_\bot$ je dvig. Dvig je disjunktna unija množice z $\bot$.
Sledeča notacija $\i = \{\op_1 \mapsto (\o_1,\i_1),...,\op_k \mapsto (\o_k, \i_k)\}$ predstavlja $\i$, ki slika $\op_i$ v $(\o_i, \i_i)$ in vse ostale $\op \in \Sigma$ slika v $\bot$.
%Preslikava $\Omega$ je endofunktor na kategoriji omega kompletnih delnih ureditvah 

Če izračun za neko operacijo $\op$ ne bo imel prestreznika, se bo to v $\i$ izražalo tako, da bo $\i$ slikal $\op$ v $\bot$. 
Sicer bo $\i$ slikal $\op$ v par $(\o', \i')$, kjer $\o'$ predstavlja nove signale in $\i'$ nove prestreznike v sproženih izračunih.
Recimo izračun $$\tmopout{op}{V}{\tmwith{op'}{x}{\tmopout{op''}{W}{\tmreturn{\tmpromise{()}}}}{p}{\tmreturn{()}}}$$ ima tip učinkov $(\{\op\}, \{\op' \mapsto (\{\op''\},\{\})\})$, saj sproži signal $\op$ in ima prestreznik za $\op'$. Ko bo prestreznik prestregel prekinitev z operacijo $\op'$ se bo od sedaj naprej lahko sprožil tudi signal z operacijo $\op''$, ne bomo pa dodali nobenega novega prestreznika, ki bi lahko prestregel kakšno dodatno operacijo.

Ko izračun od zunaj dobi novo prekinitev z operacijo $\op$, se izračunu lahko spremeni tip učinkov. Pravimo da je operacija $\op$ delovala na tip učinkov.
Če v izračunu ni ustreznega prestreznika in posledično $\i$ slika operacijo v $\bot$, potem prekinitev ne bo vplivala na izračun.
Če pa imamo ustrezen prestreznik, kar se v tipu vidi tako da $i$ slika v nek $(\o',\i')$, potem nov tip signalov dobimo tako, da preprosto naredimo unijo $\o \cup \o'$. Ker se bo prekinitev razširila čez celotno nadaljevanje, bo sprožila vse ustrezne prestreznike in bo tip prekinitev sedaj kazal na $\bot$.
Nato naredimo ustrezno unijo $\i \cup \i'$, da dodamo nove učinke iz sproženih izračunov.
Spremembe, ki se zgodijo ko izračun ali proces dobi novo prekinitev, natančneje definira sledeča preslikava.

$$\opincomp{op}{(\o, \i)}~\defeq~
\begin{cases}
	\left(\o \cup \o' , \i[\op \mapsto \bot] \cup \i' \right) & \mbox{če } \i\, (\op) = (\o',\i')\\
	(\o,\i) & \mbox{sicer} 
\end{cases}$$

Tip $\i[\op \mapsto \bot]$ je povsod enak $\i$, le $\op$ sedaj kaže na $\bot$.
$$
\i \cup \i'
~\defeq~
\op \mapsto 
\begin{cases}
	(\o'' \cup \o''' , \i'' \cup \i''') & \mbox{če } \i\, (\op) = (\o'',\i'') \wedge \i'\, (\op) = (\o''',\i''') \\
	(\o'' , \i'') & \mbox{če } \i\, (\op) = (\o'',\i'') \wedge \i'\, (\op) = \bot \\
	              & \mbox{ali } \i\, (\op) = \bot \wedge \i'\, (\op) = (\o'',\i'') \\
	\bot & \mbox{če } \i\, (\op) = \bot \wedge \i'\, (\op) = \bot \\
\end{cases}
$$

Na tipih učinkov imamo urejenost. Na $O$ je urejenost dana z relacijo podmnožica $\subseteq$. Vseeno bomo pisali $\order{O}$. Relacija $\order{O}$ skupaj z $O$ je delna urejenost.
Urejenost na $I$ pa je dana s sledečo relacijo.
$$
\begin{array}{l c l}
	\i \order I \i'
	&
	\defiff
	&
	\forall\, (\op \in \sig) \, (\o'' \in O) \, (\i'' \in I) .\, \i\, (\op) = ({\o''} , {\i''}) \implies 
	\\[0.5ex]
	&& \exists\, (\o''' \in O) \, (\i''' \in I) .\, \i'\, (\op) = ({\o'''} , {\i'''}) \wedge \o'' \order O \o''' \wedge \i'' \order I \i'''
\end{array}
$$
Delno urejenost na produktu definiramo po komponentah.
$$(\o, \i) \order{O \times I} (\o', \i') \defiff \o \order{O} \o' \wedge \i \order{I} \i'$$

V sledeči lemi~\ref{lem:partial-order} pokažemo, da je $I$ skupaj z $\order{I}$ res delna urejenost in posledično tudi $O \times I$ z $\order{O \times I}$.
Dokazujemo s koindukcijo, ki se jo lahko uporablja za dokazovanje lastnosti neskončnih struktur~\cite{coinduction,slak}. 


\begin{lema}\label{lem:partial-order}
	\begin{enumerate}
		\item Refleksivnost - $\i \order{I} \i$
		\item Antisimetričnost - $\i \order{I} \i' \wedge \i' \order{I} \i \Rightarrow \i' = \i$
		\item Tranzitivnost - $\i_1 \order{I} \i_2 \wedge \i_2 \order{I} \i_3 \Rightarrow \i_1 \order{I} \i_3$
	\end{enumerate}
\end{lema}

\begin{proof}
	\begin{enumerate}
		\item Za $\i(\op) = \bot$ je pogoj iz definicije $\order{I}$ na prazno izpolnjen.
		Naj bo sedaj $\i(\op) = (\o'',\i'')$. Tedaj sta iskana $\o'''$ in $\i'''$ iz definicije ravno $\o''$ in $\i''$. $\o''\order{O}\o''$ velja, ker je $\order{O}$ delna urejenost. $\i'' \order{I} \i''$ velja po koindukcijski predpostavki.
		
		\item Naj bo $\i(\op) = \bot$. Ker je $\i' \order{I} \i$, mora veljati $\i'(\op) = \bot$.
		Naj bo sedaj $\i(\op) = (\o'', \i'')$ in $\i'(\op) = (\o''',\i''')$. Ker velja $\i \order{I} \i' \wedge \i' \order{I} \i$, velja $\o'' \order{O} \o''' \wedge \o''' \order{O} \o''$. Ker je $\order{O}$ delna urejenost, velja $\o'' = \o'''$. Ker velja $\i'' \order{I} \i''' \wedge \i''' \order{I} \i''$, po koindukcijski predpostavki velja $\i'' = \i'''$.
		Za $\i(\op) = (\o'', \i'')$ in $\i'(\op) = \bot$ neenakost $\i \order{I} \i'$ ne velja, zato ta možnost ne pride v poštev.
		
		\item Za $\i_1(\op) = \bot$ je pogoj iz definicije $\order{I}$ na prazno izpolnjen.
		Naj bo sedaj $\i_1(\op) = (\o_1', \i_1')$. Ker je $\i_1 \order{I} \i_2$, mora biti $\i_2(\op) = (\o_2', \i_2')$.
		Po istem razmisleku je $\i_3(\op) = (\o_3', \i_3')$. Ker je $\order{O}$ delna urejenost, velja $\o_1' \order{O} \o_3'$.
		Po koindukcijski predpostavki velja tudi $\i_1' \order{I} \i_3'$.
		
	\end{enumerate}
\end{proof}


Sledeča lema pravi, da je $\cup$ na $I$ simetrična operacija, spoštuje $\order{I}$ in da je $I$ $\sqcup$-polmreža.

\begin{lema}\label{lem:effects-union}
	\begin{enumerate}
		\item $\i_1 \cup \i_2 = \i_2 \cup \i_1$
		\item $\i \order{I} (\i' \cup \i)$
		\item $\i_1 \order{I} \i_3 \wedge \i_2 \order{I} \i_3 \Rightarrow (\i_1 \cup \i_2) \order{I} \i_3$
	\end{enumerate}

\end{lema}

\begin{proof}
	\begin{enumerate}
		\item Za $\op$ za katere velja $\i_1(\op) = \bot$, je $(\i_1 \cup \i_2)(\op) = \i_2(\op) = (\i_2 \cup \i_1)(\op)$.
		Simetrično za $\op$ za katere je $\i_2(\op) = \bot$.
		Naj bo sedaj $\i_1(\op) = (\o_1', \i_1')$ in $\i_2(\op) = (\o_2', \i_2')$.
		Ker je $\cup$ na množicah simetrična in $\i_1' \cup \i_2' = \i_2' \cup \i_1'$ po koindukcijski predpostavki, velja $(\i_1 \cup \i_2)(\op) = (\o_1' \cup \o_2', \i_1' \cup \i_2') = (\o_2' \cup \o_1', \i_2' \cup \i_1') = (\i_2 \cup \i_1)(\op)$.
		
		\item Za $\op$ za katere velja $\i(\op) = \bot$, je pogoj iz definicije $\order{I}$ na prazno izpolnjen.
		Naj bo sedaj $\i(\op) = (\o'', \i'')$. 
		Če $\i'(\op) = \bot$, tedaj je $(\i' \cup \i)(\op) = (\o'', \i'')$ in pogoj iz definicije $\order{I}$ velja.
		Če $\i'(\op) = (\o''', \i''')$, tedaj je $(\i' \cup \i)(\op) = (\o'' \cup \o''', \i'' \cup i''')$.
		Po koindukcijski predpostavki velja $(\o'', \i'') \order{O \times I} (\o'' \cup \o''', \i'' \cup i''')$ in je pogoj iz definicije $\order{I}$ ponovno izpolnjen.
		
		\item Za $\op$ za katere velja $\i_1(\op) = \bot$, je $(\i_1 \cup \i_2)(\op) = \i_2(\op)$. Ker je $\i_2 \order{I} \i_3$, velja $(\i_1 \cup \i_2)(\op) \order{O \times I} \i_3(\op)$.
		Simetrično za $\op$ za katere je $\i_2(\op) = \bot$.
		Naj bo sedaj $\i_1(\op) = (\o_1', \i_1')$ in $\i_2(\op) = (\o_2', \i_2')$ in $\i_3(\op) = (\o_3', \i_3')$. Ker je $O$ z $\order{O}$ $\sqcup$-polmreža velja $(\o_1' \cup \o_2') \order{O} \o_3'$. Ker je $\i_1' \order{I} \i_3'$ in $\i_2' \order{I} \i_3'$ je po koindukcijski predpostavki $(\i_1' \cup \i_2') \order{I} \i_3'$.
	\end{enumerate}

\end{proof}

V lemi~\ref{lem:effects-order} navedimo nekaj lastnosti, ki jih bomo potrebovali kasneje v dokazu trditve o ohranitvi.
Pri tem sta $\pi_1$ in $\pi_2$ prva in druga projekcija.
Prva lastnost nam pove, da ko prekinitev sproži vse prestreznike to ne vpliva že obstoječe signale, kvečjemu lahko dobimo kakšen nov signal.
Druga lastnost pravi, da ko operacija sproži vse prestreznike se bodo signali in prestrezniki v sproženih izračunih pridružili že obstoječim.
Tretja lastnost pravi, da prekinitev ne vpliva na prestreznike z drugačnim imenom operacije.
Četrta lastnost pravi da je $\opincomp{op}{}$ monotona preslikava.

\begin{lema}\label{lem:effects-order}
	\begin{enumerate}
		\item\label{lem:eo-1} $o \order{O} \pi_1 (\opincomp{op}{(\o, \i)})$
		\item\label{lem:eo-3} Če $\i(\op) = (\o', \i')$, potem $(\o', \i') \order{O \times I} \opincomp{\op}{(\o, \i)}$
		\item\label{lem:eo-4} Če $\op \neq \op'$ in $\i(\op') = (\o', \i')$, potem $(\o', \i') \order{O \times I} (\pi_2(\opincomp{\op}{(\o, \i)}))(\op')$
		\item\label{lem:eo-5} Če $(\o, \i) \order{O \times I} (\o', \i')$, potem $\opincomp{op}{(\o, \i)} \order{O \times I} \opincomp{op}{(\o', \i')}$
	\end{enumerate}
\end{lema}

\begin{proof}
	\begin{enumerate}
		\item Ali $\opincomp{op}{(\o, \i)} = (\o \cup \o' , \i[\op \mapsto \bot] \cup \i')$ ali $\opincomp{op}{(\o, \i)} = (\o, \i)$. V obeh primerih lastnost sledi.
		\item Če $\i(\op) = (\o', \i')$ potem $\opincomp{op}{(\o, \i)} = (\o \cup \o' , \i[\op \mapsto \bot] \cup \i')$. Očitno velja $\o' \order{O} (\o \cup o')$.
		Prav tako velja $\i' \order{I} (\i[\op \mapsto \bot] \cup \i')$ po lemi~\ref{lem:effects-union}.
		\item Ločimo dve možnosti.
		Prva možnost je, da $\i(op) = (\o'', \i'')$. Potem velja $\opincomp{\op}{(\o, \i)} = (\o \cup \o'' , \i[\op \mapsto \bot] \cup \i'')$.
		Ker $\op \neq \op'$ velja $\i[\op \mapsto \bot](\op') = (\o', \i')$.
		Posledično velja $(\o', \i') \order{O \times I} (\i[\op \mapsto \bot] \cup \i'')(\op')$, ker je $\i[\op \mapsto \bot] \order{I} \i[\op \mapsto \bot] \cup \i''$ in upoštevajoč definicijo $\order{I}$. Ker je $(\i[\op \mapsto \bot] \cup \i'')(\op') = (\pi_2(\opincomp{\op}{(\o, \i)}))(\op')$ je lastnost dokazana.
		Druga možnost je $\i(op) = \bot$. Tedaj je $\opincomp{op}{(\o, \i)} = (\o, \i)$ in lastnost sledi. 
		\item Ker je $\i \order{I} \i'$, velja $(\_, \i'') = \i(op) \order{O \times I} \i'(op) = (\_, \i''')$. Posledično velja $\pi_2(\opincomp{op}{(\o, \i)}) = \i \cup \i'' \order{I} \i' \cup \i''' = \pi_2(\opincomp{op}{(\o', \i')})$.
		Urejenost za tipe signalov pokažemo simetrično.
	\end{enumerate}
\end{proof}

Za tip $\tycomp{A}{\o, \i}$ rečemo, da je pod tip tipa $\tycomp{A}{\o', \i'}$, če velja $(\o, \i) \order{O \times I} (\o', \i')$. Če lahko izračunu določimo nek podtip $\tycomp{A}{\o, \i}$ tipa $\tycomp{A}{\o', \i'}$, potem ima izračun tudi tip $\tycomp{A}{\o', \i'}$.

%Vsaki operaciji priredimo nek tip, kot vidimo na sliki~\ref{fig:tipi}.
Sedaj si poglejmo še standardni del tipa izračunov.
Pravila za določitev tipa izračunov vidimo na sliki~\ref{fig:computation-typing-rules}.
Signal ima isti tip kot njegovo nadaljevanje. Sproti pa preverimo, da je operacija $\op$ v $\o$ in da ima tovor tip, ki pripada operaciji.
Ker izračun 
$$ \tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} $$
lahko naredi korak v izračun
$$ \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}}$$
(glej sliko~\ref{fig:small-step-semantics-of-computations}),
je ključno da tovor $V$ ne vsebuje spremenljivke $p$, saj v drugem izračunu spremenljivka $p$ v vrednosti $V$ ni več dobro definiran. Da zagotovimo, da vrednost $V$ ne vsebuje spremenljivke $p$, omejimo tipe, ki pripadajo operacijam, na osnovne tipe. Vrednosti, ki imajo osnovni tip, namreč ne morejo vsebovati spremenljivke obljuba. To je močna omejitev, funkcijski tip na primer namreč ni osnovni. To omejitev bomo v poglavju~\ref{sec:razsirjen-lae} spremenili.
Prekinitev ima tip, ki ga dobimo tako, da na tipu nadaljevanja uporabimo preslikavo $\opincomp{op}$. Prav tako preverimo, da ima tovor tip, ki pripada operaciji $\op$. 
Prestreznik ima isti tip kot njegovo nadaljevanje. Preverimo tudi, da je $\op$ ena izmed operacij, ki jo lahko prestrežemo in da ima sproženi izračun tip obljuba z učinki $\i(\op) = (\o', \i')$.
Blokada ima isti tip kot njegovo nadaljevanje. Preverimo tudi da ima vrednost $V$ tip obljuba. 
Preostali izračuni imajo pričakovane tipe.


\begin{figure}[H]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyComp-Return}{
			\Gamma \types V : A
		}{
			\Gamma \types \tmreturn{V} : \tycomp{A}{\o,\i} 
		}
		\qquad
		\coopinfer{TyComp-Let}{
			\Gamma \types M : \tycomp{A}{\o,\i}
			\\
			\Gamma, x \of A \types N : \tycomp{B}{\o,\i} 
		}{												
			\Gamma \types
			\tmlet{x}{M}{N} : \tycomp{B}{\o,\i}       
		}											
		\\
		\coopinfer{TyComp-MatchEmpty}{
			\Gamma \types V : \tyempty
		}{
			\Gamma \types \tmmatch[\tycomp{C}{(\o,\i)}]{V}{} : \tycomp{C}{\o,\i}
		}
		\quad
		\coopinfer{TyComp-MatchPair}{
			\Gamma \types V : \typrod{A}{B} \\
			\Gamma, x \of A, y \of B \types M : \tycomp{C}{\o,\i}
		}{
			\Gamma \types \tmmatch{V}{\tmpair{x}{y} \mapsto M} : \tycomp{C}{\o,\i}
		}
		\\
		\coopinfer{TyComp-MatchSum}{
			\Gamma \types V : A + B \\\\
			\Gamma, x \of A \types M : \tycomp{C}{\o,\i} \\
			\Gamma, y \of B \types N : \tycomp{C}{\o,\i} \\
		}{
			\Gamma \types \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} : \tycomp{C}{\o,\i}
		}
		\\
		\coopinfer{TyComp-Apply}{
			\Gamma \types V : \tyfun{A}{\tycomp{B}{\o,\i}} \\
			\Gamma \types W : A
		}{
			\Gamma \types \tmapp{V}{W} : \tycomp{B}{\o,\i}
		}
		\\
		\coopinfer{TyComp-Signal}{
			\op \in \o \\
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{A}{\o,\i} 
		}{
			\Gamma \types \tmopout{op}{V}{M} : \tycomp{A}{\o,\i}
		}
		\qquad
		\coopinfer{TyComp-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{A}{\o,\i} 
		}{
			\Gamma \types \tmopin{op}{V}{M} : \tycomp{A}{\opincomp {op} (\o,\i)}
		}
		\\
		\coopinfer{TyComp-Promise}{
			\i\, (\op) = ({\o'} , {\i'}) \\
			\Gamma, x \of A_\op \types M : \tycomp{\typromise A}{\o',\i'} \\
			\Gamma, p \of \typromise A \types N : \tycomp{B}{\o,\i} 
		}{
			\Gamma \types \tmwith{op}{x}{M}{p}{N} : \tycomp{B}{\o,\i}
		}
		\\
		\coopinfer{TyComp-Await}{
			\Gamma \types V : \typromise A \\
			\Gamma, x \of A \types M : \tycomp{B}{\o,\i} 
		}{
			\Gamma \types \tmawait{V}{x}{M} : \tycomp{B}{\o,\i}
		}
		\qquad
		\coopinfer{TyComp-Subsume}{
			\Gamma \types M : \tycomp{A}{\o, \i} \\
			(\o,\i) \order {O \times I} (\o',\i')
		}{
			\Gamma \types M : \tycomp{A}{\o', \i'}
		}
	\end{mathpar}
	\caption{Pravila za določitev tipov za izračune.}
	\label{fig:computation-typing-rules}
\end{figure}

Pravila za določitev tipa procesov vidimo na sliki~\ref{fig:process-typing-rules}.
Tip procesa zagon je odvisen od tipa pripadajočega izračuna in posledično vsebuje tipe učinkov. 
Signal procesa ima isti tip, kot njegovo nadaljevanje. 
Operacija $\mathsf{signals\text{-}of}{(\tyC)}$ preprosto združi vse tipe signalov iz $\tyC$.
$$\mathsf{signals\text{-}of}{(\tycomp{A}{\o, \i})} \defeq \o \qquad
\mathsf{signals\text{-}of}{\typar{\tyC}{\tyD}} \defeq \mathsf{signals\text{-}of}{(\tyC)} \cup \mathsf{signals\text{-}of}{(\tyD)}$$
Podobno, kot se spremeni tip prekinitve izračuna, se spremeni tip prekinitve procesa. Operacijo $\opincomp{op}{}$ ustrezno razširimo.
\begin{figure}[H]
	\centering
	\small
	\begin{align*}
		\opincomp{op}{\tyrun{A}{\o, \i}} \defeq \tyrun{A}{\opincomp{op}{(\o, \i)}} & & 
		\opincomp{op}{\typar{\tyC}{\tyD}} \defeq \typar{\opincomp{op}{\tyC}}{\opincomp{op}{\tyD}}
	\end{align*}
	\vspace{-5ex}
	\caption{Razširitev operacije na procese.}
	\label{fig:opin-proces}
\end{figure}
Tip vzporednih procesov ohrani oba tipa.


\begin{figure}[H]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyProc-Run}{
			\Gamma \types M : \tycomp{A}{\o,\i}
		}{
			\Gamma \types \tmrun{M} : \tyrun{A}{\o, \i}
		}
		\quad
		\coopinfer{TyProc-Par}{
			\Gamma \types P : \tyC \\
			\Gamma \types Q : \tyD
		}{
			\Gamma \types \tmpar{P}{Q} : \typar{\tyC}{\tyD}
		}
		\\
		\coopinfer{TyProc-Signal}{
			\op \in \mathsf{signals\text{-}of}{(\tyC)} \\\\
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopout{op}{V}{P} : \tyC
		}
		\quad
		\coopinfer{TyProc-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopin{op}{V}{P} : \opincomp{op}{\tyC}
		}  
	\end{mathpar}
	\caption{Pravila za določitev tipov za procese.}
	\label{fig:process-typing-rules}
\end{figure}

\subsection{Izrek o varnosti}

Izrek o varnosti razdelimo na izrek o napredku in izrek o ohranitvi.
Izrek o napredku nam pove da, če ima izračun tip, lahko naredimo korak ali pa je že v končni obliki.
Izrek o ohranitvi nam pove da, če izračun, ki ima tip, naredi korak v nek drug izračun, bo pri tem ohranil tip.

Kdaj točno je končan program v zadovoljivi obliki, nam povejo pravila na sliki~\ref{fig:results-rules}.
Kadar se program ustavi si želimo, da bi se ustavil v neki dokončni obliki s katero bomo zadovoljni. 
Za procese si želimo, da so se vsi dosegljivi signali razširili do vrha. Preostanek so pari procesov ali zagoni. Izračun v zagonu mora biti ali vračanje vrednosti ali pa izračun, ki ne more narediti nobenega koraka več, dokler ne prispe ustrezna prekinitev, se izpolni obljuba in blokada dovoli nadaljnje izvajanje. Čakati na obljubo, ki ne pripada nobenemu prestrezniku in se torej nikoli ne more izpolniti, nima smisla. Ko preverjamo delni rezultat izračunov, si v $\Psi$ beležimo obljube, ki pripadajo prestreznikom. Ko pridemo do blokade preverimo, da smo na pripadajočo obljubo nekje prej že naleteli.
Ker bomo za izračune posebej dokazali trditev o napredku, dodamo tudi, da je izračun kot samostojna enota v zaključeni obliki, ko so vsi dosegljivi signali priplavali do vrha, preostanek pa je ali vračanje vrednosti ali izračun, ki čaka na prekinitev.


\begin{figure}[H]
	\centering

	\textbf{Rezultati izračunov}
	\begin{mathpar}
		\coopinfer{R-Signal}{
			\RunResult {\Psi} {M}
		}{
			\CompResult {\Psi} {\tmopout{op}{V}{M}}
		}
		\qquad
		\coopinfer{R-Comp}{
			\RunResult {\Psi} {M}
		}{
			\CompResult {\Psi} {M}
		}
	\end{mathpar}

	\textbf{Delni rezultati izračunov}
	\begin{mathpar}
		\coopinfer{R-Return}{
		}{
			\RunResult {\Psi} {\tmreturn V}
		}
		\qquad
		\coopinfer{R-Promise}{
			\RunResult {\Psi \cup \{p\}} {N}
		}{
			\RunResult {\Psi} {\tmwith {op} x M p N}
		}
		\\
		\coopinfer{R-Await}{
			p \in \Psi
		}{
			\RunResult {\Psi} {\tmawait{p}{x}{M}}
		}
	\end{mathpar}

	\textbf{Rezultati procesov}
	\begin{mathpar}
		\coopinfer{R-Out}{
			\ProcResult {P}
		}{
			\ProcResult {\tmopout {op} V P}
		}
		\qquad
		\coopinfer{R-Process}{
			\ParResult {P}
		}{
			\ProcResult {P}
		}
	\end{mathpar}

	\textbf{Delni rezultati procesov}
	\begin{mathpar}
		\coopinfer{R-Parallel}{
			\ParResult P \\
			\ParResult Q
		}{
			\ParResult {\tmpar P Q}
		}
		\qquad
		\coopinfer{R-Run}{
			\RunResult {\emptyset} {M}
		}{
			\ParResult {\tmrun M}
		}
	\end{mathpar}
	\caption{Rezultati in delni rezultati.}
	\label{fig:results-rules}
\end{figure}


Sledi nekaj lem potrebnih za dokaz teh dveh izrekov, ki so dokazane s strukturno indukcijo. Kadar je v dokazu zanimiv le posamezen primer, je ta posebej označen z $\sitem$.


\begin{lema}\label{lem:ni-spremenljivka}
	Če za vrednost $V$ velja $x_1 \of \typromise{A_1}, x_2 \of \typromise{A_2}, ..., x_n \of \typromise{A_n} \types V \of A$, kjer je $A$ tip, ki se ne pojavi v kontekstu, potem vrednost $V$ ni spremenljivka.
	\begin{itemize}
		\item Če je $A$ enak $B_1 \times B_2$, potem je $V$ enak $(W_1,W_2)$.
		\item Če je $A$ enak $B_1 + B_2$, potem je $V$ ali enak $\tminl{W_1}$ ali $\tminr{W_2}$.
		\item Če je $A$ enak $\tyfun{B_1}{\tycomp{B_2}{\o, \i}}$, potem je $V$ ali enak $\tmfunano{x}{M}$ ali $\tmfunrecano{f}{x}{M}$.
		\item Če je $A$ enak $\typromise{B}$, potem je $V$ enak $\tmpromise{W}$.
	\end{itemize}
\end{lema}

\begin{proof}
	Predpostavimo, da je $V$ spremenljivka. Edino pravilo za določitev tipa spremenljivke je \rulename{TyVal-Var}.
	Od tod sledi, da je tip $A$ v kontekstu $\Gamma$. Kar je v protislovju z predpostavko leme, da se tip $A$ ne pojavi v kontekstu $\Gamma$.
	\begin{itemize}
		\item Edini pravili za tip $B_1 \times B_2$ sta \rulename{TyVal-Var} in \rulename{TyVal-Pair}.
		Ker $V$ ni spremenljivka, je bilo uporabljeno pravilo \rulename{TyVal-Pair}.
		Posledično je $V$ oblike $\tmpair{W_1}{W_2}$.
		
		\item Edina pravila za tip $B_1 + B_2$ so \rulename{TyVal-Var}, \rulename{TyVal-Inl} in \rulename{TyVal-Inr}.
		Ker $V$ ni spremenljivka, je bilo uporabljeno pravilo \rulename{TyVal-Inl} ali \rulename{TyVal-Inr}.
		Posledično je $V$ oblike $\tminl{W_1}$ ali $\tminr{W_2}$.
		
		\item Edina pravila za tip $\tyfun{B_1}{\tycomp{B_2}{\o, \i}}$ so \rulename{TyVal-Var}, \rulename{TyVal-Fun} in \rulename{TyVal-Fun-Rec}.
		Ker $V$ ni spremenljivka, je bilo uporabljeno pravilo \rulename{TyVal-Fun} ali \rulename{TyVal-Fun-Rec}.
		Posledično je $V$ oblike $\tmfunano{x}{M}$ ali $\tmfunrecano{f}{x}{M}$.
		
		\item Edini pravili za tip $\typromise{B}$ sta \rulename{TyVal-Var} in \rulename{TyVal-Promise}.
		Ker $V$ ni spremenljivka, je bilo uporabljeno pravilo \rulename{TyVal-Promise}.
		Posledično je $V$ oblike $\tmpromise{W}$.
	\end{itemize}
\end{proof}

Najprej dokažemo trditev o napredku samo za izračune. Da bomo lahko uporabili indukcijsko predpostavko na nadaljevanju prestreznika, v kontekstu dovolimo spremenljivke tipa obljuba.

\begin{trditev}[o napredku]\label{trd:gamma-napredek}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$, kjer je $\Gamma = x_1 \of \typromise{A_1}, x_2 \of \typromise{A_2},..., x_i \of \typromise{A_i}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\CompResult{\Gamma}{M}$.
\end{trditev}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave za $\Gamma \types M \of \tycomp{A}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Return},je $M$ enak $$\tmreturn{V}.$$
		Po pravilih \rulename{R-Return} in \rulename{R-Comp} sledi, da je $M$ rezultat.
		
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $$\tmlet{x}{N_1}{N_2}.$$
		Izračun $N_1$ ima tip in po indukcijski predpostavki lahko naredi korak ali pa je rezultat. Če $N_1$ lahko naredi korak v $N_1'$, potem lahko po pravilu za evalvacijo v okolju tudi $M$ naredi korak v $\tmlet{x}{N_1'}{N_2}$.
		Če pa je $N_1$ rezultat, ločimo dve možnosti glede na zadnje pravilo. 
		\begin{itemize}
			\item Če je zadnje pravilo \rulename{R-Signal}, potem je $N_1$ enak $\tmopout{op}{V}{N_3}$ in lahko $M$ naredi korak v $\tmopout{op}{V}{(\tmlet{x}{N_3}{N_2})}$.
			\item če je zadnje pravilo \rulename{R-Comp}, potem ločimo tri primere.
			\begin{itemize}
				\item Če je $N_1$ enak $\tmreturn{V}$, potem lahko $M$ naredi korak v izračun $N_2[V/x]$.
				\item Če je $N_1$ enak $\tmwith{op}{x}{N_3}{p}{N_4}$, potem lahko $M$ naredi korak v $\tmwith{op}{x}{N_3}{p}{(\tmlet{x}{N_4}{N_2})}$.
				\item Če je $N_1$ enak $\tmawait{p}{y}{N_3}$, potem lahko $M$ naredi korak v $\tmawait{p}{y}{(\tmlet{x}{N_3}{N_2})}$.
			\end{itemize}
			
		\end{itemize}
	
		\item Če je uporabljeno pravilo \rulename{TyComp-Apply}, potem je $M$ enak $$V W.$$
		Ker ima vrednost $V$ tip $\tyfun{B_1}{B_2}$ in v kontekstu nobena spremenljivka nima tipa $\tyfun{B_1}{B_2}$, je po lemi~\ref{lem:ni-spremenljivka} vrednost $V$ oblike $\tmfunano{x}{M}$ ali $\tmfunrecano{f}{x}{M}$.
		Lahko naredimo korak v $M[W/x]$ ali $M[V/x, (\tmfunrec{f}{x \of A}{M})/f]$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchPair}, potem je $M$ enak $$\tmmatch{V}{(x,y) \mapsto N}.$$
		Ker ima vrednost $V$ tip $A \times B$ in v kontekstu nobena spremenljivka nima tipa $A \times B$, je po lemi~\ref{lem:ni-spremenljivka} vrednost $V$ oblike $(W_1,W_2)$.
		Posledično lahko $M$ naredi korak v izračun $N[W_1/x,W_2/y]$.
		
		\item Zadnje pravilo ne more biti \rulename{TyComp-MatchEmpty}.
		Če bi bilo zadnje pravilo \rulename{TyComp-MatchEmpty}, bi vrednost $V$ imela tip $0$. 
		Ker v kontekstu nobena spremenljivka nima tipa $0$, $V$ ne more biti spremenljivka po lemi~\ref{lem:ni-spremenljivka}.
		Ker ne obstaja nobeno drugo pravilo za tip $0$, take vrednosti ne moremo imeti, in posledično zadnje uporabljeno pravilo ne more biti \rulename{TyComp-MatchEmpty}.

		
		\item Če je zadnje pravilo \rulename{TyComp-MatchSum}, potem je $M$ enak $$\tmmatch{V}{\tminl{x} \mapsto N_1, \tminr{y} \mapsto N_2}.$$
		Ker ima vrednost $V$ tip $A + B$ in v kontekstu nobena spremenljivka nima tipa $A + B$, je po lemi~\ref{lem:ni-spremenljivka} vrednost $V$ oblike $\tminl{W_1}$ ali $\tminr{W_2}$.
		\begin{itemize}
			\item Če je oblike $\tminl{W_1}$ lahko $M$ naredi korak v $N_1[W_1/x]$.
			\item Sicer je oblike $\tminr{W_2}$ in lahko $M$ naredi korak v $N_2[W_2/y]$.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyComp-Signal}, potem je $M$ enak $$\tmopout{op}{V}{N}.$$
		Po indukcijski predpostavki lahko ali $N$ naredi korak v $N'$ in posledično lahko $M$ naredi korak v $\tmopout{op}{V}{N'}$.
		Ali pa je $N$ rezultat in je posledično po pravilu \rulename{R-Signal} tudi $M$ rezultat.
		
		\item Če je zadnje pravilo \rulename{TyComp-Interrupt}, potem je $M$ enak $\tmopin{op}{V}{N}$.
		Izračun $N$ ima tip in po indukcijski predpostavki lahko naredi korak ali pa je rezultat.
		Če $N$ lahko naredi korak v $N'$, potem po pravilu za evalvacijo v okolju tudi $M$ lahko naredi korak v $\tmopin{op}{V}{N'}$. 
		Če pa je $N$ rezultat ločimo dve možnosti glede na zadnje pravilo.
		\begin{itemize}
			\item Če je zadnje pravilo \rulename{R-Signal}, potem je $N$ enak $\tmopout{op}{V}{N''}$ in lahko $M$ naredi korak v $\tmopout{op'}{W}{(\tmopin{op}{V}{N''})}$.
			\item če je zadnje pravilo \rulename{R-Comp}, potem ločimo tri primere.
			\begin{itemize}
				\item Če je $N$ enak $\tmreturn{V}$, potem lahko $M$ naredi korak v $\tmreturn{V}$.
				\item Če je $N$ enak $\tmwith{op'}{x}{N_1}{p}{N_2}$, potem lahko $M$ naredi ali korak v $\tmlet{p}{N_1[V/x]}{\tmopin{op}{V}{N_2}}$, če velja $op = op'$, ali v $\tmwith{op'}{x}{N_1}{p}{\tmopin{op}{V}{N_2}}$ sicer.
				\item Če je $N$ enak $\tmawait{p}{y}{N''}$, potem lahko $M$ naredi korak v $\tmawait{p}{x}{(\tmopin{op}{V}{N''})}$.
			\end{itemize}
		\end{itemize}
		
		
		\item Če je zadnje pravilo \rulename{TyComp-Promise}, potem je $M$ enak $$\tmwith{op}{x}{N_1}{p}{N_2}.$$
		Izračun $N_2$ ima tip in po indukcijski predpostavki lahko $N_2$ naredi korak ali pa je že delna vrednost.
		Če $N_2$ lahko naredi korak v $N_2'$, potem po pravilu za evalvacijo v okolju tudi $M$ lahko naredi korak v $\tmwith{op}{x}{N_1}{p}{N_2'}$.
		Če pa je $N_2$ rezultat, ločimo dva primera.
		\begin{itemize}
			\item Če je zadnje pravilo za določitev rezultata $N_2$ pravilo \rulename{R-Comp}, potem je tudi $M$ rezultat po pravilih \rulename{R-Comp} in \rulename{R-Promise}.
			\item Če je zadnje pravilo za določitev rezultata $N_2$ pravilo \rulename{R-Signal}, potem je $N_2$ oblike $\tmopout{op'}{V}{N_3}$ in posledično lahko $M$ naredi korak v $\tmopout{op}{V}{\tmwith{op}{x}{N_1}{p}{N_3}}$.
		\end{itemize}
		 
		
		\item Če je zadnje pravilo \rulename{TyComp-Await}, potem je $M$ oblike $$\tmawait{V}{p}{N}.$$
		Ločimo dva primera.
		\begin{itemize}
			\item Če je $V$ spremenljivka v kontekstu $\Gamma$, potem je po pravilih \rulename{R-Comp} in \rulename{R-Await} izračun $M$ rezultat.
			\item Sicer je $V$ enak $\tmpromise{W}$. Tedaj lahko $M$ naredi korak v $N[W/p]$.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyComp-Subsume}, lahko po indukcijski predpostavki uporabimo direktno na $M$ in posledično lahko $M$ naredi korak ali pa je $M$ rezultat.
			
	\end{itemize}
	
\end{proof}


\begin{posledica}[o napredku]\label{pos:prazen-napredek}
	Naj za izračun $M$ velja $\emptyset \types M \of \tycomp{A}{\o, \i}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\RunResult{\emptyset}{M}$.
\end{posledica}

\begin{proof}
	Trditev \ref{trd:gamma-napredek} velja za vsak kontekst $\Gamma$, torej tudi za $\Gamma = \emptyset$.
\end{proof}


\begin{izrek}[o napredku]\label{izr:napredek}
	Naj za proces $P$ velja $\emptyset \types P \of C$. Potem ali (i) obstaja proces $P'$, tak da $P \reduces P'$, ali pa (ii) velja $\ProcResult{P}$.
\end{izrek}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave za $\emptyset \types P \of C$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyProc-Run}, potem je $P$ enak $\tmrun{M}$.
		Ker ima $M$ tip, po posledici~\ref{pos:prazen-napredek} velja da, ali lahko $M$ naredi korak v $M'$ ali pa je $M$ rezultat.
		\begin{itemize}
			\item Če $M$ lahko naredi korak v $M'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmrun{M'}$.
			\item Sicer je $M$ rezultat in ločimo dve možnosti glede na zadnje pravilo.
			\begin{itemize}
				\item Če je zadnje pravilo \rulename{R-Signal} potem je $M$ enak $\tmopout{op}{V}{N}$ in lahko $P$ naredi korak v $\tmopout{op}{V}{\tmrun{N}}$.
				\item Če je zadnje pravilo \rulename{R-Comp} je $M$ tudi delni rezultat in je $P$ rezultat po pravilu \rulename{R-Run}.
			\end{itemize}
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyProc-Par}, potem je $P$ enak $\tmpar{Q_1}{Q_2}$. Ker imata $Q_1$ in $Q_2$ tip, lahko po indukcijski predpostavki naredita korak ali pa sta že rezultata.
		Če lahko eden izmed njiju naredi korak, recimo $Q_1$ lahko naredi korak v $Q_1'$, lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmpar{Q_1'}{Q_2}$. Podobno dokažemo, če lahko $Q_2$ naredi korak.
		Sicer sta $Q_1$ in $Q_2$ rezultata. Ločimo dve možnosti.
		\begin{itemize}
			\item Če je zadnje pravilo \rulename{R-Out} za enega izmed $Q_1$ in $Q_2$, potem je eden izmed njiju enak $\tmopout{op}{V}{Q'}$, recimo $Q_1$. Tedaj lahko $P$ naredi korak v $\tmopout{op}{V}{(\tmpair{Q'}{\tmopin{op}{V}{Q_2}})}$. Podobno za $Q_2$.
			\item Sicer je $P$ rezultat po pravilu \rulename{R-Parallel}.
		\end{itemize}
		
		\item Če je zadnje pravilo \rulename{TyProc-Signal}, potem je $P$ enak $\tmopout{op}{V}{Q}$. Proces $Q$ ima tip in po indukcijski predpostavki lahko naredi korak ali pa je rezultat.
		Če $Q$ lahko naredi korak v $Q'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmopout{op}{V}{Q'}$.
		Sicer je tudi $P$ rezultat po pravilu \rulename{R-Out}.
		
		\item Če je zadnje pravilo \rulename{TyProc-Interrupt}, potem je $P$ enak $\tmopin{op}{V}{Q}$. Proces $Q$ ima tip in po indukcijski predpostavki lahko naredi korak ali pa je rezultat.
		\begin{itemize}
			\item Če $Q$ lahko naredi korak v $Q'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmopin{op}{V}{Q'}$.
			\item Če je $Q$ rezultat ločimo dva primera.
			\begin{itemize}
				
				\item Če je zadnje pravilo \rulename{R-Out}, potem je $Q$ enak $\tmopout{op'}{V'}{Q'}$ in lahko $P$ naredi korak v $\tmopout{op'}{V'}{(\tmopin{op}{V}{Q'})}$.
				
				\item Če je zadnje pravilo \rulename{R-Process} ločimo dva primera.
				\begin{itemize}
					\item Če je zadnje pravilo \rulename{R-Parallel}, potem je $Q$ enak $\tmpar{Q_1}{Q_2}$ in lahko $P$ naredi korak v $\tmpar{\tmopin{op}{V}{Q_1}}{\tmopin{op}{V}{Q_2}}$.
					\item Če je zadnje pravilo \rulename{R-Run}, potem je $Q$ enak $\tmrun{M}$ in lahko $P$ naredi korak v $\tmrun{\tmopin{op}{V}{M}}$.
				\end{itemize}
				
			\end{itemize}
		
		\end{itemize}
		
	\end{itemize}
		
\end{proof}


\begin{lema}\label{lem:strengthening-gamma}
	Naj za spremenljivko $y$ velja $\Gamma_1, x \of A, \Gamma_2 \types y \of B$ za $y \neq x$. Potem velja $\Gamma_1, \Gamma_2 \types y \of B$.
\end{lema}

\begin{proof}
	Edino pravilo za določitev tipa spremenljivke je \rulename{TyVal-Var}. Posledično velja $y \of B \in \Gamma_1$ ali $y \of B \in \Gamma_2$. V obeh primerih po pravilu \rulename{TyVal-Var} sledi $\Gamma_1, \Gamma_2 \types y \of B$.
\end{proof}

Sledeči lemi o šibitvi konteksta za vrednosti in izračune se nanašata ena na drugo. Povesta nam da, če kontekst primerno razširimo, se tip ne spremeni.

\begin{lema}\label{lem:weakening-values}
	Naj za vrednost $V$ velja $\Gamma_1, \Gamma_2 \types V \of A$. Za vsak kontekst $\Gamma_3$, ki vsebuje le sveže spremenljivke glede na $\Gamma_1$ in $\Gamma_2$, velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
\end{lema}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave za $\Gamma_1, \Gamma_2 \types V \of A$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item[\sitem] Če je zadnje pravilo \rulename{TyVal-Var}, potem je $V = x$ in velja $x \in \Gamma_1$ ali $x \in \Gamma_2$. Po pravilu \rulename{TyVal-Var} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Cons}, potem je $V = n$. Po pravilu \rulename{TyVal-Cons} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		%		\item Če je zadnje pravilo \rulename{Ty-Cons-T}, potem je $V = true$. Po pravilu \rulename{Ty-Cons-T} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		%		\item Če je zadnje pravilo \rulename{Ty-Cons-F}, potem je $V = false$. Po pravilu \rulename{Ty-Cons-F} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Unit}, potem je $V = ()$. Po pravilu \rulename{TyVal-Unit} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Pair}, potem je $V =\tmpair{V_1}{V_2}$. Po indukcijski predpostavki imata $V_1$ in $V_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Pair} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inl}, potem je $V = \tminl{V_1}$. Po indukcijski predpostavki ima $V_1$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Inl} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inr}, potem je $V = \tminl{V_2}$. Po indukcijski predpostavki ima $V_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Inr} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun}, potem je $V = \tmfunano{x}{M}$. Po lemi~\ref{lem:weakening-comp} ima $M$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Fun} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun-Rec}, potem je $V = \tmfunrecano{f}{x}{M}$. Po lemi~\ref{lem:weakening-comp} ima $M$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Fun-Rec} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Promise}, potem je $V = \tmpromise{V'}$. Po indukcijski predpostavki ima $V'$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyVal-Promise} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types V \of A$.
	\end{itemize}
\end{proof}

\begin{lema}\label{lem:weakening-comp}
	Naj za izračun $M$ velja $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$. Za vsak kontekst $\Gamma_3$, ki vsebuje le sveže spremenljivke glede na $\Gamma_1$ in $\Gamma_2$, velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$
\end{lema}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave za $\Gamma_1, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Return}, potem je $M$ enak $$\tmreturn{V}.$$
		Po lemi~\ref{lem:weakening-values} ima $V$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Return} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $$\tmlet{x}{N_1}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Let} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchEmpty}, potem je $M$ enak $$\tmmatch{V}{}.$$
		Po lemi~\ref{lem:weakening-values} ima $V$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-MatchEmpty} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchPair}, potem je $M$ enak $$\tmmatch{V}{(x_1,x_2) \mapsto N}.$$ 
		Po lemi~\ref{lem:weakening-values} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-MatchPair} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchSum}, potem je $M$ enak $$\tmmatch{V}{\tminl{x_1} \mapsto N_1, \tminr{x_2} \mapsto N_2}.$$
		Po lemi~\ref{lem:weakening-values} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-MatchSum} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Apply}, potem je $M$ enak $$V_1 V_2.$$
		Po lemi~\ref{lem:weakening-values} imata $V_1$ in $V_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Apply} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Signal}, potem je $M$ enak $$\tmopout{op}{V}{N}.$$
		Po lemi~\ref{lem:weakening-values} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Signal} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Interrupt}, potem je $M$ enak $$\tmopin{op}{V}{N}.$$
		Po lemi~\ref{lem:weakening-values} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Interrupt} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Promise}, potem je $M$ enak $$\tmwith{op}{x}{N_1}{p}{N_2}.$$
		Po indukcijski predpostavki imata $N_1$ in $N_2$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Promise} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Await}, potem je $M$ enak $$\tmawait{V}{y}{N}.$$
		Po lemi~\ref{lem:weakening-values} ima $V$ isti tip v razširjenem kontekstu.
		Po indukcijski predpostavki ima $N$ isti tip v razširjenem kontekstu.
		Po pravilu \rulename{TyComp-Await} velja $\Gamma_1, \Gamma_3, \Gamma_2 \types M \of \tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Subsume}, ima po indukcijski predpostavki $M$ isti tip v razširjenem kontekstu.
		
	\end{itemize}
\end{proof}

Lemo o substituciji razdelimo na dve lemi, ki uporabljata druga drugo.

\begin{lema}[o substituciji za vrednosti]\label{lem:substitucija-vrednosti}
	Naj za vrednost $V$ velja $\Gamma_1 \types V \of A$ in za vrednost $W$ velja $\Gamma_1, x \of A, \Gamma_2 \types W \of B$. Potem velja $\Gamma_1, \Gamma_2 \types W[V/x] \of B$.
\end{lema}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave za $\Gamma_1, x \of A, \Gamma_2 \types W \of B$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item[\sitem] 
		Če je zadnje pravilo \rulename{TyVal-Var}, potem je $W$ enak $y$. Ločimo dva primera.
		\begin{itemize}
			\item Če je spremenljivka $y = x$, potem je $W[V/x] = y[V/x] = V$. Ker je $y = x$, je $A = B$. Ker je $A = B$, je tip $W[V/x] = V$ enak $B$ tudi v razširjenem kontekstu po lemi~\ref{lem:weakening-values}.
			\item Če je spremenljivka $y \neq x$, potem je $W[V/x] = y$. Po lemi~\ref{lem:strengthening-gamma} ima $y$ tip $B$.
		\end{itemize}
		
	
		\item Če je zadnje pravilo \rulename{TyVal-Cons}, potem je $W=n$ in $B=int$. Ker je $W[V/x] = n[V/x] = n$, ima $W[V/x]$ tip $int = B$, po pravilu \rulename{TyVal-Cons}.
		
		\item Če je zadnje pravilo \rulename{TyVal-Unit}, potem je $W=()$ in $B=\text{unit}$. Ker je $W[V/x] = ()[V/x] = ()$, ima $W[V/x]$ tip $B$, po pravilu \rulename{TyVal-Unit}.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-T}, potem je $W=true$ in $B=bool$. Ker je $W[V/x] = true[V/x] = true$, ima $W[V/x]$ tip $bool = B$, po pravilu \rulename{Ty-Cons-T}. 
%		\item Če je zadnje pravilo \rulename{Ty-Cons-F}, potem je $W$ enak $false$ in $B$ enak $bool$. Ker je $W[V/x] = false[V/x] = false$, ima $W[V/x]$ tip $bool = B$, po pravilu \rulename{Ty-Cons-F}.
		
		\item Če je zadnje pravilo \rulename{TyVal-Pair}, potem je $W =\tmpair{W_1}{W_2}$ in $B = B_1 \times B_2$. Po indukcijski predpostavki imata $W_1[V/x]$ in $W_2[V/x]$ tip $B_1$ in $B_2$.
		Ker je $W[V/x] = \tmpair{W_1[V/x]}{W_2[V/x]}$, ima vrednost $W[V/x]$ tip $\typrod{B_1}{B_2} = B$ po pravilu \rulename{TyVal-Pair}.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inl}, potem je $W = \tminl{W_1}$ in $B = B_1 + B_2$. Po indukcijski predpostavki ima $W_1[V/x]$ tip $B_1$.
		Ker je $W[V/x] = \tminl{W_1[V/x]}$, ima vrednost $W[V/x]$ tip $B_1 + B_2 = B$ po pravilu \rulename{Ty-Sum}.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inr}, potem je $W = \tminr{W_2}$ in $B = B_1 + B_2$. Po indukcijski predpostavki ima $W_2[V/x]$ tip $B_2$.
		Ker je $W[V/x] = \tminr{W_2[V/x]}$, ima vrednost $W[V/x]$ tip $B_1 + B_2 = B$ po pravilu \rulename{Ty-Sum}.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun}, potem je $W = \tmfunano{y}{M}$ in $B = \tyfun{B_1}{B_2}$. Po lemi~\ref{lem:substitucija-izračuni} ima $M[V/x]$ tip $B_2$.
		Ker je $W[V/x] = \tmfunano{y}{M[V/x]}$, ima vrednost $W[V/x]$ tip $\tyfun{B_1}{B_2}$ po pravilu \rulename{TyVal-Fun}.
		
		\item Če je zadnje pravilo \rulename{TyVal-Fun-Rec}, potem je $W = \tmfunrecano{f}{y}{M}$ in $B = \tyfun{B_1}{B_2}$. Po lemi~\ref{lem:substitucija-izračuni} ima $M[V/x]$ tip $B_2$.
		Ker je $W[V/x] = \tmfunrecano{f}{y}{M[V/x]}$, ima vrednost $W[V/x]$ tip $\tyfun{B_1}{B_2}$ po pravilu \rulename{TyVal-Fun-Rec}.
		
		\item Če je zadnje pravilo \rulename{TyVal-Promise}, potem je $W = \tmpromise{W'}$ in $B = \typromise{B'}$. Po indukcijski predpostavki ima $W'[V/x]$ tip $B'$.
		Ker je $W[V/x] = \tmpromise{W'}$, ima vrednost $W[V/x]$ tip $\typromise{B'} = B$ po pravilu \rulename{TyVal-Promise}.
	\end{itemize}
\end{proof}


\begin{lema}[o substituciji za izračune]\label{lem:substitucija-izračuni}
	Naj za vrednost $V$ velja $\Gamma_1 \types V \of A$ in za izračun $M$ velja $\Gamma_1, x \of A, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$. Potem velja $\Gamma_1, \Gamma_2 \types M[V/x] \of \tycomp{B}{\o, \i}$.
\end{lema}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave za $\Gamma_1, x \of A, \Gamma_2 \types M \of \tycomp{B}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Return}, potem je $M$ enak $$\tmreturn{W}.$$
		Vrednost $W$ ima tip $B$.
		Po lemi~\ref{lem:substitucija-vrednosti} ima $W[V/x]$ tip $B$.
		Po pravilu \rulename{TyComp-Return} ima $M'$ tip $\tycomp{B}{\o, \i}$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Let}, potem je $M$ enak $$\tmlet{x}{N_1}{N_2}.$$
		Izračuna $N_1$ in $N_2$ imata tip $\tycomp{C}{\o, \i}$ in $\tycomp{B}{\o, \i}$.
		Po indukcijski predpostavki velja, da imata $N_1[V/x]$ in $N_2[V/x]$ isti tip.
		Ker je $M[V/x]$ enak $\tmlet{x}{N_1[V/x]}{N_2[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Let}.
		
		\item Zadnje pravilo ne more biti \rulename{TyComp-MatchEmpty}. Če bi bilo, potem bi $M$ bil enak $$\tmmatch{W}{}.$$
		Vrednost $W$ bi morala imeti tip $\tyempty$, ki pa ga ne more imeti. 
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchPair}, potem je $M$ enak $$\tmmatch{W}{(y_1,y_2) \mapsto N}.$$ 
		Ker ima vrednost $W$ tip $C_1 \times C_2$, ima tudi $W[V/x]$ tip $C_1 \times C_2$ po lemi~\ref{lem:substitucija-vrednosti}.
		Ker ima $N$ tip $\tycomp{B}{\o, \i}$, ima tudi $N[V/x]$ tip $\tycomp{B}{\o, \i}$ po indukcijski predpostavki.
		Ker je $M[V/x]$ enak $\tmmatch{W[V/x]}{(y_1,y_2) \mapsto N[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-MatchPair}. 
		
		\item Če je zadnje pravilo \rulename{TyComp-MatchSum}, potem je $M$ enak $$\tmmatch{W}{\tminl{y_1} \mapsto N_1, \tminr{y_2} \mapsto N_2}.$$
		Ker ima vrednost $W$ tip $C_1 + C_2$, ima tudi $W[V/x]$ tip $C_1 + C_2$ po lemi~\ref{lem:substitucija-vrednosti}.
		Ker imata $N_1$ in $N_2$ tip $\tycomp{B}{\o, \i}$, imata tudi $N_1[V/x]$ in $N_2[V/x]$ tip $\tycomp{B}{\o, \i}$ po indukcijski predpostavki.
		Ker je $M[V/x]$ enak $\tmmatch{W[V/x]}{\tminl{y_1} \mapsto N_1[V/x], \tminr{y_2} \mapsto N_2[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-MatchSum}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Apply}, potem je $M$ enak $$W_1 W_2.$$ Vrednost $W_1$ ima tip $\tyfun{C}{\tycomp{B}{\o, \i}}$ in vrednost $W_2$ ima tip $C$.
		Po lemi~\ref{lem:substitucija-vrednosti} imata $W_1[V/x]$ in $W_2[V/x]$ isti tip.
		Ker je $M[V/x]$ enak $W_1[V/x] W_2[V/x]$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Apply}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Signal}, potem je $M$ enak $$\tmopout{op}{W}{N}.$$
		Ker ima vrednost $W$ tip $C_{op}$, ima tudi $W[V/x]$ tip $C_{op}$ po lemi~\ref{lem:substitucija-vrednosti}.
		Ker ima $N$ tip $\tycomp{B}{\o, \i}$, ima tudi $N[V/x]$ tip $\tycomp{B}{\o, \i}$ po indukcijski predpostavki.
		Ker je $M[V/x]$ enak $\tmopout{op}{W[V/x]}{N[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Signal}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Interrupt}, potem je $M$ enak $$\tmopin{op}{W}{N}$$ in $(\o, \i) = \opincomp{op}{\o', \i'}.$
		Ker ima vrednost $W$ tip $C_{op}$, ima tudi $W[V/x]$ tip $C_{op}$ po lemi~\ref{lem:substitucija-vrednosti}.
		Ker ima $N$ tip $\tycomp{B}{\o', \i'}$, ima tudi $N[V/x]$ tip $\tycomp{B}{\o', \i'}$ po indukcijski predpostavki.
		Ker je $M[V/x]$ enak $\tmopin{op}{W[V/x]}{N[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Signal}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Promise}, potem je $M$ enak $$\tmwith{op}{y}{N_1}{p}{N_2}.$$
		Ker ima $N_1$ tip $\tycomp{\typromise{C}}{\o', \i'}$, ima tudi $N_1[V/x]$ tip $\tycomp{\typromise{C}}{\o', \i'}$ po indukcijski predpostavki.
		Ker ima $N_2$ tip $\tycomp{B}{\o, \i}$, ima tudi $N_2[V/x]$ tip $\tycomp{B}{\o, \i}$ po indukcijski predpostavki.
		Ker je $M[V/x]$ enak $\tmwith{op}{y}{N_1}{p}{N_2}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Promise}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Await}, potem je $M$ enak $$\tmawait{W}{y}{N}.$$
		Ker ima vrednost $W$ tip $\typromise{C}$, ima tudi $W[V/x]$ tip $\typromise{C}$ po lemi~\ref{lem:substitucija-vrednosti}.
		Ker ima $N$ tip $\tycomp{B}{\o', \i'}$, ima tudi $N[V/x]$ tip $\tycomp{B}{\o', \i'}$ po indukcijski predpostavki.
		Ker je $M[V/x]$ enak $\tmawait{W[V/x]}{y}{N[V/x]}$, ima izračun $M[V/x]$ tip $\tycomp{B}{\o, \i}$ po pravilu \rulename{TyComp-Await}.
		
		\item Če je zadnje pravilo \rulename{TyComp-Subsume}, potem ima $M$ tip $\tycomp{B}{\o', \i'}$, kjer je $(\o', \i') \order{O \times I} (\o, \i)$.
		Po indukcijski predpostavki ima tudi $M[V/x]$ tip $\tycomp{B}{\o', \i'}$. Po pravilu \rulename{TyComp-Subsume} ima $M[V/x]$ tip $\tycomp{B}{\o, \i}$.
		
	\end{itemize}

\end{proof}

\begin{lema}\label{lem:tovor-osnovni-tip-skrcitev}
	Naj za vrednost $V$ velja $\Gamma_1, x \of \typromise{A}, \Gamma_2 \types V \of B$, kjer je $B$ osnovni tip. Potem velja $\Gamma_1, \Gamma_2 \types V \of B$.
\end{lema}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave za $\Gamma_1, p \of \typromise{A}, \Gamma_2 \types V \of B$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item[\sitem] Če je zadnje pravilo \rulename{TyVal-Var'}, potem je $V = y$. Ker $\typromise{A}$ ni osnoven tip, velja $y \in \Gamma_1$ ali $y \in \Gamma_2$.
		Po pravilu \rulename{TyVal-Var'} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Cons}, potem je $V = n$. Po pravilu \rulename{TyVal-Cons} velja $\Gamma_1, \Gamma_2 \types V \of B$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-T}, potem je $V = true$. Po pravilu \rulename{Ty-Cons-T} velja $\Gamma_1, \Gamma_2 \types V \of B$.
%		\item Če je zadnje pravilo \rulename{Ty-Cons-F}, potem je $V = false$. Po pravilu \rulename{Ty-Cons-F} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Unit}, potem je $V = ()$. Po pravilu \rulename{TyVal-Unit} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Pair}, potem je $V =\tmpair{V_1}{V_2}$.
		Po indukcijski predpostavki imata $V_1$ in $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Pair} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		
		\item Če je zadnje pravilo \rulename{TyVal-Inl}, potem je $V = \tminl{V_1}$.
		Po indukcijski predpostavki ima $V_1$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Inl} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Če je zadnje pravilo \rulename{TyVal-Inr}, potem je $V = \tminl{V_2}$.
		Po indukcijski predpostavki ima $V_2$ isti tip v skrčenem kontekstu.
		Po pravilu \rulename{TyVal-Inr} velja $\Gamma_1, \Gamma_2 \types V \of B$.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Fun}, saj v tem primeru $B$ ni osnovni tip.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Fun-Rec}, saj v tem primeru $B$ ni osnovni tip.
		
		\item Zadnje pravilo ne more biti \rulename{TyVal-Promise}, saj v tem primeru $B$ ni osnovni tip.
		
	\end{itemize}
\end{proof}

Kadar ne dokazujemo na drevo izpeljave za tip izračuna, ne vemo, katero pravilo točno je bilo zadnje uporabljeno. Posledično ne moremo uporabiti uporabiti predpostavk pravila, ki bi nam povedale o tipih komponent, kljub temu, da imamo tip celega izračuna.
S pomočjo leme o inverziji lahko vseeno deloma uporabimo ustrezne predpostavke, čeprav v nekoliko šibkejši obliki.

\begin{lema}\label{lem:inversion-lema}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$. Potem obstaja $(\o', \i') \order{O, I} (\o, \i)$.
	\begin{itemize}
		\item Če je $M$ oblike $\tmlet{x}{N_1}{N_2}$, potem velja $\Gamma \types N_1 \of \tycomp{B}{\o', \i'}$, $\Gamma, x \of B \types N_2 \of \tycomp{A}{\o', \i'}$.
	
		\item Če je $M$ oblike $\tmmatch{V}{\tmpair{x_1}{x_2} \mapsto N}$, potem velja $V = \tmpair{V_1}{V_2}$, $\Gamma \types V_1 \of B_1$, $\Gamma \types V_2 \of B_2$ in $\Gamma, x_1 \of B_1, x_2 \of B_2 \types N \of \tycomp{A}{\o', \i'}$.
		
		\item Če je $M$ oblike $\tmmatch{V}{\tminl{x_1} \mapsto N_1, \tminr{x_2} \mapsto N_2}$, potem velja $\Gamma \types V \of B_1 + B_2$, $\Gamma, x_1 \of B_1 \types N_1 \of \tycomp{A}{\o', \i'}$ in $\Gamma, x_2 \of B_2 \types N_2 \of \tycomp{A}{\o', \i'}$. Če je $V = \tminl[B_2]{V'}$, potem je $\Gamma \types V' \of B_1$. Sicer je $V = \tminr[B_1]{V'}$ in velja $\Gamma \types V' \of B_2$
		
%		\item Če je $M$ oblike $\tmmatch{V}{\tminl{x_1} \mapsto N_1, \tminr{x_2} \mapsto N_2}$, potem velja $\Gamma \types V \of B_1 + B_2$, $\Gamma \types N_1 \of \tycomp{A}{\o', \i'}$ in $\Gamma \types N_2 \of \tycomp{A}{\o', \i'}$.
		
		\item Če je $M$ oblike $\tmapp{V}{W}$, potem velja $\Gamma \types V \of \tyfun{B}{\tycomp{A}{\o', \i'}}$ in $\Gamma \types W \of B$.
		
		\item Če je $M$ oblike $\tmopout{op}{V}{N}$, potem velja $\Gamma \types V \of B$ in $\Gamma \types N \of \tycomp{A}{\o', \i'}$.
		
		\item Če je $M$ oblike $\tmopin{op}{V}{N}$, potem velja $\Gamma \types V \of B$, $\Gamma \types N \of \tycomp{A}{\o'', \i''}$ in $\opincomp{op}{(\o'', \i'')} \order{O, I} (\o, \i)$.
		
		\item Če je $M$ oblike $\tmwith{op}{x}{N_1}{p}{N_2}$, potem velja $\Gamma, x \of B_{op} \types N_1 \of \tycomp{\typromise{B}}{\o'', \i''}$ in $\Gamma, p \of \typromise{B} \types N_2 \of \tycomp{A}{\o', \i'}$ in $(\o'', \i'') = i'(op)$.
		
	\end{itemize}
\end{lema}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave za $\Gamma \types M \of \tycomp{A}{\o, \i}$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo \rulename{TyComp-Let}, \rulename{TyComp-MatchPair}, \rulename{TyComp-MatchSum}, \rulename{TyComp-Apply}, \rulename{TyComp-Signal} ali \rulename{TyComp-Promise}, potem ustrezna točka leme sledi za $(\o', \i') = (\o, \i)$.
		
		\item Če je zadnje pravilo \rulename{TyComp-Interrupt}, potem ustrezna točka leme sledi za $\opincomp{op}{(\o'', \i'')} = (\o, \i)$.
		
		\item Če je zadnje uporabljeno pravilo \rulename{TyComp-Subsume}, potem ima $M$ tudi tip $\tycomp{A}{\o', \i'}$. Po indukcijski predpostavki direktno na $M$ lema sledi, saj je $\order{O, I}$ tranzitiven.
	\end{itemize}
\end{proof}

\begin{trditev}[o ohranitvi]\label{trd:ohranitev-izracuni}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$. Če izračun $M$ naredi korak $M \reduces M'$, potem velja $\Gamma \types M' \of \tycomp{A}{\o, \i}$.
\end{trditev}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave koraka $M \reduces M'$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje pravilo $$\tmapp{(\tmfun{x : B}{N})}{V} \reduces N[V/x],$$ potem ima po lemi~\ref{lem:inversion-lema} funkcija $\tmfun{x : B}{N}$ tip $\tyfun{B}{\tycomp{A}{\o', \i'}}$ in $V$ tip $B$. Posledično ima $N$ tip $\tycomp{A}{\o', \i'}$. Po lemi~\ref{lem:substitucija-izračuni} ima $M' = N[V/x]$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmapp{(\tmfunrec{f}{x \of A'}{N})}{V} \reduces N[V/x, (\tmfunrec{f}{x \of A'}{N})/f],$$ potem ima po lemi~\ref{lem:inversion-lema} funkcija $\tmfunrec{f}{x \of B}{N}$ tip $\tyfun{B}{\tycomp{A}{\o', \i'}}$ in $V$ tip $B$. Posledično ima $N$ tip $\tycomp{A}{\o', \i'}$. Po lemi~\ref{lem:substitucija-izračuni} ima $\widetilde{M} = N[V/x]$ tip $\tycomp{A}{\o', \i'}$ in po isti lemi ima $M' = \widetilde{M}[(\tmfunrec{f}{x \of B}{N})/f]$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmlet{x}{(\tmreturn V)}{N} \reduces N[V/x],$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $V$ tip $B$ in $N$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:substitucija-izračuni} ima $M' = N[V/x]$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto N} \reduces N[V/x, W/y],$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $\tmpair{V}{W}$ tip $B_1 \times B_2$, $V$ tip $B_1$, $W$ tip $B_2$ in $N$ tip $\tycomp{A}{\o', \i'}$. Po lemi~\ref{lem:substitucija-izračuni} ima $\widetilde{M} = N[V/x]$ tip $\tycomp{A}{\o', \i'}$ in po isti lemi ima $M' = \widetilde{M}[W/y]$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmmatch{(\tminl[B_2]{V})}{\tminl{x} \mapsto N_1, \tminr{y} \mapsto N_2} \reduces N_1[V/x],$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $\tminl[B_2]{V}$ tip $B_1 + B_2$, $V$ tip $B_1$ in $N_1$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:substitucija-izračuni} ima $M' = N_1[V/x]$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmmatch{(\tminr[B_1]{W})}{\tminl{x} \mapsto N_1, \tminr{y} \mapsto N_2} \reduces N_2[W/y],$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $\tminr[B_1]{W}$ tip $B_1 + B_2$, $W$ tip $B_2$ in $N_2$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:substitucija-izračuni} ima $M' = N_2[W/y]$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmlet{x}{(\tmopout{op}{V}{N_1})}{N_2} \reduces \tmopout{op}{V}{\tmlet{x}{N_1}{N_2}},$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $V$ tip $B_{op}$, $\tmopout{op}{V}{N_1}$ tip $\tycomp{B}{\o', \i'}$, $N_1$ tip $\tycomp{B}{\o'', \i''}$ in $N_2$ tip $\tycomp{A}{\o', \i'}$, kjer je $(\o'', \i'') \order{O \times I} (\o', \i')$.
		Po pravilu \rulename{TyComp-Subsume} ima $N_1$ tip $\tycomp{B}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Let} ima $\tmlet{x}{N_1}{N_2}$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Signal} ima $M'$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmlet{x}{(\tmwith{op}{y}{N_1}{p}{N_2})}{N_3} \reduces$$ $$ \tmwith{op}{y}{N_1}{p}{(\tmlet{x}{N_2}{N_3})},$$ potem ima po lemi~\ref{lem:inversion-lema} izračun $N_1$ tip $\tycomp{\typromise{A_1}}{\o''', \i'''}$, $N_2$ tip $\tycomp{A_2}{\o'', \i''}$ in $N_3$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:weakening-comp} ima $N_3$ isti tip tudi kontekstu razširjenem z $p$.
		Po pravilih \rulename{TyComp-Let} in \rulename{TyComp-Promise} ima $M'$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmwith{op}{x}{N_1}{p}{\tmopout{op'}{V}{N_2}} \reduces$$ $$ \tmopout{op'}{V}{\tmwith{op}{x}{N_1}{p}{N_2}},$$ potem ima po lemi~\ref{lem:inversion-lema} izračun $N_1$ tip $\tycomp{B}{\o''', \i'''}$, $\tmopout{op'}{V}{N_2}$ tip $\tycomp{A}{\o'', \i''}$, $N_2$ tip $\tycomp{A}{\o', \i'}$ in $V$ tip $A_{op}$.
		Po pravilu \rulename{TyComp-Promise} ima $\tmwith{op}{x}{N_1}{p}{N_2}$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:tovor-osnovni-tip-skrcitev} ima $V$ še zmeraj tip $A_{op}$ tudi v manjšem kontekstu. Po pravilu \rulename{TyComp-Signal} ima $M'$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmopin{op}{V}{\tmopout{op'}{W}{N}} \reduces \tmopout{op'}{W}{\tmopin{op}{V}{N}},$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $V$ tip $A_{op}$, $\tmopout{op'}{W}{N}$ tip $\tycomp{A}{\o', \i'}$, $W$ tip $A_{op'}$ in $N$ tip $\tycomp{A}{\o'', \i''}$.
		Velja $\opincomp{op}{(\o', \i')} \order{O \times I} (\o, \i)$ in $(\o'', \i'') \order{O \times I} (\o', \i')$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N}$ tip $\opincomp{op}{(\o'', \i'')}$. 
		Po pravilu \rulename{TyComp-Signal} in lastnosti~\ref{lem:eo-1} iz leme~\ref{lem:effects-order} ima $M'$ tip $\tycomp{A}{\opincomp{op}{(\o'', \i'')}}$.
		Po lastnosti~\ref{lem:eo-5} iz leme~\ref{lem:effects-order} velja $\opincomp{op}{(\o'', \i'')} \order{O \times I} \opincomp{op}{(\o', \i')}$.
		Po pravilu \rulename{TyComp-Subsume} in tranzitivnosti $\order{O \times I}$ ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmopin{op}{V}{\tmreturn W} \reduces \tmreturn W,$$ potem ima po lemi~\ref{lem:inversion-lema} izračun $\tmreturn{W}$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmopin{op}{V}{\tmwith{op}{x}{N_1}{p}{N_2}} \reduces \tmlet{p}{N_1[V/x]}{\tmopin{op}{V}{N_2}},$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $V$ tip $A_{op}$, $N_1$ tip $\tycomp{\typromise{B}}{\o'', \i''}$ in $N_2$ tip $\tycomp{A}{\o', \i'}$.
		Velja $\opincomp{op}{(\o', \i')} \order{O \times I} (\o, \i)$.
		Po lemi~\ref{lem:substitucija-izračuni} ima $N_1[V/x]$ tip $\tycomp{\typromise{B}}{\o'', \i''}$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N_2}$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
		Ker je $\i'(op) = (\o'', \i'')$, velja $(\o'', \i'') \order{O \times I} \opincomp{op}{(\o', \i')}$ po lastnosti~\ref{lem:eo-3} iz leme~\ref{lem:effects-order}.
		Po pravilu \rulename{TyComp-Subsume} ima izračun $N_1[V/x]$ tip $\tycomp{\typromise{B}}{\opincomp{op}{(\o', \i')}}$.
		Po pravilu \rulename{TyComp-Let} ima $M'$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmopin{op'}{V}{\tmwith{op}{x}{N_1}{p}{N_2}} \reduces$$ $$ \tmwith{op}{x}{N_1}{p}{\tmopin{op'}{V}{N}_2},$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $V$ tip $A_{op}$, $N_1$ tip $\tycomp{\typromise{B}}{\o'', \i''}$, $N_2$ tip $\tycomp{A}{\o', \i'}$ in velja $\opincomp{op'}{(\o', \i')} \order{O \times I} (\o, \i)$.
		Po lemi~\ref{lem:weakening-values}, ima $V$ isti tip tudi v kontekstu razširjenem z $p$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op'}{V}{N}_2$ tip $\tycomp{A}{\opincomp{op'}{(\o', \i')}}$.
		Ker $\op \neq \op'$, velja $(\o'', \i'') \order{O \times I} (\pi_2(\opincomp{op'}{(\o', \i')}))(op)$, po lastnosti~\ref{lem:eo-4} iz leme~\ref{lem:effects-order}. Po pravilu \rulename{TyComp-Subsume} ima izračun $N_1$ tip $(\pi_2(\opincomp{op'}{(\o', \i')}))(op)$.
		Po pravilu \rulename{TyComp-Promise} ima $M'$ tip $\tycomp{A}{\opincomp{op'}{(\o', \i')}}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo $$\tmawait{\tmpromise V}{x}{N} \reduces N[V/x],$$ potem ima po lemi~\ref{lem:inversion-lema} vrednost $\tmpromise{V}$ tip $\typromise{B}$, $V$ tip $B$ in $N$ tip $\tycomp{A}{\o', \i'}$.
		Po lemi~\ref{lem:substitucija-izračuni} ima $M'$ tip $\tycomp{A}{\o', \i'}$.
		Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		
		\item Če je zadnje pravilo evalvacija v okolju ločimo štiri primere glede na obliko $M$.
		\begin{itemize}
			\item Če je oblike $$\tmlet{x}{N}{N''},$$ potem ima po lemi~\ref{lem:inversion-lema} izračun $N$ tip $\tycomp{B}{\o', \i'}$ in $N''$ tip $\tycomp{A}{\o', \i'}$.
			Po indukcijski predpostavki ima $N'$ tip $\tycomp{B}{\o', \i'}$.
			Po pravilu \rulename{TyComp-Subsume} ima $N'$ tip $\tycomp{A}{\o, \i}$.
			Po pravilu \rulename{TyComp-Subsume} ima $N''$ tip $\tycomp{A}{\o, \i}$.
			Po pravilu \rulename{TyComp-Let} ima $\tmlet{x}{N'}{N''}$ tip $\tycomp{A}{\o, \i}$.
			
			\item Če je oblike $$\tmopout{op}{V}{N},$$ potem ima po lemi~\ref{lem:inversion-lema} izračun $N$ tip $\tycomp{A}{\o', \i'}$.
			Po indukcijski predpostavki ima $N'$ tip $\tycomp{A}{\o', \i'}$.
			Po pravilu \rulename{TyComp-Signal} ima $\tmopout{op}{V}{N'}$ tip $\tycomp{A}{\o', \i'}$.
			Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
			
			\item Če je oblike $$\tmopin{op}{V}{N},$$ potem ima po lemi~\ref{lem:inversion-lema} izračun $N$ tip $\tycomp{A}{\o', \i'}$ in velja $\opincomp{op}{(\o', \i')} \order{O, I} (\o, \i)$.
			Po indukcijski predpostavki ima $N'$ tip $\tycomp{A}{\o', \i'}$.
			Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{N'}$ tip $\tycomp{A}{\opincomp{op}{(\o', \i')}}$.
			Izračun $M'$ ima tip $\tycomp{A}{\o, \i}$ po pravilu \rulename{TyComp-Subsume}.
			
			\item Če je oblike $$\tmwith{op}{x}{N''}{N},$$ potem ima po lemi~\ref{lem:inversion-lema} izračun $N$ tip $\tycomp{A}{\o', \i'}$ in $N''$ tip $\tycomp{\typromise{B}}{\o'', \i''}$.
			Po indukcijski predpostavki ima $N'$ tip $\tycomp{A}{\o', \i'}$.
			Po pravilu \rulename{TyComp-Promise} ima $\tmwith{op}{x}{N''}{p}{N'}$ tip $\tycomp{A}{\o', \i'}$.
			Po pravilu \rulename{TyComp-Subsume} ima $M'$ tip $\tycomp{A}{\o, \i}$.
		\end{itemize}

	\end{itemize}

\end{proof}


Ko imamo par dveh procesov in eden izmed njiju pošlje signal, se bo ta signal spremenil v prekinitev na drugem procesu.
Le to bo povzročilo, da se bo tip učinkov spremenil na drugem procesu. Trenutno je prekinitev edini izvor spremembe tipa.
Najpreprostejši primer je ko imamo vzporedna signal in zagon.
Ko proces naredi sledeči korak $$\tmpar{\tmopout{op}{V}{\tmrun{M_1}}}{\tmrun{M_2}} \reduces \tmopout{op}{V}{\tmpar{\tmrun{M_1}}{\tmopin{op}{V}{M_2}}}$$ bo pripadajoči tip naredil korak
$$\typar{\tyrun{A_1}{\o_1, \i_1}}{\tyrun{A_2}{\o_2, \i_2}} \tyreduces \typar{\tyrun{A_1}{\o_1, \i_1}}{\tyrun{A_2}{\opincomp{op}{(\o_2, \i_2)}}} \quad {\color{rulenameColor}(op \in o_1)}.$$
Potencialno spremembo tipa najprej formaliziramo z pravili na osnovnih tipih, kot jih lahko vidimo na sliki~\ref{fig:process-type-reductions-basic}. Nato jih posplošimo še za splošen tip na sliki~\ref{fig:process-type-reductions}.
Kako deluje operacija $\opincomp{op}{}$ na tipih procesov smo definirali že na sliki~\ref{fig:opin-proces}.

\begin{figure}[H]
	\centering
	\begin{mathpar}
		\coopinfer{TyRedu-Same-Basic}{
		}{
			\tyrun{A}{\o, \i} \tyreduces \tyrun{A}{\o, \i}
		}
		\qquad
		\coopinfer{TyRedu-Add-Basic}{
		}{
			\tyrun{A}{\opincompp{ops}{(\o, \i)}} \tyreduces \tyrun{A}{\opincompp{ops}{(\opincomp{op}{(\o, \i)})}}
		}
		\\
		\coopinfer{TyRedu-Par}{
			\tyC \tyreduces \tyC' \\
			\tyD \tyreduces \tyD'
		}{
			\typar{\tyC}{\tyD} \tyreduces \typar{\tyC'}{\tyD'}
		}
	\end{mathpar}
		$$\opincompp{[]}{(\o, \i)} \defeq (\o, \i) \qquad \opincompp{(op::ops)}{(\o, \i)} \defeq \opincomp{op}{(\opincompp{ops}{(\o, \i)})} $$
	\vspace{-5ex}
	\caption{Pravila za spremembo na osnovnih tipih.}
	\label{fig:process-type-reductions-basic}
\end{figure}

\begin{figure}[H]
	\centering
	\begin{mathpar}
		\coopinfer{TyRedu-Same}{
		}{
			\tyC \tyreduces \tyC
		}
		\qquad
		\coopinfer{TyRedu-Add}{
		}{
			\tyC \tyreduces \opincomp{op}{\tyC}
		}
		\qquad
		\coopinfer{TyRedu-Congruence}{
			\tyC \tyreduces \tyC'
		}{
			\opincomp{op}{\tyC} \tyreduces \opincomp{op}{\tyC'}
		}
	\end{mathpar}
	
%	\vspace{-5ex}
	\caption{Pravila za spremembo splošnih tipov.}
	\label{fig:process-type-reductions}
\end{figure}


Sledeča lema pove, da se pravila ujemajo.

\begin{lema}\label{lem:reductions-rules}
	Vsak korak iz slike~\ref{fig:process-type-reductions}, lahko predstavimo s koraki iz slike~\ref{fig:process-type-reductions-basic}.
\end{lema}

\begin{proof}
	\begin{itemize}
		\item \rulename{TyRedu-Same} : Dokazujemo s strukturno indukcijo na obliko tipa $\tyC$. Če je $\tyC$ oblike $\tyrun{A}{\o,\i}$, potem $\tyC = \tyrun{A}{\o,\i} \tyreduces \tyrun{A}{\o,\i} = \tyC$.
		Če je $\tyC$ oblike $\typar{D_1}{D_2}$, potem lahko po indukcijski predpostavki $D_1$ in $D_2$ naredita korak v $D_1$ in $D_2$. Skupaj s pravilom \rulename{TyRedu-Par} velja $C = \typar{D_1}{D_2} \reduces \typar{D_1}{D_2} = C$.
		
		\item \rulename{TyRedu-Add} : Dokazujemo s strukturno indukcijo na obliko tipa $\tyC$. Če je $\tyC$ oblike $\tyrun{A}{\o,\i}$, potem $\tyC = \tyrun{A}{\opincompp{ops}{(\o, \i)}} \tyreduces \tyrun{A}{\opincompp{ops}{(\opincomp{op}{(\o, \i)})}} = \opincomp{op}{\tyC}$ za $\mathsf{ops} = []$.
		Če je $\tyC$ oblike $\typar{D_1}{D_2}$, potem lahko po indukcijski predpostavki $D_1$ in $D_2$ naredita korak v $\opincomp{op}{D_1}$ in $\opincomp{op}{D_2}$. Skupaj s pravilom \rulename{TyRedu-Par} velja $C = \typar{D_1}{D_2} \reduces \typar{\opincomp{op}{D_1}}{\opincomp{op}{D_2}} = \opincomp{op}{\typar{D_1}{D_2}} = \opincomp{op}{\tyC}$.
		
		\item \rulename{TyRedu-Congruence} Dokazujemo s strukturno indukcijo na izpeljavo koraka $\tyC \tyreduces \tyC'$.
		\begin{itemize}
			\item Če je zadnji korak $\tyrun{A}{\o, \i} \tyreduces \tyrun{A}{\o, \i}$, potem je $\opincomp{op}{\tyC} = \tyrun{A}{\o', \i'} \reduces \tyrun{A}{\o', \i'} = \opincomp{op}{\tyC'}$ in smo torej naredili korak \rulename{TyRedu-Same-Basic}.
			
			\item Če je zadnji korak $\tyrun{A}{\opincompp{ops}{(\o, \i)}} \tyreduces \tyrun{A}{\opincompp{ops}{(\opincomp{op'}{(\o, \i)})}}$, potem je $\opincomp{op}{\tyC} = \tyrun{A}{\opincompp{op::ops}{(\o, \i)}} \reduces \tyrun{A}{\opincompp{op::ops}{(\opincomp{op'}{(\o, \i)})}} = \opincomp{op}{\tyC'}$ in smo torej naredili korak \rulename{TyRedu-Add-Basic}.
			
			\item Če je zadnji korak $\typar{\tyD_1}{\tyD_2} \tyreduces \typar{\tyD_1'}{\tyD_2'}$, potem lahko po indukcijski predpostavki $\opincomp{op}{\tyD_1}$ in $\opincomp{op}{\tyD_2}$ naredita korak v $\opincomp{op}{\tyD_1'}$ in $\opincomp{op}{\tyD_2'}$. Skupaj s pravilom \rulename{TyRedu-Par} velja $\opincomp{op}{\tyC} = \opincomp{op}{\typar{D_1}{D_2}} = \typar{\opincomp{op}{\tyD_1}}{\opincomp{op}{\tyD_2}} \reduces \typar{\opincomp{op}{\tyD_1'}}{\opincomp{op}{\tyD_2'}} = \opincomp{op}{\typar{D_1'}{D_2'}} = \opincomp{op}{\tyC'}$.
		\end{itemize}
	\end{itemize}
\end{proof}


\begin{izrek}[o ohranitvi]\label{izr:ohranitev}
	Naj za proces $P$ velja $\Gamma \types P \of C$. Če proces $P$ naredi korak $P \reduces P'$, potem obstaja tak $C'$, da velja $C \tyreduces C'$ in $\Gamma \types P' \of C'$.
\end{izrek}

\begin{proof}
	Dokazujemo s strukturno indukcijo na drevo izpeljave koraka $P \reduces P'$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	\begin{itemize}
		\item Če je zadnje uporabljeno pravilo
		$$
		\coopinfer{}{
			M \reduces N
		}{
			\tmrun M \reduces \tmrun N
		},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Run}. Tip $C$ je oblike $\tyrun{A}{\o, \i}$.
		Posledično ima izračun $M$ tip $\tycomp{A}{\o, \i}$. Po trditvi~\ref{trd:ohranitev-izracuni} ima $N$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyProc-Run} ima $P'$ tip $\tyrun{A}{\o, \i}$, kjer je $C$ naredil korak \rulename{TyRedu-Same}.
	
		\item Če je zadnje uporabljeno pravilo
		$$\tmrun {(\tmopout{op}{V}{M})}  \reduces \tmopout{op}{V}{\tmrun M},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Run}. Tip $C$ je oblike $\tyrun{A}{\o, \i}$.
		Posledično ima $V$ tip $B$ in $M$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyProc-Run} ima $\tmrun{M}$ tip $\tyrun{A}{\o, \i}$.
		Po pravilu \rulename{TyProc-Signal} ima $P'$ tip $\tyrun{A}{\o, \i}$, kjer je $C$ naredil korak \rulename{TyRedu-Same}.
		
		\item Če je zadnje uporabljeno pravilo
		$$\tmopin{op}{V}{\tmrun M} \reduces \tmrun {(\tmopin{op}{V}{M})},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Interrupt}. Tip $C$ je oblike $\tyrun{A}{\opincomp{op}{(\o, \i)}}$.
		Posledično ima $V$ tip $B$ in $M$ tip $\tycomp{A}{\o, \i}$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{M}$ tip $\tycomp{A}{\opincomp{op}{(\o, \i)}}$.
		Po pravilu \rulename{TyProc-Run} ima $P'$ tip $\tyrun{A}{\opincomp{op}{(\o, \i)}} = C$, kjer je $C$ naredil korak \rulename{TyRedu-Same}.
		
		\item Če je zadnje uporabljeno pravilo
		$$\tmpar{\tmopout{op}{V}{Q_1}}{Q_2} \reduces \tmopout{op}{V}{\tmpar{Q_1}{\tmopin{op}{V}{Q_2}}},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Par}. Tip $C$ je oblike $\typar{C_1}{C_2}$.
		Posledično ima $V$ tip $B$, $Q_1$ tip $C_1$ in $Q_2$ tip $C_2$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{Q_2}$ tip $\opincomp{op}{C_2}$.
		Po pravilu \rulename{TyProc-Par} ima $P'$ tip $\typar{C_1}{\opincomp{op}{C_2}}$, kjer je $C_1$ naredil korak \rulename{TyRedu-Same}, $C_2$ naredil korak \rulename{TyRedu-Add} in $C$ naredil korak \rulename{TyRedu-Par}.

		\item Če je zadnje uporabljeno pravilo
		$$\tmpar{Q_1}{\tmopout{op}{V}{Q_2}} \reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{Q_1}}{Q_2}},$$
		dokazujemo podobno kot prejšnji primer.
	
		\item Če je zadnje uporabljeno pravilo
		$$\tmopin{op}{V}{\tmpar{Q_1}{Q_2}} \reduces \tmpar {\tmopin{op}{V}{Q_1}} {\tmopin{op}{V}{Q_2}},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Interrupt}. Tip $C$ je oblike $\opincomp{op}{\typar{C_1}{C_2}}$.
		Vrednost $V$ ima tip $B$, $Q_1$ tip $C_1$ in $Q_2$ tip $C_2$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{Q_1}$ tip $\opincomp{op}{C_1}$ in $\tmopin{op}{V}{Q_2}$ tip $\opincomp{op}{C_2}$.
		Po pravilu \rulename{TyProc-Par} ima $P'$ tip $\typar{\opincomp{op}{C_1}}{\opincomp{op}{C_2}} = \opincomp{op}{\typar{C_1}{C_2}}$. Tip $C$ je naredil korak \rulename{TyRedu-Same}.
		
		\item Če je zadnje uporabljeno pravilo
		$$\tmopin{op}{V}{\tmopout{op'}{V'}{Q}} \reduces \tmopout{op'}{V'}{\tmopin{op}{V}{Q}},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Interrupt}. Tip $C$ je oblike $\opincomp{op}{C'}$.
		Vrednost $V$ ima tip $B$, $V'$ tip $B'$ in $Q$ tip $C'$.
		Po pravilu \rulename{TyComp-Interrupt} ima $\tmopin{op}{V}{Q}$ tip $C$.
		Po pravilu \rulename{TyProc-Signal} ima $P'$ tip $C$, kjer je $C$ naredil korak \rulename{TyRedu-Same}.
		
		\item Če je zadnje uporabljeno pravilo
		$$
		\coopinfer{}{
			Q_1 \reduces Q_1'
		}{
			\tmpar{Q_1}{Q_2}  \reduces \tmpar{Q_1'}{Q_2}
		},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Par}. Tip $C$ je oblike $\typar{C_1}{C_2}$.
		Proces $Q_1$ ima tip $C_1$ in $Q_2$ tip $C_2$.
		Po indukcijski predpostavki je $C_1$ naredil korak v $C_1'$ in $Q_1'$ ima tip $C_1'$.
		Po pravilu \rulename{TyProc-Par} ima $\tmpar{Q_1'}{Q_2}$ tip $\typar{C_1'}{C_2}$, kjer je $C_1$ naredil korak iz indukcijske predpostavke, $C_2$ je naredil korak \rulename{TyRedu-Same} in $C$ naredil korak \rulename{TyRedu-Par}.

		\item Če je zadnje uporabljeno pravilo
		$$
		\coopinfer{}{
			Q_2 \reduces Q_2'
		}{
			\tmpar{Q_1}{Q_2}  \reduces \tmpar{Q_1}{Q_2'}
		},$$
		dokazujemo podobno kot za prejšnje pravilo.
		
		\item Če je zadnje uporabljeno pravilo
		$$
		\coopinfer{}{
			Q \reduces Q'
		}{
			\tmopout{op}{V}{Q}  \reduces \tmopout{op}{V}{Q'}
		},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Signal}.
		Posledično ima $V$ tip $B$ in $Q$ tip $C$.
		Po indukcijski predpostavki je $C$ naredil korak v $C'$ in $Q'$ ima tip $C'$.
		Po pravilu \rulename{TyProc-Signal} ima $\tmopout{op}{V}{Q'}$ tip $C'$. Tip $C$ je naredil isti korak kot v indukcijski predpostavki.
		
		\item Če je zadnje uporabljeno pravilo
		$$
		\coopinfer{}{
			Q \reduces Q'
		}{
			\tmopin{op}{V}{Q}  \reduces \tmopin{op}{V}{Q'}
		},$$
		potem je bilo zadnje pravilo za določitev tipa $P$ \rulename{TyProc-Interrupt}.
		Posledično ima $V$ tip $B$ in $Q$ tip $C''$, kjer je $C = \opincomp{op}{C''}$.
		Po indukcijski predpostavki je $C''$ naredil korak v $C'$ in $Q'$ ima tip $C'$.
		Po pravilu \rulename{TyProc-Interrupt} ima $\tmopin{op}{V}{Q'}$ tip $\opincomp{op}{C'}$, tip $C$ pa je naredil korak \rulename{TyRedu-Congruence}.
	\end{itemize}

\end{proof}


