\section{Račun \lae{}}\label{sec:lae}

Račun $\lambda$ je preprost teoretičen programski jezik. Leta 1930 ga je uvedel Alonzo Chuch z namenom formalizacije koncepta izračunljivosti~\cite{rojas2015tutorial}. Račun lambda je Turingovo poln.


Račun \lae{} je razširitev računa $\lambda$. Posledično je tudi \lae{}-račun Turingovo poln. Računu \lae{} dodamo izraze, ki poosebijo bistvo asinhrono vzporednega programiranja z pomočjo učinkov. Da \lae{}-račun čim bolj približamo vsakdanjim programskim jezikom, mu dodamo tudi izraze za  naravna števila, par, ujemanje vzorca...


\subsection{Izrazi}

Izraze v \lae{}-računu razdelimo na vrednosti, izračune in procese. 


Vrednosti so sledeče.
Konstante vrednosti naravna števila in logični vrednosti resnica in neresnica.
% TOLE DODAJ ČE BO MAGISTRSKA PREKRATKA DA BODO DALJŠI DOKAZI in nekatere aritmetične in logične funkcije kot so $+$, $-$, $*$, $/$, $=$, $<$...
Spremenljivke, ki so simbolična imena povezana z vrednostmi v danem kontekstu.
Enote in pare.
leve in desne inkluzije vsote.
Lambda abstrakcije.
Rekurzivne lambda abstrakcije.
Izpolnjena obljuba. Ta vrednost je edina zares nova. Je vrednost, ki jo je vrnil prestreznik in jo posebej označimo, da bomo kasneje lahko pravilno določili tip.


Izračuni so sledeči.
Vrni ki drži neko vrednost.
Zaporedje dveh izračunov.
Aplikacija ki v prvi izraz substituira drugi izraz.
Ujemanje ki glede na vzorec izraza izbere izračun. 
Signal vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prekinitev vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prestreznik vsebuje ime operacije, ime spremeljivke, Izračun M in izračun N.
blokada


Pripadajočo sintakso vidimo na~\ref{fig:izrazi} v Backus-Naurjevi obliki (BNF).



\begin{figure}[h]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\intertext{\textbf{Vrednosti}}
		V, W
		\bnfis& n \bnfor\! \true \bnfor\! \false        & &\text{konstantne vrednosti} \\
		\bnfor& x                                       & &\text{spremenljivka} \\
		\bnfor& \tmunit \bnfor\! \tmpair{V}{W}          & &\text{enota in par} \\
		\bnfor& \tminl[Y]{V} \bnfor\! \tminr[X]{V}      & &\text{leva in desna inkluzija} \\
		\bnfor& \tmfun{x}{M}                        & &\text{lambda} \\
		\bnfor& \tmfunrec{f}{x : X}{M}                        & &\text{rekurzivna lambda} \\
		\bnfor& \tmpromise V                            & &\text{izpolnjena obljuba}
		\\[1ex]
		\intertext{\textbf{Izračuni}}
		M, N
		\bnfis& \tmreturn{V}                            & &\text{vrnjena vrednost} \\
		\bnfor& \tmlet{x}{M}{N}                         & &\text{zaporedje} \\
	%	\bnfor& \tmletrec[: \tyfun{X}{Y}]{f}{x}{M}{N} & &\text{rekurzivna definicija} \\
		\bnfor& V\,W                                    & &\text{aplikacija} \\
		\bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    & &\text{ujemanje produkta} \\
		\bnfor& \tmmatch[]{V}{}                        & &\text{prazno ujemanje} \\
		\bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}	& &\text{ujemanje vsote} \\
		\bnfor& \tmopout{op}{V}{M}       & &\text{signal} \\
		\bnfor& \tmopin{op}{V}{M}          & &\text{prekinitev} \\
		\bnfor& \tmwith{op}{x}{M}{p}{N}      & &\text{prestreznik} \\
		\bnfor& \tmawait{V}{x}{M}             & &\text{blokada}
			\\[1ex]
		\intertext{\textbf{Procesi}}
	%	P \bnfis & ...
		  P, Q
		\bnfis & \tmrun M & & \text{run} \\
		\bnfor & \tmpar P Q & & \text{vzporedna procesa} \\
		\bnfor & \tmopout{op}{V}{P} & & \text{proces signal} \\
		\bnfor & \tmopin{op}{V}{P} & & \text{proces prekinitev}
		\end{align*}
	} 
	\caption{Vrednosti, izračuni in procesi.}
	\label{fig:izrazi}
\end{figure}


\subsection{Operacijska semantika}

Račun \lae\ opremimo z operacijsko semantiko malih korakov, ki je definirana z relacijo korak $M \reduces N$. Redukcijska pravila za izračune so podana na sliki~\ref{fig:small-step-semantics-of-computations}. Redukcijska pravila za procese so podana na sliki~\ref{fig:small-step-semantics-of-processes}.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Pravila osnovnih izračunov}}
	\tmapp{(\tmfun{x \of X}{M})}{V} &\reduces M[V/x]
	\\
	\tmapp{(\tmfunrec{f}{x \of X}{M})}{V} &\reduces M[V/x, (\tmfunrec{f}{x \of X}{M})/f]
	\\
	\tmlet{x}{(\tmreturn V)}{N} &\reduces N[V/x]
	\\
	\tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto M} &\reduces M[V/x, W/y]
	\\
	\mathllap{\tmmatch{(\tminl[Y]{V})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	M[V/x]
	\\
	\mathllap{\tmmatch{(\tminr[X]{W})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	N[W/y]
	\\[1ex]
	\intertext{\textbf{Algebraičnost signala in prestreznika}}
	\tmlet{x}{(\tmopout{op}{V}{M})}{N} &\reduces \tmopout{op}{V}{\tmlet{x}{M}{N}}
	\\
	\tmlet{x}{(\tmwith{op}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwith{op}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\\[1ex]
	\intertext{\textbf{Komutativnost operacij}}
	\tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmopout{op'}{W}{M}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{M}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmreturn W} &\reduces \tmreturn W
	\\
	\tmopin{op}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}
	\\
	\tmopin{op'}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmwith{op}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\\[1ex]
	\intertext{\textbf{Čakanje na izpolnitev obljube}}
	\tmawait{\tmpromise V}{x}{M} &\reduces M[V/x]
	\\[-8ex]
	\end{align*}
	
	\begin{align*}
	\intertext{\textbf{Evalvacija v okolju}}
	\coopinfer{}{
		M \reduces N
	}{
		\E[M] \reduces \E[N]
	}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{kjer}}
	\text{$\E$}
	\bnfis [~]
	\bnfor \tmlet{x}{\E}{N}
	\bnfor \tmopout{op}{V}{\E}
	\bnfor \tmopin{op}{V}{\E} 
	\bnfor \tmwith{op}{x}{M}{p}{\E}
	\end{align*}
	
	\caption{Operacijska semantika malih korakov za izračune.}
	\label{fig:small-step-semantics-of-computations}
\end{figure}

\begin{figure}[h]
    \centering
	\small
	\begin{minipage}[t]{0.4\textwidth}
		\centering
		\begin{align*}
		\intertext{\textbf{Posamezen proces}}
		\coopinfer{}{
			M \reduces N
		}{
			\tmrun M \reduces \tmrun N
		}
		\end{align*}
	\end{minipage}
	\qquad
	\begin{align*}
	\intertext{\textbf{Prehod}}
	\tmrun {(\tmopout{op}{V}{M})}  &\reduces \tmopout{op}{V}{\tmrun M}
	\\
	\tmopin{op}{V}{\tmrun M} &\reduces \tmrun {(\tmopin{op}{V}{M})}
	\\[1ex]
	\intertext{\textbf{Oddajanje signala}}
	\tmpar{\tmopout{op}{V}{P}}{Q} &\reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
	\\
	\tmpar{P}{\tmopout{op}{V}{Q}} &\reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{P}}{Q}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmpar P Q} &\reduces \tmpar {\tmopin{op}{V}{P}} {\tmopin{op}{V}{Q}}
	\\[1ex]
	\intertext{\textbf{Komutativnost signala in prekinitve}}
	\tmopin{op}{V}{\tmopout{op'}{W}{P}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{P}}
	\end{align*}
	\vspace{-4ex}
	\begin{align*}
	\shortintertext{\quad\textbf{Evalvacija v okolju}}
	\quad
	\coopinfer{}{
		P \reduces Q
	}{
		\F[P] \reduces \F[Q]
	}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{kjer}}
	\text{$\F$}
	\bnfis& [~]
	\bnfor \tmpar \F Q \bnfor\! \tmpar P \F
	\bnfor \tmopout{op}{V}{\F}
	\bnfor \tmopin{op}{V}{\F}
	\end{align*}
	
	\caption{Operacijska semantika malih korakov za procese.}
	\label{fig:small-step-semantics-of-processes}
\end{figure}

Poleg teh pravil, ki so identična pravilom iz \cite{aeff}, dodamo še dve novi.
Prvo pravilo potegne blokado ven iz zaporedja. Drugo pravilo prestavi prekinitev takoj za blokado. Obe pravili skupaj dosežeta dvoje. Malenkost večji del prvotnega izračuna je postal asinhron. Kar nam lahko v primeru, da bo obljuba izpolnjena in bomo nadaljevali z izvajanjem tega dela, nekoliko pohitri izvajanje. Druga prednost pa je, da izračun, ki je v čakajočem stanju, se vedno začne z izračunom $\tmkw{Await}$. Posledično je prepoznati ali je izračun v čakajočem stanju trivialno in se bodo delni rezultati nekoliko poenostavili. 

Rezultati ostanejo enaki kot v \cite{aeff}.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
		\intertext{\textbf{Algebraičnost blokade}}
		\tmlet{x}{(\tmawait{V}{y}{M})}{N} & \reduces \tmawait{V}{y}{(\tmlet{x}{M}{N})}
		\\[1ex]
		\intertext{\textbf{Komutativnost blokade in prekinitve}}
		\tmopin{op}{V}{\tmawait{W}{x}{M}} &\reduces \tmawait{W}{x}{\tmopin{op}{V}{M}}
	\end{align*}
	
	\caption{Dodatni pravili operacijske semantike.}
	\label{fig:operacijska-semantika-poenostavitev}
\end{figure}

\subsection{Sistem tipov}


Da se izognemo nekaterim napakam ob izvajanju uvedemo sistem tipov.
Tipe ločimo na tipe za vrednosti, izračune in procese.
Večina vrednosti dobi standardne tipe, kot so naravno število, boolean, enota, par, vsota in funkcijski tip. 


%%Predolga/grda poved
Ker funkcijski tip označuje funkcijo, ki vzame argument in mu priredi izračun, le tej pa imajo, kot bomo kasneje videli, poleg standardnih tipov, še tipe za učinke, ima tudi funkcijski tip dodane tipe za učinke.


Dodatno za vrednost obljuba uvedemo tip \emph{obljuba} $\typromise{A}$. 
Tipom za vrednosti, ki ne vsebujejo funkcijskega tipa ali obljube, pravimo osnovni tipi. 


Izračunom poleg standardnega tipa dodamo še tipe signalov, ki jih lahko sprožimo, označene z $\o$ in tipe prekinitev, ki jih lahko prestrežemo, označene z $\i$.
Tipi učinkov $\o$ in $\i$ so elementi množice $O$ oziroma $I$.
Množica $\sig$ je množica vseh operacij, ki jih imamo na voljo.
Množica $O$ je preprosto potenčna množica množice $\sig$ in posledično $\o$ predstavlja množico signalov, ki jih izračun lahko sproži.

Ko prestrežemo neko prekinitev lahko ustrezen izračun obljuba začne sprožati nove signale in prestrezati nove prekinitve. Zato $I$ definiramo kot največjo fiksno točko preslikave $\omega$ definirane kot 
$$\Omega(X) = \sig \Rightarrow (O \times X)_\bot $$,
kjer je $\Rightarrow$ potenciranje, $\times$ je kartezični produkt in $(-)_\bot$ je dvig.


Tipi procesov so odvisni od tipov izračunov in posledično vsebujejo tipe učinkov.

Pravila za dodelitev tipa vidimo na sliki~\ref{fig:value-typing-rules} in~\ref{fig:computation-typing-rules}.


\begin{figure}[h]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\text{Osnovni tipi vrednosti $\bar{A}$, $\bar{B}$}
		\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\bar{A}}{\bar{B}} \,\bnfor\! \tysum{\bar{A}}{\bar{B}}
		\\%[1ex]
		\text{Tipi vrednosti $A$, $B$}
		\bnfis & \bar{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
		\\
		\text{Tip izračuna} \bnfis& \tycomp{A}{\o,\i}
		\\
		\text{Tip procesa \tyC, \tyD}  \bnfis & \tyrun{A}{\o, \i} \,\bnfor\! \typar{\tyC}{\tyD}
		\end{align*}
	} 
	\caption{Tipi izrazov}
	\label{fig:tipi}
\end{figure}

Vsaki operaciji priredimo nek tip, kot vidimo na sliki~\ref{fig:operacije}. Ker izračun 
$$ \tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} $$
lahko naredi korak v izračun
$$ \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}} $$,
je ključno da vrednost $V$ ne vsebuje spremenljivke $p$, saj v drugem izračunu spremenljivka $p$ v vrednosti $V$ ni več dobro definiran. Da zagotovimo, da vrednost $V$ ne vsebuje spremenljivke $p$, omejimo tipe, ki pripadajo operacijam, na osnovne tipe.

\begin{figure}[t]
	\centering
	\small
	\begin{align*}
	(op_1, \bar{A}_{op_1}),\, (op_2, \bar{A}_{op_2}),\, ... ,\, (op_n, \bar{A}_{op_k})
	\end{align*}
\vspace{-5ex}
	\caption{Operacije in pripadajoči osnovni tipi.}
	\label{fig:operacije}
\end{figure}



\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types n : int
		}
		\qquad
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types true : bool
		}
		\qquad
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types false : bool
		}
		\quad
		\coopinfer{Tip-Var}{
		}{
			\Gamma, x \of X, \Gamma' \types x : X
		}
		\quad
		\coopinfer{Tip-Unit}{
		}{
			\Gamma \types \tmunit : \tyunit
		}
		\\
		\coopinfer{Tip-Pair}{
			\Gamma \types V : X \\
			\Gamma \types W : Y
		}{
			\Gamma \types \tmpair{V}{W} : \typrod{X}{Y}
		}
		\quad
		\coopinfer{Tip-Promise}{
			\Gamma \types V : X
		}{
			\Gamma \types \tmpromise V : \typromise X
		}
		\quad
		\coopinfer{Tip-Inl}{
			\Gamma \types V : X
		}{
			\Gamma \types \tminl[Y]{V} : X + Y
		}
		\quad
		\coopinfer{Tip-Inr}{
			\Gamma \types W : Y
		}{
			\Gamma \types \tminr[X]{W} : X + Y
		}
		\\
		\coopinfer{Tip-Fun}{
			\Gamma, x \of X \types M : \tycomp{Y}{\o,\i}
		}{
			\Gamma \types \tmfun{x : X}{M} : \tyfun{X}{\tycomp{Y}{\o,\i}}
		}
		\quad
		\coopinfer{Tip-Fun-Rec}{
			\Gamma,f \of \tyfun{X}{\tycomp{Y}{\o,\i}}, x \of X \types M : \tycomp{Y}{\o,\i}
		}{
			\Gamma \types \tmfunrec{f}{x : X}{M} : \tyfun{X}{\tycomp{Y}{\o,\i}}
		}
	\end{mathpar}
	\caption{Pravila za izračun tipov za vrednosti.}
	\label{fig:value-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyComp-Return}{
			\Gamma \types V : X
		}{
			\Gamma \types \tmreturn{V} : \tycomp{X}{(\o,\i)} 
		}
		\qquad
		\coopinfer{TyComp-Let}{
			\Gamma \types M : \tycomp{X}{(\o,\i)}
			\\
			\Gamma, x \of X \types N : \tycomp{Y}{(\o,\i)} 
		}{												
			\Gamma \types
			\tmlet{x}{M}{N} : \tycomp{Y}{(\o,\i)}       
		}											
		\\
		\coopinfer{TyComp-Apply}{
			\Gamma \types V : \tyfun{X}{\tycomp{Y}{(\o,\i)}} \\
			\Gamma \types W : X
		}{
			\Gamma \types \tmapp{V}{W} : \tycomp{Y}{(\o,\i)}
		}
		\quad
		\coopinfer{TyComp-MatchPair}{
			\Gamma \types V : \typrod{X}{Y} \\
			\Gamma, x \of X, y \of Y \types M : \tycomp{Z}{(\o,\i)}
		}{
			\Gamma \types \tmmatch{V}{\tmpair{x}{y} \mapsto M} : \tycomp{Z}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-MatchEmpty}{
			\Gamma \types V : \tyempty
		}{
			\Gamma \types \tmmatch[\tycomp{Z}{(\o,\i)}]{V}{} : \tycomp{Z}{(\o,\i)}
		}
		\quad
		\coopinfer{TyComp-MatchSum}{
			\Gamma \types V : X + Y \\\\
			\Gamma, x \of X \types M : \tycomp{Z}{(\o,\i)} \\
			\Gamma, y \of Y \types N : \tycomp{Z}{(\o,\i)} \\
		}{
			\Gamma \types \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} : \tycomp{Z}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-Signal}{
			\op \in \o \\
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{X}{(\o,\i)} 
		}{
			\Gamma \types \tmopout{op}{V}{M} : \tycomp{X}{(\o,\i)}
		}
		\qquad
		\coopinfer{TyComp-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{X}{(\o,\i)} 
		}{
			\Gamma \types \tmopin{op}{V}{M} : \tycomp{X}{\opincomp {op} (\o,\i)}
		}
		\\
		\coopinfer{TyComp-Promise}{
			\i\, (\op) = ({\o'} , {\i'}) \\
			\Gamma, x \of A_\op \types M : \tycomp{\typromise X}{(\o',\i')} \\
			\Gamma, p \of \typromise X \types N : \tycomp{Y}{(\o,\i)} 
		}{
			\Gamma \types \tmwith{op}{x}{M}{p}{N} : \tycomp{Y}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-Await}{
			\Gamma \types V : \typromise X \\
			\Gamma, x \of X \types M : \tycomp{Y}{(\o,\i)} 
		}{
			\Gamma \types \tmawait{V}{x}{M} : \tycomp{Y}{(\o,\i)}
		}
		\qquad
		\coopinfer{TyComp-Subsume}{
			\Gamma \types M : \tycomp{X}{(\o, \i)} \\
			(\o,\i) \order {O \times I} (\o',\i')
		}{
			\Gamma \types M : \tycomp{X}{(\o', \i')}
		}
	\end{mathpar}
	\caption{Pravila za izračun tipov za izračune.}
	\label{fig:computation-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyProc-Run}{
			\Gamma \types M : \tycomp{X}{\o,\i}
		}{
			\Gamma \types \tmrun{M} : \tyrun{X}{\o, \i}
		}
		\quad
		\coopinfer{TyProc-Par}{
			\Gamma \types P : \tyC \\
			\Gamma \types Q : \tyD
		}{
			\Gamma \types \tmpar{P}{Q} : \typar{\tyC}{\tyD}
		}
		\\
		\coopinfer{TyProc-Signal}{
			\op \in \mathsf{signals\text{-}of}{(\tyC)} \\\\
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopout{op}{V}{P} : \tyC
		}
		\quad
		\coopinfer{TyProc-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopin{op}{V}{P} : \opincomp{op}{\tyC}
		}  
	\end{mathpar}
	\caption{Pravila za izračun tipov za procese.}
	\label{fig:process-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering

%	\textbf{Čakajoči izrazi}
%	\begin{mathpar}
%		\coopinfer{}{
%		}{
%			\awaiting p {\tmawait p x M}
%		}
%		\quad
%		\coopinfer{}{
%			\awaiting p M
%		}{
%			\awaiting p {\tmlet x M N}
%		}
%		\quad
%		\coopinfer{}{
%			\awaiting p M
%		}{
%			\awaiting p {\tmopin{op}{V}{M}}
%		}
%	\end{mathpar}
	
	\textbf{Delni rezultati}
	\begin{mathpar}
		\coopinfer{R-Return}{
		}{
			\RunResult {\Psi} {\tmreturn V}
		}
		\qquad
		\coopinfer{R-Signal}{
		}{
			\RunResult {\Psi} {\tmopout{op}{V}{M}}
		}
		\\
		\coopinfer{R-Promise}{
			\RunResult {\Psi \cup \{p\}} {N}
		}{
			\RunResult {\Psi} {\tmwith {op} x M p N}
		}
		\qquad
		\coopinfer{R-Await}{
			p \in \Psi
		}{
			\RunResult {\Psi} {\tmawait{p}{x}{M}}
		}
	\end{mathpar}

	\textbf{Rezultati}
	\begin{mathpar}
		\coopinfer{R-Out}{
			\ProcResult {P}
		}{
			\ProcResult {\tmopout {op} V P}
		}
		\qquad
		\coopinfer{R-Process}{
			\ParResult {P}
		}{
			\ProcResult {P}
		}
		\\
		\coopinfer{R-Parallel}{
			\ParResult P \\
			\ParResult Q
		}{
			\ParResult {\tmpar P Q}
		}
		\qquad
		\coopinfer{R-Run}{
			\RunResult {\emptyset} {M}
		}{
			\ParResult {\tmrun M}
		}
	\end{mathpar}
	\caption{Rezultati in delni rezultati.}
	\label{fig:results-rules}
\end{figure}


Izrek o varnosti, ki je sestavljen iz izreka o ohranitvi in izreka o napredku nam zagotavlja, da ne moremo dobiti runtime, če imamo tipe, kot smo jih definirali.



\begin{trditev}[o napredku]\label{trd:gamma-napredek}
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$, kjer je $\Gamma = \{(x_1,\typromise{A_1}),(x_2,\typromise{A_2}),...,(x_i,\typromise{A_i})\}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\RunResult{\Gamma}{M}$.
\end{trditev}

\begin{proof}
	Ker ima izračun $M$ tip, obstaja drevo izpeljave za njegov tip.
	Dokazujemo z indukcijo na globino drevesa izpeljave za izračune.
	
	Za $n$ je $1$ ločimo dva primera glede na uporabljeno pravilo v drevesu izpeljave.
	Če je uporabljeno pravilo $TyComp-Return$, potem je $M$ enak $\tmreturn{V}$. Po pravilu $R-Return$ sledi, da je $M$ delni rezultat in velja (ii).
	Če je uporabljeno pravilo $TyComp-Apply$, potem je $M$ enak $V W$ in $V$ mora biti oblike $\tmfunano{x}{M}$ ali $\tmfunrecano{f}{x}{M}$. Posledično lahko naredimo korak v $M[W/x]$ ali $M[V/x, (\tmfunrec{f}{x \of X}{M})/f]$.
	
	Sedaj pokažimo da, če velja trditev za $n = 1,...,n$ velja tudi za $n+1$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	Če je zadnje pravilo $TyComp-Let$, potem je $M$ enak $\tmlet{x}{N_1}{N_2}$.
	Izračun $N_1$ ima tip in po $IP$ lahko naredi korak ali pa je delni rezultat. Če $N_1$ lahko naredi korak v $N_1'$, potem lahko po pravilu za evalvacijo v okolju tudi $M$ naredi korak v $\tmlet{x}{N_1'}{N_2}$.
	Če pa je $N_1$ delni rezultat, ločimo štiri možnosti. 
	Če je $N_1$ enak $\tmreturn{V}$, potem lahko $M$ naredi korak v izračun $N_2[V/x]$. 
	Če je $N_1$ enak $\tmopout{op}{V}{N_3}$, potem lahko $M$ naredi korak v $\tmopout{op}{V}{(\tmlet{x}{N_3}{N_2})}$
	Če je $N_1$ enak $\tmwith{op}{x}{N_3}{p}{N_4}$, lahko $M$ naredi korak v $\tmwith{op}{x}{N_3}{p}{(\tmlet{x}{N_4}{N_2})}$. 
	Če pa je $N_1$ enak $\tmawait{p}{y}{N_3}$, lahko $M$ naredi korak v $\tmawait{p}{y}{(\tmlet{x}{N_3}{N_2})}$
	
	Če je zadnje pravilo $TyComp-MatchPair$, potem je $M$ enak $\tmmatch{V}{(x,y) \mapsto N}$. Ker ima vrednost $V$ tip $X \times Y$ in v kontekstu nobena spremenljivka nima tipa $X \times Y$, je $V$ oblike $(W_1,W_2)$ in posledično lahko $M$ naredi korak v izračun $N[W_1/x,W_2/y]$.
	
	Zadnje pravilo ne more biti $TyComp-MatchEmpty$, saj bi potem morali imeti vrednost tipa $0$. Vrednost tega tipa ne obstaja.
	
	Če je zadnje pravilo $TyComp-MatchSum$, potem je $M$ enak $\tmmatch{V}{\tminl{x} \mapsto N_1, \tminr{y} \mapsto N_2}$.
	Ker ima vrednost $V$ tip $X + Y$ in v kontekstu nobena spremenljivka nima tipa $X + Y$, je $V$ oblike $\tminl{W_1}$ ali $\tminr{W_2}$.
	Če je oblike $\tminl{W_1}$ lahko $M$ naredi korak v $N_1[W_1/x]$.
	Sicer je oblike $\tminr{W_2}$ in lahko $M$ naredi korak v $N[W_2/y]$.
	
	Če je zadnje pravilo $TyComp-Signal$, potem je $M$ enak $\tmopout{op}{V}{N}$ in po pravilu $R-Signal$ dokažemo (ii).
	
	Če je zadnje pravilo $TyComp-Interupt$, potem je $M$ enak $\tmopin{op}{V}{N}$. Izračun $N$ ima tip in po $IP$ lahko naredi korak ali pa je že delna vrednost. Če $N$ lahko naredi korak v $N'$, potem po pravilu za evalvacijo v okolju tudi $M$ lahko naredi korak v $\tmopin{op}{V}{N'}$. 
	Če pa je $N$ delni rezultat ločimo štiri možnosti.
	Če je $N$ enak $\tmreturn{V}$, potem lahko $M$ naredi korak v $\tmreturn{V}$.
	Če je $N$ enak $\tmopout{op'}{W}{O}$, potem lahko $M$ naredi korak v $\tmopout{op'}{W}{(\tmopin{op}{V}{O})}$.
	Če je $N$ enak $\tmwith{op'}{x}{O}{p}{O'}$, potem lahko $M$ naredi ali korak v $\tmlet{p}{O[V/x]}{O'}$, če velja $op = op'$, ali v $\tmwith{op'}{x}{O}{p}{\tmopin{op}{V}{O'}}$ sicer.
	Če pa je $N$ enak $\tmawait{p}{x}{O}$, lahko $M$ naredi korak v $\tmawait{p}{x}{(\tmopin{op}{V}{O})}$.
	
	Če je zadnje pravilo $TyComp-promise$, potem je $M$ enak $\tmwith{op}{x}{N_1}{p}{N_2}$. Izračun $N_2$ ima tip in po $IP$ lahko $N_2$ naredi korak ali pa je že delna vrednost. Če $N_2$ lahko naredi korak v $N_2'$, potem po pravilu za evalvacijo v okolju tudi $M$ lahko naredi korak v $\tmwith{op}{x}{N_1}{p}{N_2'}$.
	Če pa je $N_2$ delni rezultat, je tudi $M$ delni rezultat.
	
	Če je zadnje pravilo $TyComp-Await$, potem je $M$ oblike $\tmawait{V}{p}{N}$.
	Ločimo dva primera.
	Če je $V$ spremenljivka v kontekstu $\Gamma$, potem je po pravilu $R-Await$ $M$ delni rezultat.
	Sicer je $V$ enak $\tmpromise{W}$. Tedaj lahko $M$ naredi korak v $N[W/p]$.
	
	Če je zadnje pravilo $TyComp-Subsume$, lahko $IP$ uporabimo direktno na $M$ in posledično lahko $M$ naredi korak ali pa je $M$ delni rezultat.
\end{proof}


\begin{posledica}[o napredku]\label{pos:prazen-napredek}
	Naj za izračun $M$ velja $\emptyset \types M \of \tycomp{A}{\o, \i}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\RunResult{\emptyset}{M}$.
\end{posledica}

\begin{proof}
	Trditev \ref{trd:gamma-napredek} velja za vsak kontekst $\Gamma$, torej tudi za $\Gamma = \emptyset$.
\end{proof}


\begin{izrek}[o napredku]
	Naj za proces $P$ velja $\Gamma \types P \of C$. Potem ali (i) obstaja proces $P'$, tak da $P \reduces P'$, ali pa (ii) velja $\ProcResult{P}$.
\end{izrek}

\begin{proof}
	Ker ima proces $P$ tip, obstaja drevo izpeljave za njegov tip.
	Dokazujemo z indukcijo na globino drevesa izpeljave za procese.
	
	Za $n$ je $1$ imamo en sam primer ko je $P$ enak $\tmrun{M}$. Ker ima $M$ tip, po posledici~\ref{pos:prazen-napredek} velja da, ali lahko $M$ naredi korak v $M'$ ali pa je $M$ delni rezultat.
	Če $M$ lahko naredi korak v $M'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmrun{M'}$.
	Sicer je $M$ delna vrednost in ločimo dva primera.
	Če je $M$ enak $\tmopout{op}{V}{N}$, potem lahko $P$ naredi korak v $\tmopout{op}{V}{\tmrun{N}}$.
	Sicer je tudi $P$ rezultat.
	
	Sedaj pokažimo da, če velja trditev za $n = 1,...,n$ velja tudi za $n+1$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	Če je zadnje pravilo $TyProc-Par$, potem je $P$ enak $\tmpar{Q_1}{Q_2}$. Ker imata $Q_1$ in $Q_2$ tip, lahko po $IP$ naredita korak ali pa sta že rezultata.
	Če lahko eden izmed njiju naredi korak, recimo $Q_1$ lahko naredi korak v $Q_1'$, lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmpar{Q_1'}{Q_2}$. Podobno dokažemo, če lahko $Q_2$ naredi korak.
	Sicer sta $Q_1$ in $Q_2$ rezultata. Ločimo dva primera.
	Če je eden izmed njiju enak $\tmopout{op}{V}{Q'}$, recimo $Q_1$. Potem lahko $P$ naredi korak v $\tmopout{op}{V}{(\tmpair{Q'}{\tmopin{op}{V}{Q_2}})}$. Podobno za $Q_2$.
	Sicer je tudi $P$ rezultat.
	
	Če je zadnje pravilo $TyProc-Signal$, potem je $P$ enak $\tmopout{op}{V}{Q}$. Proces $Q$ ima tip in po $IP$ lahko naredi korak ali pa je rezultat.
	Če $Q$ lahko naredi korak v $Q'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmopout{op}{V}{Q'}$.
	Sicer je tudi $P$ rezultat.
	
	
	Če je zadnje pravilo $TyProc-Interrupt$, potem je $P$ enak $\tmopin{op}{V}{Q}$. Proces $Q$ ima tip in po $IP$ lahko naredi korak ali pa je rezultat.
	Če $Q$ lahko naredi korak v $Q'$, potem lahko po pravilu za evalvacijo v okolju tudi $P$ naredi korak v $\tmopin{op}{V}{Q'}$.
	Če pa je $Q$ rezultat ločimo tri primere.
	Če je $Q$ enak $\tmrun{M}$, potem lahko $P$ naredi korak v $\tmrun{\tmopin{op}{V}{M}}$.
	Če je $Q$ enak $\tmopout{op'}{V'}{Q'}$, potem lahko $P$ naredi korak v $\tmopout{op'}{V'}{(\tmopin{op}{V}{Q'})}$.
	Če je $Q$ enak $\tmpar{Q_1}{Q_2}$, potem lahko $P$ naredi korak v $\tmpar{\tmopin{op}{V}{Q_1}}{\tmopin{op}{V}{Q_2}}$.	
\end{proof}



\begin{lema}[o substituciji]
	Naj za vrednost $V$ velja $\Gamma \types V \of A$ in za izračun $M$ velja $\Gamma, x \of A \types M \of \tycomp{B}{\o, \i}$. Potem velja $\Gamma \types M[V/x] \of \tycomp{B}{\o, \i}$.
\end{lema}

\begin{proof}
	Ker ima izračun $M$ tip, obstaja drevo izpeljave za njegov tip.
	Dokazujemo z indukcijo na globino drevesa izpeljave za izračune.
	
	Za $n$ je $1$ imamo en sam primer, ko je $M$ enak $\tmreturn{W}$.
	Če je $W = x$, potem je $B = A$ in $M[V/x] = \tmreturn{V}$. Ker ima $V$ tip $A$, ima $\tmreturn{V}$ tip $\tycomp{A}{\o, \i}$. Ker je $A = B$, ima $M[V/x]$ tip $\tycomp{B}{\o, \i}$.
	Če je $W \neq x$, potem je $M[V/x] = M$ in posledično ima $M[V/x]$ tip $\tycomp{B}{\o, \i}$.
	
	Sedaj pokažimo da, če velja trditev za $n = 1,...,n$ velja tudi za $n+1$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	... TODO
\end{proof}

\begin{trditev}[o ohranitvi]
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$. Če izračun $M$ naredi korak v izračun $M'$, potem velja $\Gamma \types M' \of A'$, kjer je $A' = $.
\end{trditev}

\begin{proof}
	...
\end{proof}

\begin{izrek}[o ohranitvi]
	Naj za proces $P$ velja $\Gamma \types P \of C$. Če proces $P$ naredi korak v proces $P'$, potem velja $\Gamma \types P' \of C'$, kjer je $C' = $.
\end{izrek}

\begin{proof}
	...
\end{proof}