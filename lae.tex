\section{Račun \lae{}}\label{sec:lae}

Račun $\lambda$ je preprost teoretičen programski jezik. Leta 1930 ga je uvedel Alonzo Chuch z namenom formalizacije koncepta izračunljivosti~\cite{rojas2015tutorial}. Račun lambda je Turingovo poln.


Račun \lae{} je razširitev računa $\lambda$. Posledično je tudi \lae{}-račun Turingovo poln. Računu \lae{} dodamo izraze, ki poosebijo bistvo asinhrono vzporednega programiranja z pomočjo učinkov. Da \lae{}-račun čim bolj približamo vsakdanjim programskim jezikom, mu dodamo tudi izraze za  naravna števila, par, ujemanje vzorca...


\subsection{Izrazi}

Izraze v \lae{}-računu razdelimo na vrednosti, izračune in procese. 


Vrednosti so sledeče.
Konstante vrednosti naravna števila in logični vrednosti resnica in neresnica.
% TOLE DODAJ ČE BO MAGISTRSKA PREKRATKA DA BODO DALJŠI DOKAZI in nekatere aritmetične in logične funkcije kot so $+$, $-$, $*$, $/$, $=$, $<$...
Spremenljivke, ki so simbolična imena povezana z vrednostmi v danem kontekstu.
Enote in pare.
leve in desne inkluzije vsote.
Lambda abstrakcije.
Rekurzivne lambda abstrakcije.
Izpolnjena obljuba. Ta vrednost je edina zares nova. Je vrednost, ki jo je vrnil prestreznik in jo posebej označimo, da bomo kasneje lahko pravilno določili tip.


Izračuni so sledeči.
Vrni ki drži neko vrednost.
Zaporedje dveh izračunov.
Aplikacija ki v prvi izraz substituira drugi izraz.
Ujemanje ki glede na vzorec izraza izbere izračun. 
Signal vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prekinitev vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prestreznik vsebuje ime operacije, ime spremeljivke, Izračun M in izračun N.
blokada


Pripadajočo sintakso vidimo na~\ref{fig:izrazi} v Backus-Naurjevi obliki (BNF).



\begin{figure}[h]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\intertext{\textbf{Vrednosti}}
		V, W
		\bnfis& n \bnfor\! \true \bnfor\! \false        & &\text{konstantne vrednosti} \\
		\bnfor& x                                       & &\text{spremenljivka} \\
		\bnfor& \tmunit \bnfor\! \tmpair{V}{W}          & &\text{enota in par} \\
		\bnfor& \tminl[Y]{V} \bnfor\! \tminr[X]{V}      & &\text{leva in desna inkluzija} \\
		\bnfor& \tmfun{x}{M}                        & &\text{lambda} \\
		\bnfor& \tmfunrec{f}{x : X}{M}                        & &\text{rekurzivna lambda} \\
		\bnfor& \tmpromise V                            & &\text{izpolnjena obljuba}
		\\[1ex]
		\intertext{\textbf{Izračuni}}
		M, N
		\bnfis& \tmreturn{V}                            & &\text{vrnjena vrednost} \\
		\bnfor& \tmlet{x}{M}{N}                         & &\text{zaporedje} \\
	%	\bnfor& \tmletrec[: \tyfun{X}{Y}]{f}{x}{M}{N} & &\text{rekurzivna definicija} \\
		\bnfor& V\,W                                    & &\text{aplikacija} \\
		\bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    & &\text{ujemanje produkta} \\
		\bnfor& \tmmatch[]{V}{}                        & &\text{prazno ujemanje} \\
		\bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}	& &\text{ujemanje vsote} \\
		\bnfor& \tmopout{op}{V}{M}       & &\text{signal} \\
		\bnfor& \tmopin{op}{V}{M}          & &\text{prekinitev} \\
		\bnfor& \tmwith{op}{x}{M}{p}{N}      & &\text{prestreznik} \\
		\bnfor& \tmawait{V}{x}{M}             & &\text{blokada}
			\\[1ex]
		\intertext{\textbf{Procesi}}
	%	P \bnfis & ...
		  P, Q
		\bnfis & \tmrun M & & \text{run} \\
		\bnfor & \tmpar P Q & & \text{vzporedna procesa} \\
		\bnfor & \tmopout{op}{V}{P} & & \text{proces signal} \\
		\bnfor & \tmopin{op}{V}{P} & & \text{proces prekinitev}
		\end{align*}
	} 
	\caption{Vrednosti, izračuni in procesi.}
	\label{fig:izrazi}
\end{figure}


\subsection{Operacijska semantika}

Račun \lae\ opremimo z operacijsko semantiko malih korakov, ki je definirana z relacijo korak $M \reduces N$. Redukcijska pravila za izračune so podana na sliki~\ref{fig:small-step-semantics-of-computations}. Redukcijska pravila za procese so podana na sliki~\ref{fig:small-step-semantics-of-processes}.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Pravila osnovnih izračunov}}
	\tmapp{(\tmfun{x \of X}{M})}{V} &\reduces M[V/x]
	\\
	\tmapp{(\tmfunrec{f}{x \of X}{M})}{V} &\reduces M[V/x, (\tmfunrec{f}{x \of X}{M})/f]
	\\
	\tmlet{x}{(\tmreturn V)}{N} &\reduces N[V/x]
	\\
	\tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto M} &\reduces M[V/x, W/y]
	\\
	\mathllap{\tmmatch{(\tminl[Y]{V})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	M[V/x]
	\\
	\mathllap{\tmmatch{(\tminr[X]{W})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	N[W/y]
	\\[1ex]
	\intertext{\textbf{Algebraičnost signala in prestreznika}}
	\tmlet{x}{(\tmopout{op}{V}{M})}{N} &\reduces \tmopout{op}{V}{\tmlet{x}{M}{N}}
	\\
	\tmlet{x}{(\tmwith{op}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwith{op}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\\[1ex]
	\intertext{\textbf{Komutativnost operacij}}
	\tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmopout{op'}{W}{M}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{M}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmreturn W} &\reduces \tmreturn W
	\\
	\tmopin{op}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}
	\\
	\tmopin{op'}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmwith{op}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\\[1ex]
	\intertext{\textbf{Čakanje na izpolnitev obljube}}
	\tmawait{\tmpromise V}{x}{M} &\reduces M[V/x]
	\\[-8ex]
	\end{align*}
	
	\begin{align*}
	\intertext{\textbf{Evalvacija v okolju}}
	\coopinfer{}{
		M \reduces N
	}{
		\E[M] \reduces \E[N]
	}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{kjer}}
	\text{$\E$}
	\bnfis [~]
	\bnfor \tmlet{x}{\E}{N}
	\bnfor \tmopout{op}{V}{\E}
	\bnfor \tmopin{op}{V}{\E} 
	\bnfor \tmwith{op}{x}{M}{p}{\E}
	\end{align*}
	
	\caption{Operacijska semantika malih korakov za izračune.}
	\label{fig:small-step-semantics-of-computations}
\end{figure}

\begin{figure}[h]
    \centering
	\small
	\begin{minipage}[t]{0.4\textwidth}
		\centering
		\begin{align*}
		\intertext{\textbf{Posamezen proces}}
		\coopinfer{}{
			M \reduces N
		}{
			\tmrun M \reduces \tmrun N
		}
		\end{align*}
	\end{minipage}
	\qquad
	\begin{align*}
	\intertext{\textbf{Prehod}}
	\tmrun {(\tmopout{op}{V}{M})}  &\reduces \tmopout{op}{V}{\tmrun M}
	\\
	\tmopin{op}{V}{\tmrun M} &\reduces \tmrun {(\tmopin{op}{V}{M})}
	\\[1ex]
	\intertext{\textbf{Oddajanje signala}}
	\tmpar{\tmopout{op}{V}{P}}{Q} &\reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
	\\
	\tmpar{P}{\tmopout{op}{V}{Q}} &\reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{P}}{Q}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmpar P Q} &\reduces \tmpar {\tmopin{op}{V}{P}} {\tmopin{op}{V}{Q}}
	\\[1ex]
	\intertext{\textbf{Komutativnost signala in prekinitve}}
	\tmopin{op}{V}{\tmopout{op'}{W}{P}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{P}}
	\end{align*}
	\vspace{-4ex}
	\begin{align*}
	\shortintertext{\quad\textbf{Evalvacija v okolju}}
	\quad
	\coopinfer{}{
		P \reduces Q
	}{
		\F[P] \reduces \F[Q]
	}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{kjer}}
	\text{$\F$}
	\bnfis& [~]
	\bnfor \tmpar \F Q \bnfor\! \tmpar P \F
	\bnfor \tmopout{op}{V}{\F}
	\bnfor \tmopin{op}{V}{\F}
	\end{align*}
	
	\caption{Operacijska semantika malih korakov za procese.}
	\label{fig:small-step-semantics-of-processes}
\end{figure}

Poleg teh pravil, ki so identična pravilom iz \cite{aeff}, dodamo še dve novi.
Prvo pravilo potegne blokado ven iz zaporedja. Drugo pravilo prestavi prekinitev takoj za blokado. Obe pravili skupaj dosežeta dvoje. Malenkost večji del prvotnega izračuna je postal asinhron. Kar nam lahko v primeru, da bo obljuba izpolnjena in bomo nadaljevali z izvajanjem tega dela, nekoliko pohitri izvajanje. Druga prednost pa je, da izračun, ki je v čakajočem stanju, se vedno začne z izračunom $\tmkw{Await}$. Posledično je prepoznati ali je izračun v čakajočem stanju trivialno in se bodo delni rezultati nekoliko poenostavili. 

Rezultati ostanejo enaki kot v \cite{aeff}.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
		\intertext{\textbf{Algebraičnost blokade}}
		\tmlet{x}{(\tmawait{V}{y}{M})}{N} & \reduces \tmawait{V}{y}{(\tmlet{x}{M}{N})}
		\\[1ex]
		\intertext{\textbf{Komutativnost blokade in prekinitve}}
		\tmopin{op}{V}{\tmawait{W}{x}{M}} &\reduces \tmawait{W}{x}{\tmopin{op}{V}{M}}
	\end{align*}
	
	\caption{Dodatni pravili operacijske semantike.}
	\label{fig:operacijska-semantika-poenostavitev}
\end{figure}

\subsection{Sistem tipov}


Da se izognemo nekaterim napakam ob izvajanju uvedemo sistem tipov.
Tipe ločimo na tipe za vrednosti, izračune in procese.
Večina vrednosti dobi standardne tipe, kot so naravno število, boolean, enota, par, vsota in funkcijski tip. 


%%Predolga/grda poved
Ker funkcijski tip označuje funkcijo, ki vzame argument in mu priredi izračun, le tej pa imajo, kot bomo kasneje videli, poleg standardnih tipov, še tipe za učinke, ima tudi funkcijski tip dodane tipe za učinke.


Dodatno za vrednost obljuba uvedemo tip \emph{obljuba} $\typromise{A}$. 
Tipom za vrednosti, ki ne vsebujejo funkcijskega tipa ali obljube, pravimo osnovni tipi. 


Izračunom poleg standardnega tipa dodamo še tipe signalov, ki jih lahko sprožimo, označene z $\o$ in tipe prekinitev, ki jih lahko prestrežemo, označene z $\i$.
Tipi učinkov $\o$ in $\i$ so elementi množice $O$ oziroma $I$.
Množica $\sig$ je množica vseh operacij, ki jih imamo na voljo.
Množica $O$ je preprosto potenčna množica množice $\sig$ in posledično $\o$ predstavlja množico signalov, ki jih izračun lahko sproži.

Ko prestrežemo neko prekinitev lahko ustrezen izračun obljuba začne sprožati nove signale in prestrezati nove prekinitve. Zato $I$ definiramo kot največjo fiksno točko preslikave $\omega$ definirane kot 
$$\Omega(X) = \sig \Rightarrow (O \times X)_\bot $$,
kjer je $\Rightarrow$ potenciranje, $\times$ je kartezični produkt in $(-)_\bot$ je dvig.


Tipi procesov so odvisni od tipov izračunov in posledično vsebujejo tipe učinkov.

Pravila za dodelitev tipa vidimo na sliki~\ref{fig:value-typing-rules} in~\ref{fig:computation-typing-rules}.


\begin{figure}[h]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\text{Osnovni tipi vrednosti $\bar{A}$, $\bar{B}$}
		\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\bar{A}}{\bar{B}} \,\bnfor\! \tysum{\bar{A}}{\bar{B}}
		\\%[1ex]
		\text{Tipi vrednosti $A$, $B$}
		\bnfis & \bar{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
		\\
		\text{Tip izračuna} \bnfis& \tycomp{A}{\o,\i}
		\\
		\text{Tip procesa \tyC, \tyD}  \bnfis & \tyrun{A}{\o, \i} \,\bnfor\! \typar{\tyC}{\tyD}
		\end{align*}
	} 
	\caption{Tipi izrazov}
	\label{fig:tipi}
\end{figure}

Vsaki operaciji priredimo nek tip, kot vidimo na sliki~\ref{fig:operacije}. Ker izračun 
$$ \tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} $$
lahko naredi korak v izračun
$$ \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}} $$,
je ključno da vrednost $V$ ne vsebuje spremenljivke $p$, saj v drugem izračunu spremenljivka $p$ v vrednosti $V$ ni več dobro definiran. Da zagotovimo, da vrednost $V$ ne vsebuje spremenljivke $p$, omejimo tipe, ki pripadajo operacijam, na osnovne tipe.

\begin{figure}[t]
	\centering
	\small
	\begin{align*}
	(op_1, \bar{A}_{op_1}),\, (op_2, \bar{A}_{op_2}),\, ... ,\, (op_n, \bar{A}_{op_k})
	\end{align*}
\vspace{-5ex}
	\caption{Operacije in pripadajoči osnovni tipi.}
	\label{fig:operacije}
\end{figure}



\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types n : int
		}
		\qquad
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types true : bool
		}
		\qquad
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types false : bool
		}
		\quad
		\coopinfer{Tip-Var}{
		}{
			\Gamma, x \of X, \Gamma' \types x : X
		}
		\quad
		\coopinfer{Tip-Unit}{
		}{
			\Gamma \types \tmunit : \tyunit
		}
		\\
		\coopinfer{Tip-Pair}{
			\Gamma \types V : X \\
			\Gamma \types W : Y
		}{
			\Gamma \types \tmpair{V}{W} : \typrod{X}{Y}
		}
		\quad
		\coopinfer{Tip-Promise}{
			\Gamma \types V : X
		}{
			\Gamma \types \tmpromise V : \typromise X
		}
		\quad
		\coopinfer{Tip-Inl}{
			\Gamma \types V : X
		}{
			\Gamma \types \tminl[Y]{V} : X + Y
		}
		\quad
		\coopinfer{Tip-Inr}{
			\Gamma \types W : Y
		}{
			\Gamma \types \tminr[X]{W} : X + Y
		}
		\\
		\coopinfer{Tip-Fun}{
			\Gamma, x \of X \types M : \tycomp{Y}{\o,\i}
		}{
			\Gamma \types \tmfun{x : X}{M} : \tyfun{X}{\tycomp{Y}{\o,\i}}
		}
		\quad
		\coopinfer{Tip-Fun-Rec}{
			\Gamma,f \of \tyfun{X}{\tycomp{Y}{\o,\i}}, x \of X \types M : \tycomp{Y}{\o,\i}
		}{
			\Gamma \types \tmfunrec{f}{x : X}{M} : \tyfun{X}{\tycomp{Y}{\o,\i}}
		}
	\end{mathpar}
	\caption{Pravila za izračun tipov za vrednosti.}
	\label{fig:value-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyComp-Return}{
			\Gamma \types V : X
		}{
			\Gamma \types \tmreturn{V} : \tycomp{X}{(\o,\i)} 
		}
		\qquad
		\coopinfer{TyComp-Let}{
			\Gamma \types M : \tycomp{X}{(\o,\i)}
			\\
			\Gamma, x \of X \types N : \tycomp{Y}{(\o,\i)} 
		}{												
			\Gamma \types
			\tmlet{x}{M}{N} : \tycomp{Y}{(\o,\i)}       
		}											
		\\
		\coopinfer{TyComp-Apply}{
			\Gamma \types V : \tyfun{X}{\tycomp{Y}{(\o,\i)}} \\
			\Gamma \types W : X
		}{
			\Gamma \types \tmapp{V}{W} : \tycomp{Y}{(\o,\i)}
		}
		\quad
		\coopinfer{TyComp-MatchPair}{
			\Gamma \types V : \typrod{X}{Y} \\
			\Gamma, x \of X, y \of Y \types M : \tycomp{Z}{(\o,\i)}
		}{
			\Gamma \types \tmmatch{V}{\tmpair{x}{y} \mapsto M} : \tycomp{Z}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-MatchEmpty}{
			\Gamma \types V : \tyempty
		}{
			\Gamma \types \tmmatch[\tycomp{Z}{(\o,\i)}]{V}{} : \tycomp{Z}{(\o,\i)}
		}
		\quad
		\coopinfer{TyComp-MatchSum}{
			\Gamma \types V : X + Y \\\\
			\Gamma, x \of X \types M : \tycomp{Z}{(\o,\i)} \\
			\Gamma, y \of Y \types N : \tycomp{Z}{(\o,\i)} \\
		}{
			\Gamma \types \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} : \tycomp{Z}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-Signal}{
			\op \in \o \\
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{X}{(\o,\i)} 
		}{
			\Gamma \types \tmopout{op}{V}{M} : \tycomp{X}{(\o,\i)}
		}
		\qquad
		\coopinfer{TyComp-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{X}{(\o,\i)} 
		}{
			\Gamma \types \tmopin{op}{V}{M} : \tycomp{X}{\opincomp {op} (\o,\i)}
		}
		\\
		\coopinfer{TyComp-Promise}{
			\i\, (\op) = ({\o'} , {\i'}) \\
			\Gamma, x \of A_\op \types M : \tycomp{\typromise X}{(\o',\i')} \\
			\Gamma, p \of \typromise X \types N : \tycomp{Y}{(\o,\i)} 
		}{
			\Gamma \types \tmwith{op}{x}{M}{p}{N} : \tycomp{Y}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-Await}{
			\Gamma \types V : \typromise X \\
			\Gamma, x \of X \types M : \tycomp{Y}{(\o,\i)} 
		}{
			\Gamma \types \tmawait{V}{x}{M} : \tycomp{Y}{(\o,\i)}
		}
		\qquad
		\coopinfer{TyComp-Subsume}{
			\Gamma \types M : \tycomp{X}{(\o, \i)} \\
			(\o,\i) \order {O \times I} (\o',\i')
		}{
			\Gamma \types M : \tycomp{X}{(\o', \i')}
		}
	\end{mathpar}
	\caption{Pravila za izračun tipov za izračune.}
	\label{fig:computation-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyProc-Run}{
			\Gamma \types M : \tycomp{X}{\o,\i}
		}{
			\Gamma \types \tmrun{M} : \tyrun{X}{\o, \i}
		}
		\quad
		\coopinfer{TyProc-Par}{
			\Gamma \types P : \tyC \\
			\Gamma \types Q : \tyD
		}{
			\Gamma \types \tmpar{P}{Q} : \typar{\tyC}{\tyD}
		}
		\\
		\coopinfer{TyProc-Signal}{
			\op \in \mathsf{signals\text{-}of}{(\tyC)} \\\\
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopout{op}{V}{P} : \tyC
		}
		\quad
		\coopinfer{TyProc-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopin{op}{V}{P} : \opincomp{op}{\tyC}
		}  
	\end{mathpar}
	\caption{Pravila za izračun tipov za procese.}
	\label{fig:process-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering

%	\textbf{Čakajoči izrazi}
%	\begin{mathpar}
%		\coopinfer{}{
%		}{
%			\awaiting p {\tmawait p x M}
%		}
%		\quad
%		\coopinfer{}{
%			\awaiting p M
%		}{
%			\awaiting p {\tmlet x M N}
%		}
%		\quad
%		\coopinfer{}{
%			\awaiting p M
%		}{
%			\awaiting p {\tmopin{op}{V}{M}}
%		}
%	\end{mathpar}
	
	\textbf{Delni rezultati}
	\begin{mathpar}
		\coopinfer{}{
		}{
			\RunResult {\Psi} {\tmreturn V}
		}
		\\
		\coopinfer{}{
			\RunResult {\Psi \cup \{p\}} {N}
		}{
			\RunResult {\Psi} {\tmwith {op} x M p N}
		}
		\qquad
		\coopinfer{}{
			p \in \Psi
		}{
			\RunResult {\Psi} {\tmawait{p}{x}{M}}
		}
	\end{mathpar}

	\textbf{Rezultati}
	\begin{mathpar}
		\coopinfer{}{
			\ProcResult {P}
		}{
			\ProcResult {\tmopout {op} V P}
		}
		\qquad
		\coopinfer{}{
			\ParResult {P}
		}{
			\ProcResult {P}
		}
		\\
		\coopinfer{}{
			\ParResult P \\
			\ParResult Q
		}{
			\ParResult {\tmpar P Q}
		}
		\qquad
		\coopinfer{}{
			\RunResult {\emptyset} {M}
		}{
			\ParResult {\tmrun M}
		}
	\end{mathpar}
	\caption{Rezultati in delni rezultati.}
	\label{fig:results-rules}
\end{figure}


Izrek o varnosti, ki je sestavljen iz izreka o ohranitvi in izreka o napredku nam zagotavlja, da ne moremo dobiti runtime, če imamo tipe, kot smo jih definirali.



\begin{trditev}[o napredku]
	Naj za izračun $M$ velja $\emptyset \types M \of \tycomp{A}{\o, \i}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\RunResult{\emptyset}{M}$.

	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$, kjer je $\Gamma = \{(x_1,\typromise{A_1}),(x_2,\typromise{A_2}),...,(x_i,\typromise{A_i})\}$. Potem ali (i) obstaja izračun $M'$, tak da $M \reduces M'$, ali pa (ii) velja $\RunResult{\emptyset}{M}$.
\end{trditev}

\begin{proof}
	Osnutek
	
	
	Ker ima izračun $M$ tip, obstaja drevo izpeljave za tip.
	Dokazujemo z indukcijo na globino drevesa izpeljave za izračune.
	
	Za $n$ je $1$ ločimo dva primera glede na uporabljeno pravilo v drevesu izpeljave.
	Če je $M = \tmreturn{V}$, potem po pravilu XYZ??? %Kako naj poimenujem pravila, korake... da se lahko kasneje sklicujem nanje???
	sledi, da je $M$ delni rezultat in velja (ii).
	Če je $M = V W$, potem mora biti $V$ oblike $\tmfunano{x}{M}$ ali $\tmfunrecano{f}{x}{M}$ in lahko naredimo korak v $M[W/x]$ ali $M[V/x, (\tmfunrec{f}{x \of X}{M})/f]$.
	
	Sedaj pokažimo da, če velja trditev za $n = 1,...,n$ velja tudi za $n+1$.
	Ločimo primere glede na zadnje uporabljeno pravilo.
	
	Če je zadnje pravilo $TyComp-Let$ potem ima $M$ %Kako naj ločim M iz trditve in M iz let M in N???
	tip in po $IP$ lahko naredi korak ali pa je delni rezultat. Če $M$ lahko naredi korak v $M'$ potem lahko po pravilu za evalvacijo v okolju tudi $M$ naredi korak.
	Če pa je $M$ delni rezultat ločimo tri možnosti. Če je $M = return V$ potem lahko naredimo korak v $N[V/x]$. V drugih dveh primerih lahko uporabimo algebraičnost prestreznika ali blokade in naredimo ustrezen korak. 
	
	Če je zadnje pravilo $TyComp-MatchPair$ potem je $V$ oblike $(V,W)$ in posledično lahko naredimo korak XYZ.
	
	Če je zadnje pravilo $TyComp-MatchEmpty$ %Nimamo pravila za V : 0: Zakaj bi potem imeli to pravilo???
	
	Če je zadnje pravilo $TyComp-MatchSum$ potem je $V$ ali oblike $inl_YV$ in lahko naredimo korak XYZ ali pa je oblike $inr_XV$ in lahko naredimo korak XYZ.
	
	Če je zadnje pravilo $TyComp-Signal$ %Tukaj bi morali signal prenesti iz izračuna na proces, ampak ker smo ločili izračune in procese tega ne moremo narediti? Naj združim nazaj v samo en izrek? Se da lepše formulirati trditev da bo vredu? Lahko v trditvi rečem da M ne sme biti signal. In potem v izreku za procese ta primer posebej obravnavam???
	
	Če je zadnje pravilo $TyComp-Interupt$ potem ima $M$ tip in po indukcijski predpostavki lahko $M$ naredi korak ali pa je delna vrednost. Če $M$ lahko naredi korak v $M'$ potem lahko po pravilu za evalvacijo v okolju tudi $M$ naredi korak. Če pa je $M$ delni rezultat ločimo tri možnosti. Če je $M = return V$ potem lahko naredimo korak v $M$. Če je $M = \tmwith{op'}{x}{M}{p}{N}$ naredimo ali korak XYZ ali XYZ glede na to ali velja $op = op'$.
	Tretja možnost se ne more zgodi saj je pripadajoči $\psi = \emptyset$.
	
	Če je zadnje pravilo $TyComp-promise$ potem ima $M$ tip in po indukcijski predpostavki lahko $M$ naredi korak ali pa je delna vrednost. Če $M$ lahko naredi korak v $M'$ potem lahko po pravilu za evalvacijo v okolju tudi $M$ naredi korak. Če pa je $M$ delni rezultat je tudi $M$ delni rezultat.
	
	Če je zadnje pravilo $TyComp-Await$, potem mora biti $V = <V>$ saj smo v praznem kontekstu. Tedaj lahko naredimo korak XYZ.
	
	Če je zadnje pravilo $TyComp-Subsume$ je $M$ po IP ali rezultat ali pa lahko naredi korak.
	
	%Nenehno se ponavlja "Če je zadnje pravilo...", "Ločimo primere ..." ... Glede na to da je to dokaz, ki mora biti čim bolj pregleden in razumljiv, ne pa estetsko oblikovan je to vredu??? 
	
	
	
	
\end{proof}


\begin{izrek}[o napredku]
	Naj za proces $P$ velja $\Gamma \types P \of C$. Potem ali (i) obstaja proces $P'$, tak da $P \reduces P'$, ali pa (ii) velja $\ProcResult{P}$.
\end{izrek}

\begin{proof}
	Če je izraz $M$ rezultat smo končali. Sicer dokazujemo 
\end{proof}



\begin{lema}[o substituciji]
	Naj za vrednost $V$ velja $\Gamma \types V \of A$ in za izračun $M$ velja $\Gamma, x \of A \types M \of \tycomp{B}{\o, \i}$. Potem velja $\Gamma \types M[V/x] \of \tycomp{B}{\o, \i}$.
\end{lema}

\begin{proof}
	...
\end{proof}

\begin{trditev}[o ohranitvi]
	Naj za izračun $M$ velja $\Gamma \types M \of \tycomp{A}{\o, \i}$. Če izračun $M$ naredi korak v izračun $M'$, potem velja $\Gamma \types M' \of A'$, kjer je $A' = $.
\end{trditev}

\begin{proof}
	...
\end{proof}

\begin{izrek}[o ohranitvi]
	Naj za proces $P$ velja $\Gamma \types P \of C$. Če proces $P$ naredi korak v proces $P'$, potem velja $\Gamma \types P' \of C'$, kjer je $C' = $.
\end{izrek}

\begin{proof}
	...
\end{proof}