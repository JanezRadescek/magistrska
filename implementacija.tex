\section{Zaključek}\label{sec:konec}

Medtem ko je cilj \lae-računa, da pokaže pravilnost asinhronih konceptov prikazanih v prejšnjih poglavjih, je cilj jezika \aeff{}, da te koncepte lahko tudi preizkusimo. Zato ima jezik \aeff{} določene stvari, ki jih \lae-račun nima.

Jezik \aeff{} je implementiran v jeziku Ocaml. Implementacija je sestavljena iz treh glavnih delov.
Parserja, ki prevede tekst v abstraktno sintaktično drevo (AST) in preveri ustreznost sintakse.  
Type checkerja, ki preveri, da ima dani program tip.
In tolmača, ki izvaja korake, dokler ne pridemo do rezultata.

\subsection{Dodatni izrazi}

Da \aeff{} postane bolj uporaben so mu dodane konstantni vrednosti $\true$ in $\false$, funkcije kot so $+, -, *, / ...$, reference in globalne spremenljivke.

Izračun $\tmkw{if}\ V\ \tmkw{then}\ M\ \tmkw{else}\ N$ je sintaktičen sladkor za $\tmmatch{V}{\true \mapsto M, \false \mapsto N}$.

Izračun $M;N$ je sintaktičen sladkor za $\tmlet{\_}{M}{N}$, ki ga lahko uporabimo kadar rezultat izračuna $M$ ni uporabljen v $N$.

Kot sintaktični sladkor je dodan varovan prestreznik, ki se sproži le kadar je poleg prave operacije tudi pravi pripadajoči tovor.
\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Sintaksa}}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmwithrecgu{op}{x}{r}{P(x)}{M}{p}{N}  & &\text{varovan rekurzivni prestreznik}
	\end{align*}
	
	\begin{align*}
	\intertext{\textbf{Semantika}}
	\tmopin{op}{V}{\tmwithrecgu{op}{x}{r}{P}{M}{p}{N}} \\ \reduces \tmlet{p}{(\ite{P[V/x]}{M[V/x, R/r]}{R\,()})}{\tmopin{op}{V}{N}} \\
	{\color{rulenameColor}R = \tmfunano{y}{(\tmwithrecgu{op}{x}{r}{P}{M}{p}{\tmreturn{p}})}}
	\end{align*}
	
	\caption{Varovan rekurzivni prestreznik}
	\label{fig:izrazi-varovan-prestreznik}
\end{figure}

\subsection{Sistem tipov}\label{sec:tipi}

Prvotna implementacija jezika \aeff izračuna tip programa z Hindley–Milnerjevim algoritmom. 
Kasneje je bil typechecker spremenjen, da je uporabljal dvosmerni sistem tipov (bidirectional typing), ki temelji na algoritmu iz članka~\cite{bidirectional}.
Glavna ideja dvosmernega sistema tipov je, da lahko dinamično izmenjuje med preverjanjem in računanjem tipa. Kadar so tipi pripisani izrazom, tip le preverimo, kar je enostavneje, kot ga izračunati in v primeru napake lahko izpiše boljše poročilo o napaki. Vendar pa pripisovanje tipov ni obvezno in ga v tem primeru lahko izračunamo. Posledično lahko uporabnik, poda tip le nekaterim delom programa, preostalim pa ne.

\subsection{Tolmač}\label{sec:interpreter}

Čeprav ima \aeff{} možnost vzporednega izvajanja in smo to do sedaj v primerih programov predpostavljali, sama implementacije zaenkrat le simulira vzporedno izvajanje.


\section*{Slovar strokovnih izrazov}



\geslo{await}{blokada}
\geslo{bidirectional type system}{dvosmerni sistem tipov}
\geslo{boxed type}{zavit tip}
\geslo{ground type}{osnovni tip}
\geslo{handler}{prestreznik}
\geslo{interrupt}{prekinitev}
\geslo{mobile type}{prenosljiv tip}
\geslo{promise}{obljuba}
\geslo{signal}{signal}
\geslo{spawn}{dinamični proces}
\geslo{unbox}{odvijanje}


%guarded promise = varovana obljuba
%abstraction = abstrakcija
%spawn =  ustvaritev novega procesa
%interpreter = tolmač
%type sistem = sistem tipov
%computation = izračun
%calculus = račun
%unit = enota
%Syntactic sugar = sintaktičen sladkor
%black box in types = kocka 
%recursion = rekurzija
%bidirectional = dvosmerni?
%small step semantics = op. sem. malih korakov
%pattern matching = ujemanje vzorca
%substitution = substitucija
%substitute = substituirati
%source code = izvorna koda
%machine code = strojna koda
%shared memory = skupni spomin
%context = kontekst
%true/false = resnica/neresnica
%runtime error = napaka ob izvajanju
%typing rules = pravila za tipe
%interupt propagation = širitev prekinitve
%signal hoisting = dvig signala
%broadcasting = oddajanje signala
%evaluation context rule = Vrednotenje v kontekstu
%turing complete = turingovo poln
