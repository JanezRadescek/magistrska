\section{Zaključek}\label{sec:konec}

Medtem ko je cilj \lae-računa, da pokaže pravilnost asinhronih konceptov prikazanih v prejšnjih poglavjih, je cilj jezika \aeff{}, da te koncepte lahko tudi preizkusimo in uporabimo. Zato ima jezik \aeff{} določene stvari, ki jih \lae-račun nima.

Jezik \aeff{} je implementiran v jeziku Ocaml. Implementacija je sestavljena iz treh glavnih delov.
Parserja, ki prevede tekst v abstraktno sintaktično drevo (AST) in preveri ustreznost sintakse.  
Pregledovalnika tipov, ki preveri, da ima dani program tip.
In tolmača, ki izvaja korake, dokler ne pride do rezultata.

\subsection{Izrazi}

Da \aeff{} postane bolj uporaben so mu dodane konstantni vrednosti $\true$ in $\false$, funkcije kot so $+, -, *, / ...$, reference in globalne spremenljivke.

Izračun $\tmkw{if}\ V\ \tmkw{then}\ M\ \tmkw{else}\ N$ je sintaktičen sladkor za $\tmmatch{V}{\true \mapsto M, \false \mapsto N}$.

Izračun $\uparrow\hspace{-1ex}\op (V);M$ je sintaktičen sladkor za $\tmlet{\_}{\tmopout{op}{V}{return ()}}{M}$.
Podobno je $\tmkw{spawn}(M);N$ sintaktičen sladkor za $\tmlet{\_}{\tmspawn{M}{return ()}}{N}$. 
%Izračun $M;N$ je sintaktičen sladkor za $\tmlet{\_}{M}{N}$, ki ga lahko uporabimo kadar rezultat izračuna $M$ ni uporabljen v $N$.

Varovan prestreznik $$\tmwithrecgu{op}{x}{r}{P(x)}{M}{p}{N},$$ je sintaktičen sladkor za $$\tmwithrec{op}{x}{r}{\tmif{P(x)}{M}{r()}}{p}{N}.$$
Nanj lahko gledamo kot na prestreznik, ki se sproži, le kadar je poleg pravega imena operacije tudi pravi tovor.

Dodamo tudi seznam. Za prazen seznam uporabimo konstruktor []. Elementa mu lahko dodajamo z $::$, recimo 1::2::3::[].
Sedaj imamo problem, ker uporabljamo [] tako za sezname kot za zavite vrednosti.
V poglavju~\ref{sec:razsirjen-lae}, kjer v dveh primerih uporabimo seznam, nadomestimo konstruktor za prazen seznam z $\mathsf{nil}$ in ohranimo [] za zavite vrednosti, ki so bistvene v tem delu.
Nasprotno v dejanski implementaciji \aeff{} raje ohranimo [] za prazen seznam in spremenimo sintakso zavite vrednosti v $[|V|]$. 


\subsection{Sistem tipov}\label{sec:tipi}

Prvotna implementacija jezika \aeff{} izračuna tip programa z Hindley–Milnerjevim algoritmom. 
Kasneje je bil typechecker spremenjen, da je uporabljal dvosmerni sistem tipov (bidirectional typing), ki temelji na algoritmu iz članka~\cite{bidirectional}.
Glavna ideja dvosmernega sistema tipov je, da lahko dinamično izmenjuje med preverjanjem in računanjem tipa. Kadar so tipi pripisani izrazom, tip le preverimo, kar je enostavneje, kot ga izračunati in v primeru napake lahko izpiše boljše poročilo o napaki. Vendar pa pripisovanje tipov ni obvezno in ga v tem primeru lahko izračunamo. Posledično lahko uporabnik, poda tip le nekaterim delom programa, preostalim pa ne.

\subsection{Tolmač}\label{sec:interpreter}

Čeprav ima \aeff{} možnost vzporednega izvajanja in smo to do sedaj v primerih programov predpostavljali, sama implementacije zaenkrat le simulira vzporedno izvajanje.


\section*{Slovar strokovnih izrazov}



\geslo{await}{blokada}
\geslo{bidirectional type system}{dvosmerni sistem tipov}
\geslo{boxed type}{zavit tip}
\geslo{ground type}{osnovni tip}
\geslo{handler}{prestreznik}
\geslo{interrupt}{prekinitev}
\geslo{mobile type}{prenosljiv tip}
\geslo{promise}{obljuba}
\geslo{signal}{signal}
\geslo{spawn}{dinamični proces}
\geslo{unbox}{odvijanje}


%guarded promise = varovana obljuba
%abstraction = abstrakcija
%spawn =  ustvaritev novega procesa
%interpreter = tolmač
%type sistem = sistem tipov
%computation = izračun
%calculus = račun
%unit = enota
%Syntactic sugar = sintaktičen sladkor
%black box in types = kocka 
%recursion = rekurzija
%bidirectional = dvosmerni?
%small step semantics = op. sem. malih korakov
%pattern matching = ujemanje vzorca
%substitution = substitucija
%substitute = substituirati
%source code = izvorna koda
%machine code = strojna koda
%shared memory = skupni spomin
%context = kontekst
%true/false = resnica/neresnica
%runtime error = napaka ob izvajanju
%typing rules = pravila za tipe
%interupt propagation = širitev prekinitve
%signal hoisting = dvig signala
%broadcasting = oddajanje signala
%evaluation context rule = Vrednotenje v kontekstu
%turing complete = turingovo poln
