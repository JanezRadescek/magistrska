% !TeX spellcheck = sl_SI
% vim: set spell spelllang=sl:
% za preverjanje črkovanja, če se uporablja Texstudio ali vim
\documentclass[12pt,a4paper,twoside]{article}
\usepackage[utf8]{inputenc}  % pravilno razpoznavanje unicode znakov

% NASLEDNJE UKAZE USTREZNO POPRAVI
\newcommand{\program}{Matematika} % ime studijskega programa
\newcommand{\imeavtorja}{Janez~Radešček} % ime avtorja
\newcommand{\imementorja}{doc.~dr.~Pretnar~Matija} % akademski naziv in ime mentorja, uporabi poln naziv, prof.~dr.~, doc.~dr., ali izr.~prof.~dr.
\newcommand{\imesomentorja}{asist.~raz.~dr.~Danel~Ahman} % akademski naziv in ime somentorja, če ga imate
\newcommand{\naslovdela}{Asinhroni algebrajski učinki}
\newcommand{\letnica}{2021} % letnica magistriranja
\newcommand{\opis}{Delo obravnava integracijo po ω-kompleksih, njene lastnosti in posplošitve
na Levy-jeve topološke prostore.}  % Opis dela v eni povedi. Ne sme vsebovati matematičnih simbolov v $ $.
\newcommand{\kljucnebesede}{integracija\sep kompleks} % ključne besede, ločene z \sep, da se PDF metapodatki prav procesirajo
\newcommand{\keywords}{integration\sep complex} % ključne besede v angleščini
\newcommand{\organization}{Univerza v Ljubljani, Fakulteta za matematiko in fiziko} % fakulteta
\newcommand{\literatura}{literatura}  % pot do datoteke z literaturo (brez .bib končnice)
\newcommand{\sep}{, }  % separator med ključnimi besedami v besedilu
% KONEC PODATKOV

\usepackage{bibentry}         % za navajanje literature v programu dela s celim imenom
\nobibliography{\literatura}
\newcommand{\plancite}[1]{\item[\cite{#1}] \bibentry{#1}} % citiranje v programu dela

\usepackage{filecontents}  % za pisanje datoteke s PDF metapodatki
\usepackage{silence} \WarningFilter{latex}{Overwriting file}  % odstrani annoying warning o obstoju datoteke
% datoteka s PDF metapodatki, zgenerira se kot magisterij.xmpdata
\begin{filecontents*}{\jobname.xmpdata}
  \Title{\naslovdela}
  \Author{\imeavtorja}
  \Keywords{\kljucnebesede}
  \Subject{matematika}
  \Org{\organization}
\end{filecontents*}

\usepackage[a-1b]{pdfx}  % zgenerira PDF v tem PDF/A-1b formatu, kot zahteva knjižnica
\hypersetup{bookmarksopen, bookmarksdepth=3, colorlinks=true,
  linkcolor=black, anchorcolor=black, citecolor=black, filecolor=black,
  menucolor=black, runcolor=black, urlcolor=black, pdfencoding=auto,
  breaklinks=true, psdextra}

\usepackage[slovene]{babel}  % slovenščina
\usepackage[T1]{fontenc}     % naprednejše kodiranje fonta
\usepackage{amsmath,amssymb,amsfonts,amsthm} % matematični paketi
\usepackage{graphicx}     % za slike
\usepackage{emptypage}    % prazne strani so neoštevilčene, ampak so štete
%\usepackage{units}        % fizikalne enote kot \unit[12]{kg} s polovico nedeljivega presledka, glej primer v kodi
\usepackage{makeidx}      % za stvarno kazalo, lahko zakomentiraš, če ne rabiš
\makeindex                % za stvarno kazalo, lahko zakomentiraš, če ne rabiš
% oblika strani
\usepackage[
  top=3cm,
  bottom=3cm,
  inner=3.5cm,      % margini za dvostransko tiskanje
  outer=2.5cm,
  footskip=40pt     % pozicija številke strani
]{geometry}



% DRUGI TVOJI PAKETI:

\usepackage{mathpartir} % inference rules
\usepackage{mathtools} % mathllap

\usepackage{listings}
\renewcommand{\lstlistingname}{Program}% Listing -> Program
\renewcommand{\lstlistlistingname}{Kazalo Programov}% List of Listings -> Kazalo Programov

\usepackage{float}

\input{macros.tex}



% todo notes to comment the code when working in a group
\usepackage{todonotes}
\definecolor{jcyan}{cmyk}{1, 0, 0.15, 0.05}
\newcommand\mP[1]{\todo[inline,color=red]{#1 -MP}}	% comments by matija
\newcommand\jR[1]{\todo[inline,color=jcyan]{#1 -JR}} % comments by janez


\setlength{\overfullrule}{50pt} % označi predlogo vrstico
\pagestyle{plain}               % samo številka strani na dnu, nobene glave / noge

% ukazi za matematična okolja
\theoremstyle{definition} % tekst napisan pokončno
\newtheorem{definicija}{Definicija}[section]
\newtheorem{primer}[definicija]{Primer}
\newtheorem{opomba}[definicija]{Opomba}
\newtheorem{aksiom}{Aksiom}

\theoremstyle{plain} % tekst napisan poševno
\newtheorem{lema}[definicija]{Lema}
\newtheorem{izrek}[definicija]{Izrek}
\newtheorem{trditev}[definicija]{Trditev}
\newtheorem{posledica}[definicija]{Posledica}

\numberwithin{equation}{section}  % števec za enačbe zgleda kot (2.7) in se resetira v vsakem poglavju



% bold matematika znotraj \textbf{ }, tudi v naslovih, kot \omega spodaj
\makeatletter \g@addto@macro\bfseries{\boldmath} \makeatother

% Poimenuj kazalo slik kot ``Kazalo slik'' in ne ``Slike''
\addto\captionsslovene{
  \renewcommand{\listfigurename}{Kazalo slik}%
}

% če želiš, da se poglavja začnejo na lihih straneh zgoraj
% \let\oldsection\section
% \def\section{\cleardoublepage\oldsection}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%           DOCUMENT           %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\pagenumbering{roman} % začnemo z rimskimi številkami
\thispagestyle{empty} % ampak na prvi strani ni številke

\noindent{\large
UNIVERZA V LJUBLJANI\\[1mm]
FAKULTETA ZA MATEMATIKO IN FIZIKO\\[5mm]
\program\ -- 2.~stopnja}
% ustrezno dopolni za IŠRM
\vfill

\begin{center}
  \large
  \imeavtorja\\[3mm]
  \Large
  \textbf{\MakeUppercase{\naslovdela}}\\[10mm]
  \large
  Magistrsko delo \\[1cm]
  Mentor: \imementorja \\[2mm] % ustrezno popravi spol
  Somentor: \imesomentorja   % dodaj, če potrebno
\end{center}
\vfill

\noindent{\large Ljubljana, \letnica}

\cleardoublepage

%% sem pride IZJAVA O AVTORSTVU  -- SE NATISNE V VIS

% zahvala
\pdfbookmark[1]{Zahvala}{zahvala} %
\section*{Zahvala}
Neobvezno.
Zahvaljujem se \dots
% end zahvala -- izbriši vse med zahvala in end zahvala, če je ne rabiš

\cleardoublepage

\pdfbookmark[1]{\contentsname}{kazalo-vsebine}
\tableofcontents

% list of figures
% \cleardoublepage
% \pdfbookmark[1]{\listfigurename}{kazalo-slik}
% \listoffigures
% end list of figures

\cleardoublepage

\section*{Program dela}
\addcontentsline{toc}{section}{Program dela} % dodajmo v kazalo
%Mentor naj napiše program dela skupaj z osnovno literaturo. Na literaturo se
%lahko sklicuje kot~\cite{lebedev2009introduction}, \cite{gurtin1982introduction},
%\cite{zienkiewicz2000finite}, \cite{STtemplate}.

\section*{Osnovna literatura}
%Literatura mora biti tukaj posebej samostojno navedena (po pomembnosti) in ne
%le citirana. V tem razdelku literature ne oštevilčimo po svoje, ampak uporabljamo
%okolje itemize in ukaz plancite, saj je celotna literatura oštevilčena na koncu.
\begin{itemize}
  \plancite{STtemplate}
\end{itemize}

\vspace{2cm}
\hspace*{\fill} Podpis mentorja: \phantom{prostor za podpis}

 \vspace{2cm}
 \hspace*{\fill} Podpis somentorja: \phantom{prostor za podpis}

\cleardoublepage
\pdfbookmark[1]{Povzetek}{abstract}

\begin{center}
\textbf{\naslovdela} \\[3mm]
\textsc{Povzetek} \\[2mm]
\end{center}
%Tukaj napišemo povzetek vsebine. Sem sodi razlaga vsebine in ne opis tega, kako je delo
%organizirano.
V delu si pogledamo programski jezik \aeff\ in račun \lae\ na katerem temelji. Račun \lae razširimo z rekurzivno obljubo, razcepom in \jR{Box/Unbox}. \jR{Ground} tipe nadomestimo z mobilnimi tipi, ki nam omogočajo pošiljanje tipov za katere prej nebi zmogli pokazati da so varni. Obstoječi sistem tipov nadomestimo z dvostranskim sistemom, ki predvsem izboljša sporočila v primeru napak. Dokažemo izreka o napredku in ohranitvi za razširjen \lae. Ne deterministično operacijsko semantiko malih korakov nadomestimo z deterministično \jR{big.SMALL kak} semantiko in pokažemo, da je prejšnji v nekem smislu ekvivalentna.



\vfill
\begin{center}
\textbf{English translation of the title} \\[3mm] % prevod slovenskega naslova dela
\textsc{Abstract}\\[2mm]
\end{center}

%An abstract of the work is written here. This includes a short description of
%the content and not the structure of your work.
TODO

\vfill\noindent
\textbf{Math.~Subj.~Class.~(2010):} oznake kot 74B05, 65N99, na voljo so na naslovu
\url{http://www.ams.org/msc/msc2010.html} \\[1mm]
\textbf{Ključne besede:} \kljucnebesede \\[1mm]
\textbf{Keywords:} \keywords

\cleardoublepage

\setcounter{page}{1}    % od sedaj naprej začni zopet z 1
\pagenumbering{arabic}  % in z arabskimi številkami


%Slovar
%promise = obljuba
%guarded promise = varovana obljuba
%abstraction = abstrakcija
%spawn =  ??
%interpreter = tolmač
%type sistem = sistem tipov
%computation = izračun
%calculus = račun
%unit = enota
%Syntactic sugar = sintaktičen sladkor
%if computation/statement = če izračun
%parallel = vzporedno (Fizična implementacija ni tako bistvena)Logika program je razdeljena v več bolj ali manj neodvisnih enot threadov/procesov.)
%thread = nit
%payload = tovor
%Ground type = osnovni
%mobile = prenosljiv
%boxed type = zavit tip
%unbox = odvijanje   , ,zavijanje,
%black box in types = kocka 
%recursion = rekurzija
%bidirectional = dvosmerni?
%small step semantics = op. sem. malih korakov
%signal = signal
%interrupt = prekinitev
%handler = prestreznik
%pattern matching = ujemanje vzorca
%substitution = substitucija
%substitute = substituirati
%await = blokada
%source code = izvorna koda
%machine code = strojna koda
%shared memory = skupni spomin
%race condition = ??
%context = kontekst
%true/false = resnica/neresnica
%runtime error = ??
%Partition of a set = partiticija množice ?? https://en.wikipedia.org/wiki/Partition_of_a_set
%typing rules = pravila za tipe
%interupt propagation = širitev prekinitve
%signal hoisting = dvig signala
%broadcasting = oddajanje signala
%evaluation context rule = Vrednotenje v kontekstu
%turing complete = ??


%prevajaj vse razen sintakse na slikcah.
%Katere izreke/trditve si želimo od \lae? varnost in vse potrebno za dokaz le tega.
%prevajam tudi sintakso? NE
%Katere stvari lahko v magistrski predpostavim, da se jih ve? poglej kaj je že bilo v prejšnjih magistrskih
%Zakaj se tipi pojavijo že tukaj, če do tipov še nismo prišli? They are part of syntax. They dont have semantics yet

\section{Uvod} \label{sec:uvod}
%Napišite kratek zgodovinski in matematični uvod.  Pojasnite motivacijo za problem, kje
%nastopa, kje vse je bil obravnavan. Na koncu opišite tudi organizacijo dela -- kaj je v
%katerem razdelku.


Če zelo poenostavimo postopek nastajanja program, potem nastane tako, da se v programskem jeziku napiše zaporedje ukazov, ki se jih izvaja enega za drugim. Program $P$ lahko predstavimo z urejeno $n$-terico 
$$P = (k^1, k^2,..., k^n).$$ 
Izvajanje $I_s(P)$ je vrstni red v katerem se izvaja korake in ga lahko predstavimo z urejeno $n$-terico
$$I_s(P) = (k_1^{\pi(1)}, k_2^{\pi(2)},..., k_n^{\pi(n)}),\ k_i^{\pi(i)} = k^{\pi(i)}.$$
Privzeto je $\pi$ identična permutacija. Program je končan, ko so izvedeni vsi koraki. Rezultat končnega programa je običajno rezultat zadnjega izvedenega koraka. Dve izvajanji programa sta ekvivalentni, če sta njuna rezultata enaka. Ker je zgornji indeks določen s spodnjim indeksom ga bomo opustili. Kadar se korak $k_i$ začne izvajati, šele ko so se v celoti izvedli vsi koraki $k_1,...,k_{i-1}$, takemu programu pravimo, da je sinhron ali sekvenčen. Če vsak korak potrebuje enoto časa, da se izvede, in korake izvajamo sekvenčno v istem vrstnem redu kot so v $S$ se korak $k_i$ izvede ob času $i$. Koraka $k_i$ in $k_{i+j}$ sta odvisna drug od drugega, kadar se rezultat $k_{i+j}$ spreminja v odvisnosti od rezultata $k_i$ ali kadar se rezultat $k_i+j$ spreminja v odvisnosti od ali je bil $k_i$ izveden prej hkrati ali po $k_{i+j}$. Sicer sta neodvisna. Na primer korak $k_3$, ki vrne spremenljivko $a$ je odvisen od koraka $k_4$, ki poveča $a$ za 1, saj se $k_3$ spremeni, če ga izvedemo za korakom $k_4$. V primeru, da sta korak $k_i$ in $k_{i-1}$ neodvisna, lahko zamenjamo njun vrstni red izvajanja, ne da bi se rezultat kakega koraka spremenil in posledično delovanje celotnega programa.
Če korake izvajamo sekvenčno, z zamenjavo vrstnega reda izvajanja korakov nismo pridobili na času, saj je skupno število korakov v programu ostalo nespremenjeno. Vseeno pa to pomeni, da imamo več možnosti v zaporedju izvajanja programa kamor lahko damo korak $k_i$, da dobimo želeni končen program, kar lahko programerju prihrani čas za razmislek, kam točno ga mora postaviti.


Program $P$ se lahko izvaja tudi drugače. Namesto da se na enkrat izvede le en korak, se izvede nekaj korakov. Novo izvajanje programa lahko predstavimo z urejeno $n$-terico ne praznih množic korakov. 
$$S_p = (t_1, t_2, ... , t_m),\ t_i = \{ k_{1(i)},...k_{l(i)} \}.$$
Koraki v množici $t_i$ se izvedejo ob času $i$. Kadar vsaj ena množica $t_i$ vsebuje vsaj dva ali več korakov, programu pravimo da je vzporeden. V primeru, da so $t_i = \{k_i\}$, sta izvajanji $S_p$ in $S_s$ ekvivalentni.
Če je korak $k_j \in t_i$ neodvisen od vseh preostalih korakov iz $t_{i-1}$ ali $t_i$ v izvajanju $S_p$, bo izvajanje 
$$\tilde{S_p} = (t_1, t_2, ... , t_{i-2}, \tilde{t}_{i-1}, \tilde{t}_i, t_{i+1}, ..., t_m),\ \tilde{t}_{i-1} =t_{i-1} \cup \{k_j\},\ \tilde{t}_i = t_i \setminus \{k_j\}$$ 
ekvivalentno izvajanju $S_p$. 
V primeru, da je $\tilde{t}_i$ prazna množica bo izvajanje 
$$\hat{S_p} = (t_1, t_2, ... , t_{i-2}, \tilde{t}_{i-1}, t_{i+1}, ..., t_m)$$
ekvivalentno prejšnjima dvema z bistveno razliko. Izvajanje $\hat{S_p}$ se konča enota časa prej, kot $S_p$ ali $\tilde{S_p}$. Dokler so pogoji izpolnjeni lahko ta postopek ponavljamo in dobimo izvajanja, ki so ekvivalentna prvotnemu, a bistveno, se hitreje končajo.
Hitrejše izvajanje programa je glavni razlog, da si želimo vzporedno izvajanje programa.


Ugotoviti kateri koraki so med sabo neodvisni je v večini primerov ne trivialno. Programski jezik ugotovi neodvisnost le na najbolj trivialnih primerih. Običajen pristop za reševanje tega problema je zato, da se korake razdeli v procese ali niti. Za koraka $k_i$ in $k_j$ se smatra da sta neodvisna, če pripadata različnemu procesu, razen v primeru ko eksplicitno označimo, da koraka sta odvisna. Sedaj ima programski jezik na voljo veliko več trivialnih korakov, ki jih zna narediti vzporedne. 

Seveda imamo sedaj ne trivialen postopek delitve korakov v procese in označevanje korakov iz različnih procesov, ki so odvisni med sabo. Nepravilna delitev v procese ali napačno označevanje odvisnosti korakov, lahko vodi v izvajanje programa, ki ne bo ekvivalentno prvotnemu. Da se ta postopek olajša kolikor je mogoče, je želeno od programskega jezika, da ima korake, ki naredijo ta postopek čim bolj enostaven in razumljiv. Iz tega razloga imajo nekateri programski jeziki zelo omejeno število različnih vrst korakov, ki so lahko odvisni od korakov izven istega procesa.


Nekateri programski jeziki, predvsem starejše verzije, nimajo direktno podpore za vzporedno izvajanje programa. 
Veliko modernih jezikov, če ne drugega omogočajo tako imenovan POSIX. POSIX je API, ki na operacijskih sistemih, ki ga podpirajo, omogoča uporabo niti~\cite{posix}.
Drugi programski jeziki kot so C++, Java... imajo kot del standardne knjižnice konstrukte, ki jim omogočajo vzporedno izvajanje programa. Čeprav v ozadju mnogi jeziki uporabljajo POSIX, so detajli skriti in zato bolj naravni za programerja. 
Nekateri programski jeziki omogočajo mnoge konstrukte povezane s vzporednim programiranjem, vendar direktno ne omogočajo vzporednega izvajanja. Na primer CPython ima tako imenovan GIL (global  interpreter lock)~\cite{gil}, ki preprečuje tolmaču, da bi izvajal korake iz več kot ene nit na enkrat.
Le redki programski jeziki, recimo Go, pa so bili zasnovani z vzporednim programiranjem v mislih in imajo zato konstrukte potrebne za vzporedno izvajanje vgrajene v jezik.


Eden izmed njih je tudi jezik \aeff{}, ki sloni na računu imenovanem \lae~\cite{aeff}. \aeff{} je ne deterministični statično tipiziran tolmačen funkcijski jezik. Program napisan v \aeff{} je razdeljen v procese, ki se lahko izvajajo vzporedno. Procesi lahko med sabo komunicirajo s pomočjo efektov.  Glavni namen \lae{} je pokazati, da je v ozadju vzporednih programskih jezikov lepa teorija. V osnovni verziji \aeff{} omogoča vzporedno izvajanje izračunov, ki lahko po potrebi komunicirajo med sabo s pošiljanjem signalov. 


Najprej si bomo v poglavju \ref{sec:lae} pogledali že obstoječ račun \lae{}. V poglavju \ref{sec:razsirjen-lae} ga bomo razširili z rekurzivno obljubo, razcepom in \jR{Okvir}. V poglavju \ref{sec:impl} si bomo pogledali implementacijo. Obstoječ Hindley–Milnerjev sistem tipov bomo zamenjali z dvosmernim sistemom tipov in obstoječ tolmač spremenili, da omogoča nekoliko bolj optimalno izvajanje. Vse dele implementacije bomo prilagodili tudi za razširjen \lae.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Račun \lae{}}\label{sec:lae}

Račun $\lambda$ je preprost teoretičen programski jezik. Leta 1930 ga je uvedel Alonzo Chuch z namenom formalizacije koncepta izračunljivosti~\cite{rojas2015tutorial}. Račun lambda je turing complete.
Kot tak predstavlja odlično osnovo za formalizacijo paralelnega programskega jezika.


Račun \lae{} je razširitev računa $\lambda$. Posledično je tudi \lae{} turing complete. Računu \lae{} dodamo izraze, ki poosebijo bistvo vzporednega programiranja z pošiljanjem sporočil. Da \lae{} čim bolj približamo vsakdanjim programskim jezikom, mu dodamo tudi izraze za  naravna števila, par, ujemanje vzorca...

%Ena izmed ključnih oblikovnih lastnosti računa \lae, je da nima skupnega pomnilnika in posledično v njem ne pride do race conditions.


\subsection{Vrednosti in izračuni}

Izraze v \lae{} razdelimo na vrednosti, izračune in procese. 


Vrednosti so sledeče.
Konstante vrednosti naravna števila in logični vrednosti resnica in neresnica.
% TOLE DODAJ ČE BO MAGISTRSKA PREKRATKA DA BODO DALJŠI DOKAZI in nekatere aritmetične in logične funkcije kot so $+$, $-$, $*$, $/$, $=$, $<$...
Spremenljivke, ki so simbolična imena povezana z vrednostmi v danem kontekstu.
Enote in pare.
leve in desne inkluzije vsote.
Lambda abstrakcije.
Rekurzivne lambda abstrakcije.
Izpolnjena obljuba. Ta vrednost je edina zares nova. Je vrednost, ki jo je vrnil prestreznik in jo posebej označimo, da bomo kasneje lahko pravilno določili tip.


Izračuni so sledeči.
Vrni ki drži neko vrednost.
Zaporedje dveh izračunov.
Aplikacija ki v prvi izraz substituira drugi izraz.
Ujemanje ki glede na vzorec izraza izbere izračun. 
Signal vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prekinitev vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prestreznik vsebuje ime operacije, ime spremeljivke, Izračun M in izračun N.
blokada


Pripadajočo sintakso vidimo na~\ref{fig:izrazi} v Backus-Naurjevi obliki (BNF).

%zakaj imajo funkcije sintakso za tip? Na ta način je inferece veliko enostavnejši ampak saj tu se neukvarjamo z inference? Ali niso anotacije v ta namen?? 

%Kaj gre narobe če odstranimo match V with {} ??
%Odveč če bo prvi odgovor dober. Vir prazne vsote so exceptni, runtime errorji in neskončne rekurzije ali še kaj drugega? Exceptionov nimamo v jeziku, errorjev nimamo ker imamo tipe, rekurzija lahko nikoli vrne poljuben tip. Pa naj nikoli vrne unit namesto da nikoli vrne prazno vsoto?? Je prazna vsota "indikator" da preostanka ne moremo doseči in ga lahko vržemo stran? Neke vrsta optimizacija pomnilnika ali še bolje compile error uporabniku naj spremeni kodo?


\begin{figure}[h]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\intertext{\textbf{Vrednosti}}
		V, W
		\bnfis& n \bnfor\! \true \bnfor\! \false        & &\text{konstantne vrednosti} \\
		\bnfor& x                                       & &\text{spremenljivka} \\
		\bnfor& \tmunit \bnfor\! \tmpair{V}{W}          & &\text{enota in par} \\
		\bnfor& \tminl[Y]{V} \bnfor\! \tminr[X]{V}      & &\text{leva in desna inkluzija} \\
		\bnfor& \tmfun{x}{M}                        & &\text{lambda} \\
		\bnfor& \tmfunrec{f}{x : X}{M}                        & &\text{rekurzivna lambda} \\
		\bnfor& \tmpromise V                            & &\text{izpolnjena obljuba}
		\\[1ex]
		\intertext{\textbf{Izračuni}}
		M, N
		\bnfis& \tmreturn{V}                            & &\text{vrnjena vrednost} \\
		\bnfor& \tmlet{x}{M}{N}                         & &\text{zaporedje} \\
	%	\bnfor& \tmletrec[: \tyfun{X}{Y}]{f}{x}{M}{N} & &\text{rekurzivna definicija} \\
		\bnfor& V\,W                                    & &\text{aplikacija} \\
		\bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    & &\text{ujemanje produkta} \\
		\bnfor& \tmmatch[]{V}{}                        & &\text{prazno ujemanje} \\
		\bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}	& &\text{ujemanje vsote} \\
		\bnfor& \tmopout{op}{V}{M}       & &\text{signal} \\
		\bnfor& \tmopin{op}{V}{M}          & &\text{prekinitev} \\
		\bnfor& \tmwith{op}{x}{M}{p}{N}      & &\text{prestreznik} \\
		\bnfor& \tmawait{V}{x}{M}             & &\text{blokada}
			\\[1ex]
		\intertext{\textbf{Procesi}}
	%	P \bnfis & ...
		  P, Q
		\bnfis & \tmrun M & & \text{run} \\
		\bnfor & \tmpar P Q & & \text{vzporedna procesa} \\
		\bnfor & \tmopout{op}{V}{P} & & \text{proces signal} \\
		\bnfor & \tmopin{op}{V}{P} & & \text{proces prekinitev}
		\end{align*}
	} 
	\caption{Vrednosti, izračuni in procesi.}
	\label{fig:izrazi}
\end{figure}


\subsection{Operacijska semantika}

Račun \lae\ opremimo z operacijsko semantiko malih korakov in je definirana z relacijo korak $M \reduces N$.


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Pravila osnovnih izračunov}}
	\tmapp{(\tmfun{x \of X}{M})}{V} &\reduces M[V/x]
	\\
	\tmlet{x}{(\tmreturn V)}{N} &\reduces N[V/x]
	\\
	\tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto M} &\reduces M[V/x, W/y]
	\\
	\mathllap{\tmmatch{(\tminl[Y]{V})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	M[V/x]
	\\
	\mathllap{\tmmatch{(\tminr[X]{W})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	N[W/y]
	\\[1ex]
	\intertext{\textbf{Algebraičnost signala, prestreznika in blokade}}
	\tmlet{x}{(\tmopout{op}{V}{M})}{N} &\reduces \tmopout{op}{V}{\tmlet{x}{M}{N}}
	\\
	\tmlet{x}{(\tmwith{op}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwith{op}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\\
	\tmlet{x}{(\tmawait{V}{y}{M})}{N} & \reduces \tmawait{V}{y}{(\tmlet{x}{M}{N})}
	\\[1ex]
	\intertext{\textbf{Komutativnost operacij}}
	\tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmopout{op'}{W}{M}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{M}}
	\\
	\tmopin{op}{V}{\tmawait{W}{x}{M}} &\reduces \tmawait{W}{x}{\tmopin{op}{V}{M}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmreturn W} &\reduces \tmreturn W
	\\
	\tmopin{op}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}
	\\
	\tmopin{op'}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmwith{op}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\\[1ex]
	\intertext{\textbf{Čakanje na izpolnitev obljube}}
	\tmawait{\tmpromise V}{x}{M} &\reduces M[V/x]
	\\[-8ex]
	\end{align*}
	
	\begin{align*}
	\intertext{\textbf{Evalvacija v okolju}}
	\coopinfer{}{
		M \reduces N
	}{
		\E[M] \reduces \E[N]
	}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{kjer}}
	\text{$\E$}
	\bnfis [~]
	\bnfor \tmlet{x}{\E}{N}
	\bnfor \tmopout{op}{V}{\E}
	\bnfor \tmopin{op}{V}{\E} 
	\bnfor \tmwith{op}{x}{M}{p}{\E}
	\end{align*}
	
	\caption{Operacijska semantika malih korakov za izračune.}
	\label{fig:small-step-semantics-of-computations}
\end{figure}

\begin{figure}[h]
    \centering
	\small
	\begin{minipage}[t]{0.4\textwidth}
		\centering
		\begin{align*}
		\intertext{\textbf{Posamezen proces}}
		\coopinfer{}{
			M \reduces N
		}{
			\tmrun M \reduces \tmrun N
		}
		\end{align*}
	\end{minipage}
	\qquad
	\begin{align*}
	\intertext{\textbf{Prehod}}
	\tmrun {(\tmopout{op}{V}{M})}  &\reduces \tmopout{op}{V}{\tmrun M}
	\\
	\tmopin{op}{V}{\tmrun M} &\reduces \tmrun {(\tmopin{op}{V}{M})}
	\\[1ex]
	\intertext{\textbf{Oddajanje signala}}
	\tmpar{\tmopout{op}{V}{P}}{Q} &\reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
	\\
	\tmpar{P}{\tmopout{op}{V}{Q}} &\reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{P}}{Q}}
	\\[1ex]
	\intertext{\textbf{Širitev prekinitve}}
	\tmopin{op}{V}{\tmpar P Q} &\reduces \tmpar {\tmopin{op}{V}{P}} {\tmopin{op}{V}{Q}}
	\\[1ex]
	\intertext{\textbf{Komutativnost signala in prekinitve}}
	\tmopin{op}{V}{\tmopout{op'}{W}{P}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{P}}
	\end{align*}
	\vspace{-4ex}
	\begin{align*}
	\shortintertext{\quad\textbf{Evalvacija v okolju}}
	\quad
	\coopinfer{}{
		P \reduces Q
	}{
		\F[P] \reduces \F[Q]
	}
	\end{align*}
	\vspace{-6ex}
	\begin{align*}
	\intertext{\textbf{kjer}}
	\text{$\F$}
	\bnfis& [~]
	\bnfor \tmpar \F Q \bnfor\! \tmpar P \F
	\bnfor \tmopout{op}{V}{\F}
	\bnfor \tmopin{op}{V}{\F}
	\end{align*}
	
	\caption{Operacijska semantika malih korakov za procese.}
	\label{fig:small-step-semantics-of-processes}
\end{figure}



%Določenih kombinacij izrazov nimamo v operacijski semantiki, ker niso smiselne. Recimo ...
%aplikacija konstantne funkcije $+$ na enoti. Problem nastane, ker je domena funkcije $+$ števila, čeprav ni nikjer eksplicitno zapisana. Enota ni število. Zato aplikacija $+$ na enoti ni smiselna.
%Če \lae pride do izračuna za katerega nima pravila v operacijski semantiki se ustavi. Večina programskih jezikov bi na tem mestu vrnila runtime error.
%V aeff interpreterju je povno assertov, ki bi se sprožili, če bi dobili recimo "true + ()". Kaj točno pa lae naredil?

\subsection{Sistem tipov}

Runtime errorji niso zaželjeni. Da jih spremenimo v compile time error, uvedemo sistem tipov in efektov. 

Pravila za dodelitev tipa vidimo na~\ref{fig:tipi}.


\begin{figure}[h]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\text{Osnovni tipi vrednosti $\bar{A}$, $\bar{B}$}
		\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\bar{A}}{\bar{B}} \,\bnfor\! \tysum{\bar{A}}{\bar{B}}
		\\%[1ex]
		\text{Tipi vrednosti $A$, $B$}
		\bnfis & \bar{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
		\\
		\text{Tip izračuna} \bnfis& \tycomp{A}{\o,\i}
		\\
		\text{Tip procesa \tyC, \tyD}  \bnfis & \tyrun{A}{\o, \i} \,\bnfor\! \typar{\tyC}{\tyD}
		\end{align*}
	} 
	\caption{Tipi izrazov}
	\label{fig:tipi}
\end{figure}

\begin{figure}[t]
	\centering
	\small
	\begin{align*}
	(op_1, \bar{A}_{op_1}),\, (op_2, \bar{A}_{op_2}),\, ... ,\, (op_n, \bar{A}_{op_k})
	\end{align*}
	\caption{Operacije in pripadajoči tipi}
	\label{fig:operacije}
\end{figure}



\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types n : int
		}
		\qquad
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types true : bool
		}
		\qquad
		\coopinfer{Tip-Cons}{
		}{
			\Gamma \types false : bool
		}
		\quad
		\coopinfer{Tip-Var}{
		}{
			\Gamma, x \of X, \Gamma' \types x : X
		}
		\quad
		\coopinfer{Tip-Unit}{
		}{
			\Gamma \types \tmunit : \tyunit
		}
		\\
		\coopinfer{Tip-Pair}{
			\Gamma \types V : X \\
			\Gamma \types W : Y
		}{
			\Gamma \types \tmpair{V}{W} : \typrod{X}{Y}
		}
		\quad
		\coopinfer{Tip-Promise}{
			\Gamma \types V : X
		}{
			\Gamma \types \tmpromise V : \typromise X
		}
		\quad
		\coopinfer{Tip-Inl}{
			\Gamma \types V : X
		}{
			\Gamma \types \tminl[Y]{V} : X + Y
		}
		\quad
		\coopinfer{Tip-Inr}{
			\Gamma \types W : Y
		}{
			\Gamma \types \tminr[X]{W} : X + Y
		}
		\\
		\coopinfer{Tip-Fun}{
			\Gamma, x \of X \types M : \tycomp{Y}{\o,\i}
		}{
			\Gamma \types \tmfun{x : X}{M} : \tyfun{X}{\tycomp{Y}{\o,\i}}
		}
		\quad
		\coopinfer{Tip-Fun-Rec}{
			\Gamma,f \of \tyfun{X}{\tycomp{Y}{\o,\i}}, x \of X \types M : \tycomp{Y}{\o,\i}
		}{
			\Gamma \types \tmfunrec{f}{x : X}{M} : \tyfun{X}{\tycomp{Y}{\o,\i}}
		}
	\end{mathpar}
	\caption{Pravila za izračun tipov za vrednosti.}
	\label{fig:value-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyComp-Return}{
			\Gamma \types V : X
		}{
			\Gamma \types \tmreturn{V} : \tycomp{X}{(\o,\i)}  %OD kje dobimo oi? Kako lahko return sproži kakršne koli efekte??
		}
		\qquad
		\coopinfer{TyComp-Let}{
			\Gamma \types M : \tycomp{X}{(\o,\i)}
			\\
			\Gamma, x \of X \types N : \tycomp{Y}{(\o,\i)} %Zakaj imata M in N v zaporedju iste operacije, ki jih lahko sprožita/prestrežeta?? let x = send op 23 in return 4. Ali nima M ({op},{}) in N ({},{}) ??
		}{													%Zakaj ima pa rekurzivno zaporedje dva različna tipa?? 
			\Gamma \types
			\tmlet{x}{M}{N} : \tycomp{Y}{(\o,\i)}       % KO definiramo tip izraza rečemo MINIMALNA relacija zaprta za pravila. Nebi tudi za tipe efektov morali imeti v nekem smislu minimalnost?
		}												% Zakaj imamo oi in ne si, če imamo signal in interupt handler? Zakaj nimamo signal in interupt ALI send in interupt handler??
		\\
		\coopinfer{TyComp-Apply}{
			\Gamma \types V : \tyfun{X}{\tycomp{Y}{(\o,\i)}} \\
			\Gamma \types W : X
		}{
			\Gamma \types \tmapp{V}{W} : \tycomp{Y}{(\o,\i)}
		}
		\quad
		\coopinfer{TyComp-MatchPair}{
			\Gamma \types V : \typrod{X}{Y} \\
			\Gamma, x \of X, y \of Y \types M : \tycomp{Z}{(\o,\i)}
		}{
			\Gamma \types \tmmatch{V}{\tmpair{x}{y} \mapsto M} : \tycomp{Z}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-MatchEmpty}{
			\Gamma \types V : \tyempty
		}{
			\Gamma \types \tmmatch[\tycomp{Z}{(\o,\i)}]{V}{} : \tycomp{Z}{(\o,\i)}
		}
		\quad
		\coopinfer{TyComp-MatchSum}{
			\Gamma \types V : X + Y \\\\
			\Gamma, x \of X \types M : \tycomp{Z}{(\o,\i)} \\
			\Gamma, y \of Y \types N : \tycomp{Z}{(\o,\i)} \\
		}{
			\Gamma \types \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} : \tycomp{Z}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-Signal}{
			\op \in \o \\
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{X}{(\o,\i)} 
		}{
			\Gamma \types \tmopout{op}{V}{M} : \tycomp{X}{(\o,\i)}
		}
		\qquad
		\coopinfer{TyComp-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types M : \tycomp{X}{(\o,\i)} 
		}{
			\Gamma \types \tmopin{op}{V}{M} : \tycomp{X}{\opincomp {op} (\o,\i)}
		}
		\\
		\coopinfer{TyComp-Promise}{
			\i\, (\op) = ({\o'} , {\i'}) \\
			\Gamma, x \of A_\op \types M : \tycomp{\typromise X}{(\o',\i')} \\
			\Gamma, p \of \typromise X \types N : \tycomp{Y}{(\o,\i)} 
		}{
			\Gamma \types \tmwith{op}{x}{M}{p}{N} : \tycomp{Y}{(\o,\i)}
		}
		\\
		\coopinfer{TyComp-Await}{
			\Gamma \types V : \typromise X \\
			\Gamma, x \of X \types M : \tycomp{Y}{(\o,\i)} 
		}{
			\Gamma \types \tmawait{V}{x}{M} : \tycomp{Y}{(\o,\i)}
		}
		\qquad
		\coopinfer{TyComp-Subsume}{
			\Gamma \types M : \tycomp{X}{(\o, \i)} \\
			(\o,\i) \order {O \times I} (\o',\i')
		}{
			\Gamma \types M : \tycomp{X}{(\o', \i')} %Zakaj potrebujemo to pravilo v tej verziji lae??
		}
	\end{mathpar}
	\caption{Pravila za izračun tipov za izračune.}
	\label{fig:computation-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{TyProc-Run}{
			\Gamma \types M : \tycomp{X}{(\o,\i)}
		}{
			\Gamma \types \tmrun{M} : \tyrun{X}{\o}{\i}
		}
		\quad
		\coopinfer{TyProc-Par}{
			\Gamma \types P : \tyC \\
			\Gamma \types Q : \tyD
		}{
			\Gamma \types \tmpar{P}{Q} : \typar{\tyC}{\tyD}
		}
		\\
		\coopinfer{TyProc-Signal}{
			\op \in \mathsf{signals\text{-}of}{(\tyC)} \\\\
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopout{op}{V}{P} : \tyC
		}
		\quad
		\coopinfer{TyProc-Interrupt}{
			\Gamma \types V : A_\op \\
			\Gamma \types P : \tyC 
		}{
			\Gamma \types \tmopin{op}{V}{P} : \opincomp{op}{\tyC}
		}  
	\end{mathpar}
	\caption{Pravila za izračun tipov za procese.}
	\label{fig:process-typing-rules}
\end{figure}

\begin{figure}[h]
	\centering
	\textbf{Delni rezultati}
	\begin{mathpar}
		\coopinfer{}{
		}{
			\RunResult {\Psi} {\tmreturn V}
		}
		\\
		\coopinfer{}{
			\RunResult {\Psi \cup \{p\}} {N}
		}{
			\RunResult {\Psi} {\tmwith {op} x M p N}
		}
		\quad
		\coopinfer{}{
			p \in \Psi \\
			\awaiting p {\tmawait p x M}
		}{
			\RunResult {\Psi} {M}
		}
	\end{mathpar}

	
	\textbf{Rezultati}
	\begin{mathpar}
		\coopinfer{}{
			\ProcResult {P}
		}{
			\ProcResult {\tmopout {op} V P}
		}
		\qquad
		\coopinfer{}{
			\ParResult {P}
		}{
			\ProcResult {P}
		}
		\\
		\coopinfer{}{
			\ParResult P \\
			\ParResult Q
		}{
			\ParResult {\tmpar P Q}
		}
		\qquad
		\coopinfer{}{
			\RunResult {\emptyset} {M}
		}{
			\ParResult {\tmrun M}
		}
	\end{mathpar}
	\caption{Rezultati in delni rezultati.}
	\label{fig:results-rules}
\end{figure}

...

Izrek o varnosti, ki je sestavljen iz izreka o ohranitvi in izreka o napredku nam zagotavlja, da ne moremo dobiti runtime, če imamo tipe, kot smo jih definirali.

\begin{izrek}[Izrek o varnosti]
	Če ima izračun $M$ tip, potem je "varen".
\end{izrek}


\begin{izrek}[Izrek o napredku]
	Če ima izraz $M$ v okolju $\Gamma$ tip $A$, je $M$ rezultat ali pa lahko naredi korak v izraz $M^*$.
\end{izrek}

\begin{proof}
	Če je izraz $M$ rezultat smo končali. Sicer dokazujemo 
\end{proof}


\begin{izrek}[Izrek o ohranitvi]
	Če ima izraz $M$ v okolju $\Gamma$ tip $A$ in naredi korak v izraz $M^*$, ima $M^*$ v okolju $\Gamma$ tip $A$.
\end{izrek}

\begin{proof}
	%Left for the reader as an exercise :D
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Razširjen \lae{}}\label{sec:razsirjen-lae}



\subsection{Rekurzivni prestreznik}


\mP{Tole še ni za oddati.}

Kadar pričakujemo več prekinitev z isto operacijo je lahko iz različnih razlogov za programerja priročno, če ima na voljo prestreznik, ki se po potrebi ponovno namesti. Lahko da je namen prestreznika, da na vsako prekinitev odgovori z signalom. Lahko nam prihajajoča prekinitev prinese pravo operacijo, vendar ne pravega pripadajočega tovora, zato obljube še nočemo izpolniti, in čakamo na naslednjo prekinitev.

To funkcionalnost smo do sedaj dosegli tako, da smo obljubo zapakirali v rekurzivno funkcijo in po potrebi znotraj obljube ponovno klicali to funkcij kot lahko vidimo v programu~\ref{prog:obljuba-v-rekurzivni-funkciji}.


\begin{lstlisting}[caption={Obljuba v rekurzivni funkciji.},label={prog:obljuba-v-rekurzivni-funkciji}]
	let rec f =
	promise (op x -> send op x; f(); return <<()>>) 
	as _ in ()
\end{lstlisting}

Predvsem z namenom bolj pregledne kode nadomestimo obstoječi prestreznik z rekurzivnim prestreznikom. Le ta ima poleg imena operacije $op$, tovora $V$, obljube $M$ in kontinuacije $N$ tudi spremenljivko $f$. Pripadajočo sintakso vidimo na sliki~\ref{fig:izrazi-prestreznik}.


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmwithrec{op}{f}{V}{M}{p}{N}  & &\text{rekurzivni prestreznik}
	\end{align*}
 
	\caption{Izračuni z rekurzivnim prestreznikom}
	\label{fig:izrazi-prestreznik}
\end{figure}


Operacijska semantika rekurzivnega prestreznika je zelo podobna prejšnji verziji. Z to izjemo, da ko ustrezna prekinitev pride do prestreznika le ta v obljubi M naredi dve substituciji. Tako kot prej spremenljivko $x$ substituira z vrednostjo $V$, dodatno pa spremenljivko $f$ substituira z lambda funkcijo $F$, ki sprejme enoto in vrne svežo kopijo prestreznika. Znotraj $M$ lahko uporabimo $F$ in tako ponovno namestimo prestreznik.   


\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\tmlet{x}{(\tmwithrec{op}{f}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwithrec{op}{f}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
	\\
	\tmwithrec{op}{f}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}}
	\\
	\tmopin{op}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x, F/f]}{\tmopin{op}{V}{N}} \\
	F = \;& \tmfunano{y}{(\tmwithrec{op}{f}{x}{M}{p}{\tmreturn{p}})} \\
	\tmopin{op'}{V}{\tmwithrec{op}{f}{x}{M}{p}{N}} &\reduces \tmwithrec{op}{f}{x}{M}{p}{\tmopin{op'}{V}{N}} \\
	&\qquad {\color{rulenameColor}(\op \neq \op')}
	\end{align*}
	
	\caption{Operacijska semantika rekurzivnega prestreznika}
	\label{fig:semantika-prestreznik}
\end{figure}

Program~\ref{prog:rekurzivna-obljuba} ima isti semantičen pomen kot program~\ref{prog:obljuba-v-rekurzivni-funkciji}, le da je tokrat napisan z rekurzivno obljubo.
\begin{lstlisting}[caption={Rekurzivna obljuba.},label={prog:rekurzivna-obljuba}]
	promise (op x k -> send op x; k())
	as _ in ()
\end{lstlisting}

Kot sintaktični sladkor dodamo tudi varovan prestreznik, ki se sproži le kadar je poleg prave operacije tudi pravi pripadajoči tovor.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Sintaksa}}
	\tmwithrecgu{op}{x}{f}{P(x)}{M}{p}{N}  & &\text{varovan rekurzivni prestreznik}
	\\%[1ex]
	\intertext{\textbf{Semantika}}
	\tmopin{op}{V}{\tmwithrecgu{op}{f}{x}{P}{M}{p}{N}} \\ \reduces \tmlet{p}{(\ite{P[V/x]}{M[V/x, F/f]}{F\,()})}{\tmopin{op}{V}{N}} \\
	{\color{rulenameColor}F = \tmfunano{y}{(\tmwithrec{op}{f}{x}{M}{p}{\tmreturn{p}})}}
	\end{align*}
	
	\caption{Varovan rekurzivni prestreznik}
	\label{fig:izrazi-prestreznik}
\end{figure}


\subsection{Prenosljivi tipi}

Ko imamo nek signal je ključno, da tovor ne vsebuje vrednosti z tipom obljuba, kar smo do sedaj rešili tako, da smo omejili signale na osnovne tipe. Glavni problem tega pristopa je, da funkcijski tip ni med osnovnimi tipi in posledično ne moremo poslati lambda funkcij. Ta problem rešimo z uvedbo zavite vrednosti in zavitega tipa. Zavite vrednosti bodo lahko vrednosti tudi lambda funkcije, ki ne bodo vsebovale zunanje obljube. Posledično jih bo varno poslati. Osnovne tipe skupaj z zavitim tipom imenujemo prenosljivi tipi. Da bomo lahko zavito vrednost tudi uporabili dodamo izračun odvijanje. 

Tipi za izračune in procese ostanejo enaki.

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\intertext{\textbf{Vrednosti}}
	V
	\bnfis& ...                            & &\text{obstoječe vrednosti} \\
	\bnfor& \tmboxed{V}  & &\text{zavita vrednost}
	\intertext{\textbf{Izračuni}}
	M, N
	\bnfis& ...                            & &\text{obstoječi izračuni} \\
	\bnfor& \tmunbox{V}{x}{M}  & &\text{odvijanje}
	\end{align*}
	
	\caption{Prenosljivi izrazi.}
	\label{fig:izrazi-prenosljivi}
\end{figure}

\begin{figure}[h]
	\centering
	\small
	\begin{align*}
	\text{Prenosljivi tipi vrednosti $\tymobile{A}$, $\tymobile{B}$}
	\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tysum{\tymobile{A}}{\tymobile{B}} \,\bnfor\! \tyboxed{A}
	\\%[1ex]
	\text{Tipi vrednosti $A$, $B$}
	\bnfis & \tymobile{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{\tycomp{B}{\o,\i}} \,\bnfor\! \typromise{A}
	\end{align*}
	\vspace{-5ex}
	\begin{align*}
	(op_1, \tymobile{A}_{op_1}),\, (op_2, \tymobile{A}_{op_2}),\, ... ,\, (op_n, \tymobile{A}_{op_k})
	\end{align*}
	 
	\caption{Prenosljivi tipi.}
	\label{fig:tipi-prenosljivi}
\end{figure}

Da zagotovimo, da nebi kakšni vrednosti, ki vsebuje zunanjo obljubo, dodeliti zavit tip, nekoliko spremenimo pravilo za izračun tipa spremenljivke. Hkrati tudi dodamo pravili za zavito vrednost in izračun odvijanje.

\begin{figure}[h]
	\centering
	\small
	\begin{mathpar}
		\coopinfer{}{\text{A prenosljiv ali } \blacksquare \notin \Gamma'
		}{
			\Gamma, x \of A, \Gamma' \types x \of A
		}
		\quad
		\coopinfer{}{\Gamma, \blacksquare \types V \of A
		}{
			\Gamma \types \tmboxed{V} \of \tyboxed{A}
		}
	    \quad
		\coopinfer{}{\Gamma \types V \of \tyboxed{A} \\ \Gamma, x \of A \types M \of B
		}{
			\Gamma \types \tmunbox{V}{x}{M} \of B
		}
	\end{mathpar}

	\caption{Pravila za izračun tipov prenosljivih izrazov.}
	\label{fig:tipi-pravila-prenosljivi}
\end{figure} 

\subsection{Spawn}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementacija}\label{sec:impl}

\subsection{Sistem tipov}\label{sec:tipi}

\subsubsection{Hindley–Milner}

\subsubsection{Bidirectional}


\subsection{Tolmač}\label{sec:interpreter}

\subsubsection{prej}

\subsubsection{potem}

Pokazat da, če naredimo korak v nek izračun, obstaja zaporedje korakov v prejšnji, ki vodijo v isti izračun.

Pokazati da potrebujemo "manj korakov" 




% Literatura:
% Primer navajanja na http://www.fmf.uni-lj.si/storage/24240/LiteraturaM.pdf,
% ampak bi moral stil poskrbeti za vse. Reference se uredijo po abecedi.
% Če nobena izbira izmed @book, @atricle,... ni ok, potem se lahko vse napiše v
% @misc pod note={} in deluje tako kot normalen LaTeX.
% Komentar v bib datoteki se naredi samo s parom { }
% Za urejanje literature avtor priporoča program Jabref, ki zna tudi avtomatsko
% okrajšati imena revij. Za pravilno sortiranje vnosov brez avtorja, uporabite
% polje key={ }, kot v primeru.
% V primeru napak ustvarite issue na GitHubu ali pišite na jure.slak@fmf.uni-lj.si.
\cleardoublepage                           % na desni strani
\phantomsection                            % da prav delujejo hiperlinki
\addcontentsline{toc}{section}{\bibname}   % dodajmo v kazalo
\bibliographystyle{fmf-sl}                 % uporabljen stil je v datoteki fmf-sl.bst, na voljo tudi angleška verzija
\bibliography{\literatura}                 % literatura je v datoteki, definirani na začetku
% TeXStudio zmede \ zgoraj, tako da lahko notri napišeš dejansko ime .bib datoteke, če ti
% ne delajo predlogi citatov.

% Za stvarno kazalo
\cleardoublepage                           % na desni strani
\phantomsection                            % da prav delujejo hiperlinki
\addcontentsline{toc}{section}{\indexname} % dodajmo v kazalo
\printindex

\end{document}
