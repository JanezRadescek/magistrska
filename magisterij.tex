% !TeX spellcheck = sl_SI
% vim: set spell spelllang=sl:
% za preverjanje črkovanja, če se uporablja Texstudio ali vim
\documentclass[12pt,a4paper,twoside]{article}
\usepackage[utf8]{inputenc}  % pravilno razpoznavanje unicode znakov

% NASLEDNJE UKAZE USTREZNO POPRAVI
\newcommand{\program}{Matematika} % ime studijskega programa
\newcommand{\imeavtorja}{Janez~Radešček} % ime avtorja
\newcommand{\imementorja}{doc.~dr.~Pretnar Matija} % akademski naziv in ime mentorja, uporabi poln naziv, prof.~dr.~, doc.~dr., ali izr.~prof.~dr.
\newcommand{\imesomentorja}{} % akademski naziv in ime somentorja, če ga imate
\newcommand{\naslovdela}{Naslov vašega dela}
\newcommand{\letnica}{2021} % letnica magistriranja
\newcommand{\opis}{Delo obravnava integracijo po ω-kompleksih, njene lastnosti in posplošitve
na Levy-jeve topološke prostore.}  % Opis dela v eni povedi. Ne sme vsebovati matematičnih simbolov v $ $.
\newcommand{\kljucnebesede}{integracija\sep kompleks} % ključne besede, ločene z \sep, da se PDF metapodatki prav procesirajo
\newcommand{\keywords}{integration\sep complex} % ključne besede v angleščini
\newcommand{\organization}{Univerza v Ljubljani, Fakulteta za matematiko in fiziko} % fakulteta
\newcommand{\literatura}{literatura}  % pot do datoteke z literaturo (brez .bib končnice)
\newcommand{\sep}{, }  % separator med ključnimi besedami v besedilu
% KONEC PODATKOV

\usepackage{bibentry}         % za navajanje literature v programu dela s celim imenom
\nobibliography{\literatura}
\newcommand{\plancite}[1]{\item[\cite{#1}] \bibentry{#1}} % citiranje v programu dela

\usepackage{filecontents}  % za pisanje datoteke s PDF metapodatki
\usepackage{silence} \WarningFilter{latex}{Overwriting file}  % odstrani annoying warning o obstoju datoteke
% datoteka s PDF metapodatki, zgenerira se kot magisterij.xmpdata
\begin{filecontents*}{\jobname.xmpdata}
  \Title{\naslovdela}
  \Author{\imeavtorja}
  \Keywords{\kljucnebesede}
  \Subject{matematika}
  \Org{\organization}
\end{filecontents*}

\usepackage[a-1b]{pdfx}  % zgenerira PDF v tem PDF/A-1b formatu, kot zahteva knjižnica
\hypersetup{bookmarksopen, bookmarksdepth=3, colorlinks=true,
  linkcolor=black, anchorcolor=black, citecolor=black, filecolor=black,
  menucolor=black, runcolor=black, urlcolor=black, pdfencoding=auto,
  breaklinks=true, psdextra}

\usepackage[slovene]{babel}  % slovenščina
\usepackage[T1]{fontenc}     % naprednejše kodiranje fonta
\usepackage{amsmath,amssymb,amsfonts,amsthm} % matematični paketi
\usepackage{graphicx}     % za slike
\usepackage{emptypage}    % prazne strani so neoštevilčene, ampak so štete
%\usepackage{units}        % fizikalne enote kot \unit[12]{kg} s polovico nedeljivega presledka, glej primer v kodi
\usepackage{makeidx}      % za stvarno kazalo, lahko zakomentiraš, če ne rabiš
\makeindex                % za stvarno kazalo, lahko zakomentiraš, če ne rabiš
% oblika strani
\usepackage[
  top=3cm,
  bottom=3cm,
  inner=3.5cm,      % margini za dvostransko tiskanje
  outer=2.5cm,
  footskip=40pt     % pozicija številke strani
]{geometry}



% DRUGI TVOJI PAKETI:


\usepackage{listings}
\renewcommand{\lstlistingname}{Program}% Listing -> Program
\renewcommand{\lstlistlistingname}{Kazalo Programov}% List of Listings -> Kazalo Programov

\input{macros.tex}




\definecolor{jcyan}{cmyk}{1, 0, 0.15, 0.05}
\definecolor{jyellow}{cmyk}{0.8, 0, 0.4, 0}
% todo notes to comment the code when working in a group
\usepackage{todonotes}
\newcommand\dic[1]{\todo[inline,color=yellow]{#1}}	% slovar
\newcommand\mP[1]{\todo[inline,color=red]{#1 -MP}}	% comments by matija
\newcommand\jR[1]{\todo[inline,color=jcyan]{#1 -JR}} % comments by janez


\setlength{\overfullrule}{50pt} % označi predlogo vrstico
\pagestyle{plain}               % samo številka strani na dnu, nobene glave / noge

% ukazi za matematična okolja
\theoremstyle{definition} % tekst napisan pokončno
\newtheorem{definicija}{Definicija}[section]
\newtheorem{primer}[definicija]{Primer}
\newtheorem{opomba}[definicija]{Opomba}
\newtheorem{aksiom}{Aksiom}

\theoremstyle{plain} % tekst napisan poševno
\newtheorem{lema}[definicija]{Lema}
\newtheorem{izrek}[definicija]{Izrek}
\newtheorem{trditev}[definicija]{Trditev}
\newtheorem{posledica}[definicija]{Posledica}

\numberwithin{equation}{section}  % števec za enačbe zgleda kot (2.7) in se resetira v vsakem poglavju



% bold matematika znotraj \textbf{ }, tudi v naslovih, kot \omega spodaj
\makeatletter \g@addto@macro\bfseries{\boldmath} \makeatother

% Poimenuj kazalo slik kot ``Kazalo slik'' in ne ``Slike''
\addto\captionsslovene{
  \renewcommand{\listfigurename}{Kazalo slik}%
}

% če želiš, da se poglavja začnejo na lihih straneh zgoraj
% \let\oldsection\section
% \def\section{\cleardoublepage\oldsection}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%           DOCUMENT           %%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\pagenumbering{roman} % začnemo z rimskimi številkami
\thispagestyle{empty} % ampak na prvi strani ni številke

\noindent{\large
UNIVERZA V LJUBLJANI\\[1mm]
FAKULTETA ZA MATEMATIKO IN FIZIKO\\[5mm]
\program\ -- 2.~stopnja}
% ustrezno dopolni za IŠRM
\vfill

\begin{center}
  \large
  \imeavtorja\\[3mm]
  \Large
  \textbf{\MakeUppercase{\naslovdela}}\\[10mm]
  \large
  Magistrsko delo \\[1cm]
  Mentor: \imementorja \\[2mm] % ustrezno popravi spol
%   Somentor: \imesomentorja   % dodaj, če potrebno
\end{center}
\vfill

\noindent{\large Ljubljana, \letnica}

\cleardoublepage

%% sem pride IZJAVA O AVTORSTVU  -- SE NATISNE V VIS

% zahvala
\pdfbookmark[1]{Zahvala}{zahvala} %
\section*{Zahvala}
Neobvezno.
Zahvaljujem se \dots
% end zahvala -- izbriši vse med zahvala in end zahvala, če je ne rabiš

\cleardoublepage

\pdfbookmark[1]{\contentsname}{kazalo-vsebine}
\tableofcontents

% list of figures
% \cleardoublepage
% \pdfbookmark[1]{\listfigurename}{kazalo-slik}
% \listoffigures
% end list of figures

\cleardoublepage

\section*{Program dela}
\addcontentsline{toc}{section}{Program dela} % dodajmo v kazalo
Mentor naj napiše program dela skupaj z osnovno literaturo. Na literaturo se
lahko sklicuje kot~\cite{lebedev2009introduction}, \cite{gurtin1982introduction},
\cite{zienkiewicz2000finite}, \cite{STtemplate}.

\section*{Osnovna literatura}
Literatura mora biti tukaj posebej samostojno navedena (po pomembnosti) in ne
le citirana. V tem razdelku literature ne oštevilčimo po svoje, ampak uporabljamo
okolje itemize in ukaz plancite, saj je celotna literatura oštevilčena na koncu.
\begin{itemize}
  \plancite{lebedev2009introduction}
  \plancite{gurtin1982introduction}
  \plancite{zienkiewicz2000finite}
  \plancite{STtemplate}
\end{itemize}

\vspace{2cm}
\hspace*{\fill} Podpis mentorja: \phantom{prostor za podpis}

% \vspace{2cm}
% \hspace*{\fill} Podpis somentorja: \phantom{prostor za podpis}

\cleardoublepage
\pdfbookmark[1]{Povzetek}{abstract}

\begin{center}
\textbf{\naslovdela} \\[3mm]
\textsc{Povzetek} \\[2mm]
\end{center}
%Tukaj napišemo povzetek vsebine. Sem sodi razlaga vsebine in ne opis tega, kako je delo
%organizirano.
V delu si pogledamo programski jezik \aeff\ in račun \lae\ na katerem temelji. Račun \lae razširimo z rekurzivno obljubo, razcepom in \jR{Box/Unbox}. \jR{Ground} tipe nadomestimo z mobilnimi tipi, ki nam omogočajo pošiljanje tipov za katere prej nebi zmogli pokazati da so varni. Obstoječi sistem tipov nadomestimo z dvostranskim sistemom, ki predvsem izboljša sporočila v primeru napak. Dokažemo izreka o napredku in ohranitvi za razširjen \lae. Ne deterministično operacijsko semantiko malih korakov nadomestimo z deterministično \jR{big.SMALL kak} semantiko in pokažemo, da je prejšnji v nekem smislu ekvivalentna.



\vfill
\begin{center}
\textbf{English translation of the title} \\[3mm] % prevod slovenskega naslova dela
\textsc{Abstract}\\[2mm]
\end{center}

%An abstract of the work is written here. This includes a short description of
%the content and not the structure of your work.
TODO

\vfill\noindent
\textbf{Math.~Subj.~Class.~(2010):} oznake kot 74B05, 65N99, na voljo so na naslovu
\url{http://www.ams.org/msc/msc2010.html} \\[1mm]
\textbf{Ključne besede:} \kljucnebesede \\[1mm]
\textbf{Keywords:} \keywords

\cleardoublepage

\setcounter{page}{1}    % od sedaj naprej začni zopet z 1
\pagenumbering{arabic}  % in z arabskimi številkami


%Slovar
%promise = obljuba
%guarded promise = varovana obljuba
%abstraction = abstrakcija
%spawn = ??
%interpreter = tolmač
%type sistem = sistem tipov
%computation = izračun
%calculus = račun
%unit = enota
%Syntactic sugar = sintaktičen sladkor
%if computation/statement = če izračun
%parallel = vzporedno (Fizična implementacija ni tako bistvena)Logika program je razdeljena v več bolj ali manj neodvisnih enot threadov/procesov.)
%thread = nit
%payload = tovor
%Ground type = osnovni
%mobile = prenosljiv
%box/boxed = zavit,zavijanje,odvijanje
%black box in types =  
%recursion = rekurzija
%bidirectional = dvosmerni?
%small step semantics = op. sem. malih korakov
%signal = odhajajoči signal
%interrupt = prihajajoči signal          prekinitev
%handler = prestreznik
%pattern matching = ujemanje vzorca
%substitution = substitucija
%substitute = substituirati
%await = blokada
%source code = izvorna koda
%machine code = strojna koda
%shared memory = skupni spomin
%context = kontekst
%true/false = resnica/neresnica
%runtime error = ??
%Partition of a set = partiticija množice ??


%prevajaj vse razen sintakse na slikcah.
%Katere izreke/trditve si želimo od \lae? varnost in vse potrebno za dokaz le tega.
%prevajam tudi sintakso? NE
%Katere stvari lahko v magistrski predpostavim, da se jih ve? poglej kaj je že bilo v prejšnjih magistrskih
%Zakaj se tipi pojavijo že tukaj, če do tipov še nismo prišli? They are part of syntax. They dont have semantics yet

\section{Uvod} \label{sec:uvod}
%Napišite kratek zgodovinski in matematični uvod.  Pojasnite motivacijo za problem, kje
%nastopa, kje vse je bil obravnavan. Na koncu opišite tudi organizacijo dela -- kaj je v
%katerem razdelku.

%uporabljam programer ali uporabnik??


Če zelo poenostavimo postopek nastajanja program, potem nastane tako, da se v programskem jeziku napiše zaporedje ukazov, ki se jih izvaja enega za drugim. Program $P$ lahko predstavimo z urejeno $n$-terico 
$$P = (k^1, k^2,..., k^n).$$ 
Izvajanje $I_s(P)$ je vrstni red v katerem se izvaja korake in ga lahko predstavimo z urejeno $n$-terico
$$I_s(P) = (k_1^{\pi(1)}, k_2^{\pi(2)},..., k_n^{\pi(n)}),\ k_i^{\pi(i)} = k^{\pi(i)}.$$
Privzeto je $\pi$ identična permutacija. Program je končan, ko so izvedeni vsi koraki. Rezultat končnega programa je običajno rezultat zadnjega izvedenega koraka. Dve izvajanji programa sta ekvivalentni, če sta njuna rezultata enaka. Ker na rezultat vpliva le vrstni red korakov v izvajanju programa bomo zgornji indeks opustili. Kadar se korak $k_i$ začne izvajati, šele ko so se v celoti izvedli vsi koraki $k_1,...,k_{i-1}$, takemu programu pravimo, da je sinhron ali sekvenčen. Če vsak korak potrebuje enoto časa, da se izvede, in korake izvajamo sekvenčno v istem vrstnem redu kot so v $S$ se korak $k_i$ izvede ob času $i$. Koraka $k_i$ in $k_{i+j}$ sta odvisna drug od drugega, kadar se rezultat $k_{i+j}$ spreminja v odvisnosti od rezultata $k_i$ ali kadar se rezultat $k_i+j$ spreminja v odvisnosti od ali je bil $k_i$ izveden prej hkrati ali po $k_{i+j}$. Sicer sta neodvisna. Na primer korak $k_3$, ki vrne spremenljivko $a$ je odvisen od koraka $k_4$, ki poveča $a$ za 1, saj se $k_3$ spremeni, če ga izvedemo za korakom $k_4$. V primeru, da sta korak $k_i$ in $k_{i-1}$ neodvisna, lahko zamenjamo njun vrstni red izvajanja, ne da bi se rezultat kakega koraka spremenil in posledično delovanje celotnega programa.
Če korake izvajamo sekvenčno, z zamenjavo vrstnega reda izvajanja korakov nismo pridobili na času, saj je skupno število korakov v programu ostalo nespremenjeno. Vseeno pa to pomeni, da imamo več možnosti v zaporedju izvajanja programa kamor lahko damo korak $k_i$, da dobimo želeni končen program, kar lahko programerju prihrani čas za razmislek, kam točno ga mora postaviti.


Program $P$ se lahko izvaja tudi drugače. Namesto da se na enkrat izvede le en korak, se izvede nekaj korakov. Novo izvajanje programa lahko predstavimo z urejeno $n$-terico ne praznih množic korakov. 
$$S_p = (t_1, t_2, ... , t_m),\ t_i = \{ k_{1(i)},...k_{l(i)} \}.$$
Koraki v množici $t_i$ se izvedejo ob času $i$. Kadar vsaj ena množica $t_i$ vsebuje vsaj dva ali več korakov, programu pravimo da je vzporeden. V primeru, da so $t_i = \{k_i\}$, sta izvajanji $S_p$ in $S_s$ ekvivalentni.
Če je korak $k_j \in t_i$ neodvisen od vseh preostalih korakov iz $t_{i-1}$ ali $t_i$ v izvajanju $S_p$, bo izvajanje 
$$\tilde{S_p} = (t_1, t_2, ... , t_{i-2}, \tilde{t}_{i-1}, \tilde{t}_i, t_{i+1}, ..., t_m),\ \tilde{t}_{i-1} =t_{i-1} \cup \{k_j\},\ \tilde{t}_i = t_i \setminus \{k_j\}$$ 
ekvivalentno izvajanju $S_p$. 
V primeru, da je $\tilde{t}_i$ prazna množica bo izvajanje 
$$\hat{S_p} = (t_1, t_2, ... , t_{i-2}, \tilde{t}_{i-1}, t_{i+1}, ..., t_m)$$
ekvivalentno prejšnjima dvema z bistveno razliko. Izvajanje $\hat{S_p}$ se konča enota časa prej, kot $S_p$ ali $\tilde{S_p}$. Dokler so pogoji izpolnjeni lahko ta postopek ponavljamo in dobimo izvajanja, ki so ekvivalentna prvotnemu, a bistveno, se hitreje končajo.
Hitrejše izvajanje programa je glavni razlog, da si želimo vzporedno izvajanje programa.


Ugotoviti kateri koraki so med sabo neodvisni je v večini primerov ne trivialno. Programski jezik ugotovi neodvisnost le na najbolj trivialnih primerih. Običajen pristop za reševanje tega problema je zato, da se korake razdeli v procese ali niti. Za koraka $k_i$ in $k_j$ se smatra da sta neodvisna, če pripadata različnemu procesu, razen v primeru ko eksplicitno označimo, da koraka sta odvisna. Sedaj ima programski jezik na voljo veliko več trivialnih korakov, ki jih zna narediti vzporedne. 

Seveda imamo sedaj ne trivialen postopek delitve korakov v procese in označevanje korakov iz različnih procesov, ki so odvisni med sabo. Nepravilna delitev v procese ali napačno označevanje odvisnosti korakov, lahko vodi v izvajanje programa, ki ne bo ekvivalentno prvotnemu. Da se ta postopek olajša kolikor je mogoče, je želeno od programskega jezika, da ima korake, ki naredijo ta postopek čim bolj enostaven in razumljiv. Iz tega razloga imajo nekateri programski jeziki zelo omejeno število različnih vrst korakov, ki so lahko odvisni od korakov izven istega procesa.


Nekateri programski jeziki, predvsem starejše verzije, nimajo direktno podpore za vzporedno izvajanje programa. 
Veliko modernih jezikov, če ne drugega omogočajo tako imenovan POSIX. POSIX je API, ki na operacijskih sistemih, ki ga podpirajo, omogoča uporabo niti~\cite{posix}.
Drugi programski jeziki kot so C++, Java... imajo kot del standardne knjižnice konstrukte, ki jim omogočajo vzporedno izvajanje programa. Čeprav v ozadju mnogi jeziki uporabljajo POSIX, so detajli skriti in zato bolj naravni za programerja. 
Nekateri programski jeziki omogočajo mnoge konstrukte povezane s vzporednim programiranjem, vendar direktno ne omogočajo vzporednega izvajanja. Na primer CPython ima tako imenovan GIL (global  interpreter lock)~\cite{gil}, ki preprečuje tolmaču, da bi izvajal korake iz več kot ene nit na enkrat.
Le redki programski jeziki, recimo Go, pa so bili zasnovani z vzporednim programiranjem v mislih in imajo zato konstrukte potrebne za vzporedno izvajanje vgrajene v jezik.


Eden izmed njih je tudi jezik \aeff{}, ki sloni na računu imenovanem \lae~\cite{aeff}. \aeff{} je ne deterministični statično tipiziran tolmačen funkcijski jezik. Glavni namen \lae{} je pokazati, da je v ozadju vzporednih programskih jezikov lepa teorija. V osnovni verziji \aeff{} omogoča vzporedno izvajanje izračunov, ki lahko po potrebi komunicirajo med sabo s pošiljanjem signalov. 


Najprej si bomo v poglavju \ref{sec:lae} pogledali že obstoječ račun \lae{}. V poglavju \ref{sec:razsirjen-lae} ga bomo razširili z rekurzivno obljubo, razcepom in \jR{Okvir}. V poglavju \ref{sec:impl} si bomo pogledali implementacijo. Obstoječ Hindley–Milnerjev sistem tipov smo zamenjali z dvosmernim sistemom tipov in obstoječ tolmač spremenil,i da omogoča nekoliko bolj optimalno izvajanje. Vse dele implementacije smo prilagodili tudi za razširjen \lae.


%Kakšna je točna relacija med računom in programskim jezikom? Jezik je implementacija računa??

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Račun \lae{}}\label{sec:lae}

Lambda račun je preprost programski jezik, ki je \jR{Turing complete}.


Račun \lae je razširjena verzija Lambda računa. Poleg standardnih izrazov vsebuje še izraze, ki poosebijo bistvo vzporednega programiranja z pošiljanjem sporočil. 
%V marsikaterih programskih jezik se uporablja tako imenovan skupen pomnilnik. To je pomnilnik, do katerega lahko dostopata dva ali več procesov hkrati. Ker je delovanje programa lahko odvisno od vrstnega reda dostopa


\subsection{Vrednosti in izračuni}

Račun \lae{} je formalen jezik. Izraze v \lae{} razdelimo na vrednosti in izračune. 


Vrednosti so sledeče.
Konstante vrednosti naravna števila in logični vrednosti resnica in neresnica.
% TOLE DODAJ ČE BO MAGISTRSKA PREKRATKA DA BODO DALJŠI DOKAZI :D in nekatere aritmetične in logične funkcije kot so $+$, $-$, $*$, $/$, $=$, $<$...
Spremenljivke, ki so simbolična imena povezana z vrednostmi v danem kontekstu.
Enota in par.
leva in desna inkluzija vsote.
Lambda abstrakcije.
Rekurzivne lambda abstrakcije.
Izpolnjena obljuba. Ta vrednost je edina zares nova. Označuje, da je bila obljuba izpolnjena z neko vrednostjo.


Izračuni so sledeči.
Vrni ki drži neko vrednost.
Zaporedje dveh izračunov.
Aplikacija ki v prvi izraz substituira drugi izraz.
Ujemanje ki glede na vzorec izraza izbere izračun. 
Odhajajoči signal vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
Prihajajoči signal vsebuje operacijo, pripadajočo vrednost imenovano tovor in izračun.
prestreznik 
blokada


Pripadajočo sintakso vidimo na~\ref{fig:izrazi} v Backus-Naurjevi obliki (BNF).

%zakaj imajo funkcije sintakso za tip? Ali niso anotacije v ta namen??


%Kaj se zgodi če odstranimo match V with {} ??
%Zakaj nimamo prazne vsote med vrednostmi??
%Odveč če bo prvi in drugi odgovor dober. Vir prazne vsote so exceptni, errorji in neskončne rekurzije? Exceptionov nimamo v jeziku, errorjev nimamo ker imamo tipe, rekurzija lahko nikoli vrne poljuben tip. Pa naj nikoli vrne unit namesto da nikoli vrne prazno vsoto??

%Jaz nebi delil na sekvenčni in vzporedni del??

\begin{figure}[hp]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\intertext{\textbf{Vrednosti}}
		V, W
		\bnfis& n \bnfor\! \true \bnfor\! \false        & &\text{konstantne vrednosti} \\
		\bnfor& x                                       & &\text{spremenljivka} \\
		\bnfor& \tmunit \bnfor\! \tmpair{V}{W}          & &\text{enota in par} \\
		\bnfor& \tminl[Y]{V} \bnfor\! \tminr[X]{V}      & &\text{leva in desna inkluzija} \\
		\bnfor& \tmfun{x}{M}                        & &\text{lambda} \\
		\bnfor& \tmfunrec{f}{x}{M}                        & &\text{rekurzivna lambda} \\
		\bnfor& \tmpromise V                            & &\text{izpolnjena obljuba}
		\\[1ex]
		\intertext{\textbf{Izračuni}}
		M, N
		\bnfis& \tmreturn{V}                            & &\text{vrnjena vrednost} \\
		\bnfor& \tmlet{x}{M}{N}                         & &\text{zaporedje} \\
	%	\bnfor& \tmletrec[: \tyfun{X}{Y}]{f}{x}{M}{N} & &\text{rekurzivna definicija} \\
		\bnfor& V\,W                                    & &\text{aplikacija} \\
		\bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    & &\text{ujemanje produkta} \\
		\bnfor& \tmmatch[]{V}{}                        & &\text{prazno ujemanje} \\
		\bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}	& &\text{ujemanje vsote} \\
		\bnfor& \tmopout{op}{V}{M}       & &\text{odhajajoči signal} \\
		\bnfor& \tmopin{op}{V}{M}          & &\text{prihajajoči signal } \\
		\bnfor& \tmwith{op}{x}{M}{p}{N}      & &\text{prestreznik} \\
		\bnfor& \tmawait{V}{x}{M}             & &\text{blokada}
			\\[1ex]
		\intertext{\textbf{Procesi}}
	%	P \bnfis & ...
		  P, Q
		\bnfis & \tmrun M & & \text{run} \\
		\bnfor & \tmpar P Q & & \text{vzporedna procesa} \\
		\bnfor & \tmopout{op}{V}{P} & & \text{hmmm} \\
		\bnfor & \tmopin{op}{V}{P} & & \text{hmmm}
		\end{align*}
	} 
	\caption{Vrednosti, izračuni in procesi.}
	\label{fig:izrazi}
\end{figure}

%Dobro ime za process, ki ima i/o signal


\subsection{Operacijska semantika}

Račun \lae\ je ...

...

Določenih kombinacij izrazov nimamo v operacijski semantiki, ker niso smiselne. Recimo ...
%aplikacija konstantne funkcije $+$ na enoti. Problem nastane, ker je domena funkcije $+$ števila, čeprav ni nikjer eksplicitno zapisana. Enota ni število. Zato aplikacija $+$ na enoti ni smiselna.
Če \lae pride do izračuna za katerega nima pravila v operacijski semantiki se ustavi. Večina programskih jezikov bi na tem mestu vrnila runtime error.
%V aeff interpreterju je povno assertov, ki bi se sprožili, če bi dobili recimo "true + ()". Kaj točno pa lae naredil?

\subsection{Sistem tipov}

Runtime errorji niso zaželjeni, saj se je program, do takrat ko se sprožijo, potencialno izvajal že zelo dolgo.
Da se jim izognemo, uvedemo sistem tipov. Izraze razdelimo v množice. Množice poimenujemo. Imenu množice rečemo tip. Ko izraz $M$ damo v množico $A$, rečemo, da smo izrazu $M$ dodelili tip $A$ ali da ima $M$ tip $A$. 
Pravila za dodelitev tipa vidimo na~\ref{fig:tipi}.

%Ali se razdelitev elementov v nmnožice ne imenuje particija??



%Zakaj rabimo tip i/o operacij, ki jih bomo morda sprožili??
\begin{figure}[tb]
	\parbox{\textwidth}{
		\centering
		\small
		\begin{align*}
		\text{Osnovni tipi vrednosti $A$, $B$}
		\bnfis& \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \,\bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B}
		\\%[1ex]
		\text{Tipi vrednosti $X$, $Y$}
		\bnfis& A \,\bnfor\! \tyfun{X}{Y} \,\bnfor\! \typromise{X}
		\\
		\text{Tip izračuna} \bnfis& \tycomp{X}
		\end{align*}
	} 
	\caption{Tipi}
	\label{fig:tipi}
\end{figure}



V nekem smislu smo uvedli ekvivalenčno relacijo in sedaj gledamo samo še predstavnika razreda.
 

...

Izrek o varnosti, ki je sestavljen iz izreka o ohranitvi in izreka o napredku nam zagotavlja, da ne moremo dobiti runtime, če imamo tipe, kot smo jih definirali.

\begin{izrek}[Izrek o varnosti]
	Če ima izračun $M$ tip, potem je "varen".
\end{izrek}


\begin{izrek}[Izrek o napredku]
	Če ima izraz $M$ v okolju $\Gamma$ tip $A$, je $M$ vrednost ali pa lahko naredi korak v izraz $M^*$.
\end{izrek}

\begin{proof}
	Če je izraz $M$ vrednost smo končali. Sicer dokazujemo 
\end{proof}


\begin{izrek}[Izrek o ohranitvi]
	Če ima izraz $M$ v okolju $\Gamma$ tip $A$ in naredi korak v izraz $M^*$ ima $M^*$ v okolju $\Gamma$ tip $A$.
\end{izrek}

\begin{proof}
	Left fo the reader as an exercise :D
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Razširjen \lae{}}\label{sec:razsirjen-lae}



\subsection{Rekurzivna obljuba}


\mP{Tole še ni za oddati.}

Kadar pričakujemo več signalov z isto operacijo je lahko iz različnih razlogov za programerja priročno, če ima na voljo obljubo, ki se po potrebi ponovno namesti. Lahko da je namen obljube, da na vsak signal sproži določene učinke. Lahko nam prihajajoči signal prinese pravo operacijo, vendar ne pravega pripadajočega tovora zato obljube še nočemo izpolniti, in čakamo na naslednjega.

To funkcionalnost smo do sedaj dosegli tako, da smo obljubo zapakirali v rekurzivno funkcijo in po potrebi znotraj obljube ponovno klicali to funkcij kot lahko vidimo v programu~\ref{prog:obljuba-v-rekurzivni-funkciji}.


\begin{lstlisting}[caption={Obljuba v rekurzivni funkciji.},label={prog:obljuba-v-rekurzivni-funkciji}]
	let rec f =
	promise (op x -> send op x; f(); return <<()>>) 
	as _ in ()
\end{lstlisting}



Sedaj lahko obljubi dodamo ime lambda funkcije, ki sprejme enoto in ima v abstrakciji za izračun svežo kopijo obljube. To funkcijo lahko uporabimo znotraj pripadajoče obljube.

\begin{definicija}
	promise (op x k -> M) as p in N
\end{definicija}

Program~\ref{prog:rekurzivna-obljuba} ima isti semantičen pomen kot~\ref{prog:obljuba-v-rekurzivni-funkciji} le da je tokrat napisan z rekurzivno obljubo.
\begin{lstlisting}[caption={Rekurzivna obljuba.},label={prog:rekurzivna-obljuba}]
	promise (op x k -> send op x; k())
	as _ in ()
\end{lstlisting}

Prejšnje obstoječe varovane obljube so sedaj sintaktičen sladkor za obljubo, ki zapakira izračun iz abstrakcije v če izračun.
\begin{definicija}

	promise (op x k when x >= 0 -> send op x; k())
	as \_ in ()
	
	-->
	
	promise (op x k -> if x > = then send op x; k() else k())
	as \_ in ()
\end{definicija}

\subsection{Prenosljivi tipi}

\subsection{Spawn}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementacija}\label{sec:impl}

\subsection{Sistem tipov}\label{sec:tipi}

\subsubsection{Hindley–Milner}

\subsubsection{Bidirectional}


\subsection{Tolmač}\label{sec:interpreter}

\subsubsection{prej}

\subsubsection{potem}

Pokazat da, če naredimo korak v nek izračun, obstaja zaporedje korakov v prejšnji, ki vodijo v isti izračun.

Pokazati da potrebujemo "manj korakov" 




% Literatura:
% Primer navajanja na http://www.fmf.uni-lj.si/storage/24240/LiteraturaM.pdf,
% ampak bi moral stil poskrbeti za vse. Reference se uredijo po abecedi.
% Če nobena izbira izmed @book, @atricle,... ni ok, potem se lahko vse napiše v
% @misc pod note={} in deluje tako kot normalen LaTeX.
% Komentar v bib datoteki se naredi samo s parom { }
% Za urejanje literature avtor priporoča program Jabref, ki zna tudi avtomatsko
% okrajšati imena revij. Za pravilno sortiranje vnosov brez avtorja, uporabite
% polje key={ }, kot v primeru.
% V primeru napak ustvarite issue na GitHubu ali pišite na jure.slak@fmf.uni-lj.si.
\cleardoublepage                           % na desni strani
\phantomsection                            % da prav delujejo hiperlinki
\addcontentsline{toc}{section}{\bibname}   % dodajmo v kazalo
\bibliographystyle{fmf-sl}                 % uporabljen stil je v datoteki fmf-sl.bst, na voljo tudi angleška verzija
\bibliography{\literatura}                 % literatura je v datoteki, definirani na začetku
% TeXStudio zmede \ zgoraj, tako da lahko notri napišeš dejansko ime .bib datoteke, če ti
% ne delajo predlogi citatov.

% Za stvarno kazalo
\cleardoublepage                           % na desni strani
\phantomsection                            % da prav delujejo hiperlinki
\addcontentsline{toc}{section}{\indexname} % dodajmo v kazalo
\printindex

\end{document}
