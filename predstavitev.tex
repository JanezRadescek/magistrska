\documentclass{beamer}
\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usetheme{Montpellier} %beamer
\usecolortheme{beaver}

\usepackage{listings} %koda
\usepackage{mathpartir} % inference rules
\usepackage{mathtools} % mathllap


% bold matematika znotraj \textbf{ }, tudi v naslovih, kot \omega spodaj
\makeatletter \g@addto@macro\bfseries{\boldmath} \makeatother



% ukazi za matematična okolja
\theoremstyle{definition} % tekst napisan pokončno
\newtheorem{definicija}{Definicija}[section]
\newtheorem{primer}[definicija]{Primer}
\newtheorem{opomba}[definicija]{Opomba}
\newtheorem{aksiom}{Aksiom}

\theoremstyle{plain} % tekst napisan poševno
\newtheorem{lema}[definicija]{Lema}
\newtheorem{izrek}[definicija]{Izrek}
\newtheorem{trditev}[definicija]{Trditev}
\newtheorem{posledica}[definicija]{Posledica}

\input{macros.tex}


\begin{document}
	
	\title{Asinhroni algebrajski učinki}
	\author[Janez Radešček]{Janez Radešček \\[3mm] Mentor: doc.~dr.~Pretnar~Matija\\[3mm] Somentor: asist.~raz.~dr.~Danel~Ahman}
	\institute{FMF, Univerza v Ljubljani}
	\date{\today}
	
	\frame{\titlepage}
	
	
	\note{Hahahaha}
	
	
	\begin{frame}[fragile]{Uvod}
		\begin{enumerate}
			\item<1-> Običajen program je sekvenčen. 
			%Imamo neke korake, ki jih izvajamo v določenem zaporedju enega za drugim.
		\begin{lstlisting}[numbers=left]
a = 2
b = 5
c = a + b
a = 4
return c
		\end{lstlisting}
			\item<2-> Da bi pohitrili izvajanje, bi radi vzporeden program.
			%Namesto, da naenkrat izvajamo samo en korak, jih lahko več hkrati.
			%Določene korake moramo izvesti kasneje kot določene druge korake. 
			%Recimo koraka 3 sploh ne moremo izvesti dokler se nista izvedla koraka 1 in 2.
			%Bolj kompliciran
			%V splšnem ni enostavno ugotoviti kateri koraki so med sabo odvisni. 

	\end{enumerate}
		
		
		

		
	\end{frame}


	\begin{frame}[fragile]{Uvod}
		
		Standardni pristop je zato sledeč.
		\begin{enumerate}
			\item Korake razporedimo v procese.
			\item Vsi koraki znotraj enega procesa se smatrajo za odvisne in se zato izvedejo sekvenčno.
			\item Za korake iz različnih procesov smatramo da so neodvisni, razen če jih posebej označimo.
		\end{enumerate}
	
		\begin{align*}
		&1\ a = 2       &2\ b = 5 \\
		&3\ c = a + b\ \ : 2& \\
		&4\ a = 4      &\\
		&5\ return\ c   &\\
		\end{align*}
	
		%Problem ugotoviti kateri koraki so odvisni med sabo, smo prevedli na problem delitve korakov v procese.
		%Če korake napačno razdelimo v procese lahko dobimo program z drugačnim rezultatom ali celo takega ki ima napako.
		
	\end{frame}

	\begin{frame}[fragile]{\aeff{}}
		V jeziku potrebujemo nekaj, da lahko razdelimo korake v procese in naredimo korake iz različnih procesov odvisne.
		
		
		TODO prevedi primer v aeff
		
		Programski jezik 
		
		%Da se izognemo problemu kaj z 4. korakom aeff ne omogoča uporabe spremenljivk iz drugih procesov.
		%Kadar bi radi da nek korak le je odvisen od koraka iz drugega procesa to dosežemo s pomočjo efektov. 
		
	\end{frame}

	\begin{frame}{izrazi}
		
		\begin{columns}[T]
			\begin{column}{0.27\textwidth}
				\begin{figure}[hp]
					\parbox{\textwidth}{
						\centering
						\tiny
						\begin{align*}
						\intertext{\textbf{Vrednosti}}
						V, W
						\bnfis& n \bnfor\! \true \bnfor\! \false        \\
						\bnfor& x                                       \\
						\bnfor& \tmunit \bnfor\! \tmpair{V}{W}          \\
						\bnfor& \tminl[Y]{V} \bnfor\! \tminr[X]{V}      \\
						\bnfor& \tmfun{x}{M}                        \\
						\bnfor& \tmfunrec{f}{x}{M}                   \\
						\bnfor& \tmpromise V                           
						\end{align*}
					} 
				\end{figure}
			\end{column}
		
			\begin{column}{0.32\textwidth}
				\begin{figure}[hp]
					\parbox{\textwidth}{
						\centering
						\tiny
						\begin{align*}
						\intertext{\textbf{Izračuni}}
						M, N
						\bnfis& \tmreturn{V}                             \\
						\bnfor& \tmlet{x}{M}{N}                          \\
						\bnfor& V\,W                                   \\
						\bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    \\
						\bnfor& \tmmatch[]{V}{}                         \\
						\bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}	\\
						\bnfor& \tmopout{op}{V}{M}       \\
						\bnfor& \tmopin{op}{V}{M}          \\
						\bnfor& \tmwith{op}{x}{M}{p}{N}      \\
						\bnfor& \tmawait{V}{x}{M}           
						\end{align*}
					} 
				\end{figure}
			\end{column}
		
			\begin{column}{0.42\textwidth}
				\begin{figure}[hp]
					\parbox{\textwidth}{
						\centering
						\tiny
						\begin{align*}
						\intertext{\textbf{Procesi}}
						P, Q
						\bnfis & \tmrun M & & \text{proces} \\
						\bnfor & \tmpar P Q & & \text{vzporedna procesa} \\
						\bnfor & \tmopout{op}{V}{P} & & \text{proces z signalom} \\
						\bnfor & \tmopin{op}{V}{P}  & & \text{proces z prekinitvijo}
						\end{align*}
					} 
				\end{figure}
			\end{column}
		\end{columns}
		
	\end{frame}



	\begin{frame}{Standardna operacijska semantika}
		\begin{figure}[tp]
			\tiny
			\begin{align*}
			\tmapp{(\tmfun{x \of X}{M})}{V} &\reduces M[V/x]
			\\
			\tmapp{(\tmfunrec{f}{x \of X}{M})}{V} &\reduces M[V/x, (\tmfunrec{f}{x \of X}{M})/f]
			\\
			\tmlet{x}{(\tmreturn V)}{N} &\reduces N[V/x]
			\\
			\tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto M} &\reduces M[V/x, W/y]
			\\
			\mathllap{\tmmatch{(\tminl[Y]{V})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	M[V/x]
			\\
			\mathllap{\tmmatch{(\tminr[X]{W})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	N[W/y]
			\end{align*}
		\end{figure}
	\end{frame}


	\begin{frame}{\lae operacijska semantika}
		\begin{figure}[tp]
			\tiny
			\begin{align*}
			\intertext{\textbf{Algebraicity of signals and interrupt handlers}}
			\tmlet{x}{(\tmopout{op}{V}{M})}{N} &\reduces \tmopout{op}{V}{\tmlet{x}{M}{N}}
			\\
			\tmlet{x}{(\tmwith{op}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwith{op}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
			\\[1ex]
			\intertext{\textbf{Commutativity of signals with interrupt handlers}}
			\tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}}
			\\[1ex]
			\intertext{\textbf{Interrupt propagation}}
			\tmopin{op}{V}{\tmreturn W} &\reduces \tmreturn W
			\\
			\tmopin{op}{V}{\tmopout{op'}{W}{M}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{M}}
			\\
			\tmopin{op}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}
			\\
			\tmopin{op'}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmwith{op}{x}{M}{p}{\tmopin{op'}{V}{N}}
			\quad {\color{rulenameColor}(\op \neq \op')}
			\\[1ex]
			\intertext{\quad\,\textbf{Awaiting a promise to be fulfilled}}
			\tmawait{\tmpromise V}{x}{M} &\reduces M[V/x]
			\end{align*}
		\end{figure}
	\end{frame}

	
	\begin{frame}{\lae operacijska semantika}
		\vspace{-2ex}
		\begin{minipage}[t]{\textwidth}
			\tiny
			\centering
			\begin{align*}
			\shortintertext{\textbf{Evaluation context rule}}
			\coopinfer{}{
				M \reduces N
			}{
				\E[M] \reduces \E[N]
			}
			\end{align*}
			\vspace{-10ex}
		\end{minipage}
		
		\begin{figure}[tp]
			\tiny
			\begin{align*}
				\shortintertext{\textbf{where}}
				\text{$\E$}
				\bnfis [~]
				\bnfor \tmlet{x}{\E}{N}
				\bnfor \tmopout{op}{V}{\E}
				\bnfor \tmopin{op}{V}{\E}
				\bnfor \tmwith{op}{x}{M}{p}{\E}
			\end{align*}
			\vspace{-10ex}
		\end{figure}
	\end{frame}


	\begin{frame}
		\begin{figure}[tp]
			\parbox{\textwidth}{
				\centering
				\tiny
				\begin{minipage}[t]{0.4\textwidth}
					\centering
					\begin{align*}
					\shortintertext{\textbf{Individual computations}}
					\coopinfer{}{
						M \reduces N
					}{
						\tmrun M \reduces \tmrun N
					}
					\end{align*}
				\end{minipage}
				\qquad
				\begin{minipage}[t]{0.4\textwidth}
					\centering
					\begin{align*}
					\shortintertext{\textbf{Interrupt propagation}}
					\tmopin{op}{V}{\tmrun M} &\reduces \tmrun {(\tmopin{op}{V}{M})}
					\\
					\tmopin{op}{V}{\tmpar P Q} &\reduces \tmpar {\tmopin{op}{V}{P}} {\tmopin{op}{V}{Q}}
					\\
					\tmopin{op}{V}{\tmopout{op'}{W}{P}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{P}}
					\end{align*}
				\end{minipage}
			
				
				
				%%%%
				
				\begin{minipage}[t]{0.4\textwidth}
					\centering
					\begin{align*}
					\shortintertext{\textbf{Signal hoisting}}
					\tmrun {(\tmopout{op}{V}{M})}  &\reduces \tmopout{op}{V}{\tmrun M}
					\end{align*}
				\end{minipage}
				\qquad
				\begin{minipage}[t]{0.4\textwidth}
					\centering
					\begin{align*}
					\shortintertext{\textbf{Broadcasting}}
					\tmpar{\tmopout{op}{V}{P}}{Q} &\reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
					\\
					\tmpar{P}{\tmopout{op}{V}{Q}} &\reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{P}}{Q}}
					\end{align*}
				\end{minipage}
				
				%%%%
		
				\begin{align*}
				\shortintertext{\quad\textbf{Evaluation context rule}}
				\quad
				\coopinfer{}{
					P \reduces Q
				}{
					\F[P] \reduces \F[Q]
				}
				\end{align*}
				\vspace{-8ex}
				\begin{align*}
				\shortintertext{\textbf{where}\vspace{1ex}}
				\text{$\F$}
				\bnfis& [~]
				\bnfor \tmpar \F Q \bnfor\! \tmpar P \F
				\bnfor \tmopout{op}{V}{\F}
				\bnfor \tmopin{op}{V}{\F}
				\end{align*}
			} 
		\end{figure}
	\end{frame}


	\begin{frame}{tipi}
	\begin{figure}[tb]
		\parbox{\textwidth}{
			\centering
			\tiny
			\begin{align*}
			\text{Osnovni tipi vrednosti $A_\op$, $B_\op$}
			\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \\
			\bnfor & \typrod{A_\op}{B_\op} \,\bnfor\! \tysum{A_\op}{B_\op}
			\\%[1ex]
			\text{Tipi vrednosti $A$, $B$}
			\bnfis & A_\op \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{B} \,\bnfor\! \typromise{A}
			\\
			\text{Tip izračuna} \bnfis& \tycomp{A}
			\\
			\text{Tip procesa \tyC, \tyD}  \bnfis & \tyrun{A} \,\bnfor\! \typar{\tyC}{\tyD}
			\end{align*}
		} 
	\end{figure}
	\end{frame}

	\begin{frame}{pravila za tipe vrednosti}
		\begin{figure}[tp]
			\centering
			\tiny
			\begin{mathpar}
				\coopinfer{}{
				}{
					\Gamma \types n : \tysym{int}
				}
				\qquad
				\coopinfer{}{
				}{
					\Gamma \types \true : \tysym{bool}
				}
				\qquad
				\coopinfer{}{
				}{
					\Gamma \types \false : \tysym{bool}
				}
				\quad
				\coopinfer{}{
				}{
					\Gamma, x \of A, \Gamma' \types x : A
				}
				\quad
				\coopinfer{}{
				}{
					\Gamma \types \tmunit : \tyunit
				}
				\\
				\coopinfer{}{
					\Gamma \types V : A \\
					\Gamma \types W : B
				}{
					\Gamma \types \tmpair{V}{W} : \typrod{A}{B}
				}
				\quad
				\coopinfer{}{
					\Gamma \types V : A
				}{
					\Gamma \types \tmpromise V : \typromise A
				}
				\quad
				\coopinfer{}{
					\Gamma \types V : A
				}{
					\Gamma \types \tminl[B]{V} : A + B
				}
				\quad
				\coopinfer{}{
					\Gamma \types W : B
				}{
					\Gamma \types \tminr[A]{W} : A + B
				}
				\\
				\coopinfer{}{
					\Gamma, x \of A \types M : B
				}{
					\Gamma \types \tmfun{x : A}{M} : \tyfun{A}{B}
				}
				\quad
				\coopinfer{}{
					\Gamma, x \of A \types M : B
				}{
					\Gamma \types \tmfunrec{f}{x : A}{M} : \tyfun{A}{B}
				}
			\end{mathpar}
		\end{figure}
	\end{frame}

	\begin{frame}{pravila za tipe računov}
		\begin{figure}[tp]
			\centering
			\tiny
			\begin{mathpar}
				\coopinfer{}{
					\Gamma \types V : X
				}{
					\Gamma \types \tmreturn{V} : X
				}
				\qquad
				\coopinfer{}{
					\Gamma \types M : X
					\\
					\Gamma, x \of X \types N : Y
				}{
					\Gamma \types
					\tmlet{x}{M}{N} : Y
				}
				\qquad
				\coopinfer{}{
					\Gamma \types V : \tyfun{X}{Y} \\
					\Gamma \types W : X
				}{
					\Gamma \types \tmapp{V}{W} : Y
				}
				\\
				\coopinfer{}{
					\Gamma \types V : \typrod{X}{Y} \\
					\Gamma, x \of X, y \of Y \types M : Z
				}{
					\Gamma \types \tmmatch{V}{\tmpair{x}{y} \mapsto M} : Z
				}
				\qquad
				\coopinfer{}{
					\Gamma \types V : \tyempty
				}{
					\Gamma \types \tmmatch[Z]{V}{} : Z
				}
				\\
				\coopinfer{}{
					\Gamma \types V : X + Y \\\\
					\Gamma, x \of X \types M : Z \\
					\Gamma, y \of Y \types N : Z \\
				}{
					\Gamma \types \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} : Z
				}
				\\
				\coopinfer{}{
					\Gamma \types V : A_\op \\
					\Gamma \types M : X 
				}{
					\Gamma \types \tmopout{op}{V}{M} : X
				}
				\qquad
				\coopinfer{}{
					\Gamma \types V : A_\op \\
					\Gamma \types M : X 
				}{
					\Gamma \types \tmopin{op}{V}{M} : X
				}
				\\
				\coopinfer{}{
					\Gamma, x \of A_\op \types M : \typromise X \\
					\Gamma, p \of \typromise X \types N : Y 
				}{
					\Gamma \types \tmwith{op}{x}{M}{p}{N} : Y
				}
				\\
				\coopinfer{}{
					\Gamma \types V : \typromise X \\
					\Gamma, x \of X \types M : Y 
				}{
					\Gamma \types \tmawait{V}{x}{M} : Y
				}
			\end{mathpar}
		\end{figure}
	\end{frame}


	\begin{frame}{pravila za tipe procesov}
		\begin{figure}[tp]
			\centering
			\small
			\begin{mathpar}
				\coopinfer{}{
					\Gamma \types M : \tycomp{A}
				}{
					\Gamma \types \tmrun{M} : \tyrun{A}
				}
				\quad
				\coopinfer{}{
					\Gamma \types P : \tyC \\
					\Gamma \types Q : \tyD
				}{
					\Gamma \types \tmpar{P}{Q} : \typar{\tyC}{\tyD}
				}
				\\
				\coopinfer{}{
					\Gamma \types V : A_\op \\
					\Gamma \types P : \tyC 
				}{
					\Gamma \types \tmopout{op}{V}{P} : \tyC
				}
				\quad
				\coopinfer{}{
					\Gamma \types V : A_\op \\
					\Gamma \types P : \tyC 
				}{
					\Gamma \types \tmopin{op}{V}{P} : \tyC
				}  
			\end{mathpar}
		\end{figure}
	\end{frame}

	
	\begin{frame}{Napredek}
		
		\begin{izrek}[o napredku]
			Če ima izraz $M$ v okolju $\Gamma$ tip $A$, je $M$ vrednost ali pa lahko naredi korak v izraz $M^*$.
		\end{izrek}
		
		\begin{proof}
			... 
		\end{proof}
		
	\end{frame}

	
		
	\begin{frame}{Ohranitev}
				
		\begin{izrek}[o ohranitvi]
			Če ima izraz $M$ v okolju $\Gamma$ tip $A$ in naredi korak v izraz $M^*$, ima $M^*$ v okolju $\Gamma$ tip $A$.
		\end{izrek}
		
		\begin{proof}
			%Left for the reader as an exercise :D
		\end{proof}
		
	\end{frame}


	\begin{frame}{Razširitev}
		
		Za dano $n$-terico $(z_1,...,z_n)$ kompleksnih števil iz enotskega diska, kjer so elementi paroma različni, in dano $n$-terico $(w_1,...,w_n)$ kompleksnih števil Pick-Nevalinnov problem sprašuje po potrebnih in zadostnih pogojih na ta števila, da obstaja holomorfna funkcija $f$ na enotskem disku po absolutni vrednosti pod 1, ki interpolira dane podatke: $f(z_i) = w_i$ za $i = 1,...,n$. 

		\begin{definicija}
			Naj bo $n$-terica točk $(a_1,...,a_n) \subset A$, kjer so elementi paroma različni in $n$-terica točk $(b_1,...,b_n) \subset B$. Interpolacija je funkcija $f:A \rightarrow B$ za katero velja: $f(a_i) = b_i$. Za tako funkcijo  $f$ pravimo da interpolira $(a_1,...,a_n)$ v  $(b_1,...,b_n)$.
		\end{definicija}
		
	\end{frame}
	
	
	
	
	\begin{frame}{Literatura}
		\begin{thebibliography}{1}
			
			\bibitem{bib1} 
			Donald E. Marshall:
			An elementary proof of the Pick-Nevanlinna interpolation theorem, dostopno na:
			\url{https://projecteuclid.org/download/pdf_1/euclid.mmj/1029001307}
			
			
			
		\end{thebibliography}
	\end{frame}
	
	
\end{document}