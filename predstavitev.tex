\documentclass{beamer}
\usepackage[slovene]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usetheme{Montpellier} %beamer
\usecolortheme{beaver}

\usepackage{listings} %koda
\usepackage{mathpartir} % inference rules
\usepackage{mathtools} % mathllap


% bold matematika znotraj \textbf{ }, tudi v naslovih, kot \omega spodaj
\makeatletter \g@addto@macro\bfseries{\boldmath} \makeatother



% ukazi za matematična okolja
\theoremstyle{definition} % tekst napisan pokončno
\newtheorem{definicija}{Definicija}[section]
\newtheorem{primer}[definicija]{Primer}
\newtheorem{opomba}[definicija]{Opomba}
\newtheorem{aksiom}{Aksiom}

\theoremstyle{plain} % tekst napisan poševno
\newtheorem{lema}[definicija]{Lema}
\newtheorem{izrek}[definicija]{Izrek}
\newtheorem{trditev}[definicija]{Trditev}
\newtheorem{posledica}[definicija]{Posledica}

\input{macros.tex}


\begin{document}
	
	\title{Asinhroni algebrajski učinki}
	\author[Janez Radešček]{Janez Radešček \\[3mm] Mentor: doc.~dr.~Pretnar~Matija\\[3mm] Somentor: asist.~raz.~dr.~Danel~Ahman}
	\institute{FMF, Univerza v Ljubljani}
	\date{\today}
	
	\frame{\titlepage}
	
	
	\note{Hahahaha}
	
	
	\begin{frame}[fragile]{Uvod}
		\begin{enumerate}
			\item Običajen program je sekvenčen. 
			%Imamo neke korake, ki jih izvajamo v določenem zaporedju enega za drugim.
			
			\begin{columns}[T]
				\begin{column}{0.2\textwidth}
					\begin{align*}
					&1\ a \gets 2  \\
					&2\ b \gets 5 \\
					&3\ c \gets b + 1 \\
					&4\ d \gets a + c \\
					&5\ return\ c 
					\end{align*}
					\vspace{0.1ex}
				\end{column}
				\begin{column}{0.5\textwidth}
				\end{column}
			\end{columns}
		
			\item Da bi pohitrili izvajanje, bi radi vzporeden program.
			%Namesto, da naenkrat izvajamo samo en korak, jih lahko več hkrati.
			%Običajno ne moremo izvesti vseh korakov hkrati.
			%Določene korake moramo izvesti kasneje kot določene druge korake, ker so med sabo odvisni. 
			%Recimo koraka 3 ne moremo izvesti dokler se ni izvedel korak 2.
			%Podobno 4
			%V splšnem ni enostavno ugotoviti kateri koraki so med sabo odvisni. 

		\end{enumerate}	
	\end{frame}


	\begin{frame}[fragile]{Uvod}
		
		Standardni pristop je zato sledeč.
		\begin{enumerate}
			\item Korake razporedimo v procese.
			\item Vsi koraki znotraj enega procesa se smatrajo za odvisne in se zato izvedejo sekvenčno.
			\item Za korake iz različnih procesov smatramo da so neodvisni, razen če jih posebej označimo.
		\end{enumerate}
	
		\begin{columns}[T]
			\begin{column}{0.15\textwidth}
				\begin{align*}
				&1\ a \gets 2  \\
				& \\
				& \\
				&4\ d \gets a + c\ \ : 3 \\
				&5\ return\ c 
				\end{align*}
				\vspace{0.1ex}
			\end{column}
			\begin{column}{0.15\textwidth}
				\begin{align*}
				& &  \\
				&               &2\ b \gets 5 \\
				&               &3\ c \gets b + 1 \\
				&& \\
				&&\\
				\end{align*}
			\end{column}
			\begin{column}{0.05\textwidth}
			\end{column}
		\end{columns}
	
		%Problem ugotoviti kateri koraki so odvisni med sabo, smo prevedli na problem delitve korakov v procese.
		%Če korake napačno razdelimo v procese lahko dobimo program z drugačnim rezultatom ali celo takega ki ima napako.
		
	\end{frame}

	\begin{frame}[fragile]{\aeff{}}
		V jeziku potrebujemo nekaj, da lahko razdelimo korake v procese in naredimo korake iz različnih procesov odvisne.
		
		
		TODO prevedi primer v aeff
		
		Programski jezik 
		
		%Da se izognemo problemu kaj z 4. korakom aeff ne omogoča uporabe spremenljivk iz drugih procesov.
		%Kadar bi radi da nek korak le je odvisen od koraka iz drugega procesa to dosežemo s pomočjo efektov. 
		
	\end{frame}



	\begin{frame}{izrazi}


		\begin{columns}[T]
			\begin{column}{0.27\textwidth}
				\begin{figure}[hp]
					\parbox{\textwidth}{
						\centering
						\tiny
						\begin{align*}
						\intertext{\textbf{Vrednosti}}
						V, W
						\bnfis& n \bnfor\! \true \bnfor\! \false        \\
						\bnfor& x                                       \\
						\bnfor& \tmunit \bnfor\! \tmpair{V}{W}          \\
						\bnfor& \tminl[Y]{V} \bnfor\! \tminr[X]{V}      \\
						\bnfor& \tmfun{x}{M}                        \\
						\bnfor& \tmfunrec{f}{x}{M}                   \\
						\bnfor& \tmpromise V                           
						\end{align*}
					} 
				\end{figure}
			\end{column}
		
			\begin{column}{0.32\textwidth}
				\begin{figure}[hp]
					\parbox{\textwidth}{
						\centering
						\tiny
						\begin{align*}
						\intertext{\textbf{Izračuni}}
						M, N
						\bnfis& \tmreturn{V}                             \\
						\bnfor& \tmlet{x}{M}{N}                          \\
						\bnfor& V\,W                                   \\
						\bnfor& \tmmatch{V}{\tmpair{x}{y} \mapsto M}    \\
						\bnfor& \tmmatch[]{V}{}                         \\
						\bnfor& \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}	\\
						\bnfor& \tmopout{op}{V}{M}       \\
						\bnfor& \tmopin{op}{V}{M}          \\
						\bnfor& \tmwith{op}{x}{M}{p}{N}      \\
						\bnfor& \tmawait{V}{x}{M}           
						\end{align*}
					} 
				\end{figure}
			\end{column}
		
			\begin{column}{0.42\textwidth}
				\begin{figure}[hp]
					\parbox{\textwidth}{
						\centering
						\tiny
						\begin{align*}
						\intertext{\textbf{Procesi}}
						P, Q
						\bnfis & \tmrun M & & \text{proces} \\
						\bnfor & \tmpar P Q & & \text{vzporedna procesa} \\
						\bnfor & \tmopout{op}{V}{P} & & \text{proces z signalom} \\
						\bnfor & \tmopin{op}{V}{P}  & & \text{proces z prekinitvijo}
						\end{align*}
					} 
				\end{figure}
			\end{column}
		\end{columns}
		
	\end{frame}



	\begin{frame}{Standardna operacijska semantika izračunov}
		\begin{figure}[tp]
			\tiny
			\begin{align*}
			\tmapp{(\tmfun{x \of X}{M})}{V} &\reduces M[V/x]
			\\
			\tmapp{(\tmfunrec{f}{x \of X}{M})}{V} &\reduces M[V/x, (\tmfunrec{f}{x \of X}{M})/f]
			\\
			\tmlet{x}{(\tmreturn V)}{N} &\reduces N[V/x]
			\\
			\tmmatch{\tmpair{V}{W}}{\tmpair{x}{y} \mapsto M} &\reduces M[V/x, W/y]
			\\
			\mathllap{\tmmatch{(\tminl[Y]{V})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	M[V/x]
			\\
			\mathllap{\tmmatch{(\tminr[X]{W})}{\tminl{x} \mapsto M, \tminr{y} \mapsto N}} &\reduces	N[W/y]
			\end{align*}
		\end{figure}
	\end{frame}


	\begin{frame}{\lae{} operacijska semantika izračunov}
		\begin{figure}[tp]
			\tiny
			\begin{align*}
			\intertext{\textbf{Algebraicity of signals and interrupt handlers}}
			\tmlet{x}{(\tmopout{op}{V}{M})}{N} &\reduces \tmopout{op}{V}{\tmlet{x}{M}{N}}
			\\
			\tmlet{x}{(\tmwith{op}{y}{M}{p}{N_1})}{N_2} &\reduces \tmwith{op}{y}{M}{p}{(\tmlet{x}{N_1}{N_2})}
			\\[1ex]
			\intertext{\textbf{Commutativity of signals with interrupt handlers}}
			\tmwith{op}{x}{M}{p}{\tmopout{op'}{V}{N}} &\reduces \tmopout{op'}{V}{\tmwith{op}{x}{M}{p}{N}}
			\\[1ex]
			\intertext{\textbf{Interrupt propagation}}
			\tmopin{op}{V}{\tmreturn W} &\reduces \tmreturn W
			\\
			\tmopin{op}{V}{\tmopout{op'}{W}{M}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{M}}
			\\
			\tmopin{op}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}
			\\
			\tmopin{op'}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmwith{op}{x}{M}{p}{\tmopin{op'}{V}{N}}
			\quad {\color{rulenameColor}(\op \neq \op')}
			\\[1ex]
			\intertext{\quad\,\textbf{Awaiting a promise to be fulfilled}}
			\tmawait{\tmpromise V}{x}{M} &\reduces M[V/x]
			\end{align*}
		\end{figure}
	\end{frame}

	
	\begin{frame}{\lae{} operacijska semantika okolja}
		\vspace{-2ex}
		\begin{minipage}[t]{\textwidth}
			\tiny
			\centering
			\begin{align*}
			\shortintertext{\textbf{Evaluation context rule}}
			\coopinfer{}{
				M \reduces N
			}{
				\E[M] \reduces \E[N]
			}
			\end{align*}
			\vspace{-10ex}
		\end{minipage}
		
		\begin{figure}[tp]
			\tiny
			\begin{align*}
				\shortintertext{\textbf{where}}
				\text{$\E$}
				\bnfis [~]
				\bnfor \tmlet{x}{\E}{N}
				\bnfor \tmopout{op}{V}{\E}
				\bnfor \tmopin{op}{V}{\E}
				\bnfor \tmwith{op}{x}{M}{p}{\E}
			\end{align*}
			\vspace{-10ex}
		\end{figure}
	\end{frame}


	\begin{frame}{\lae{} operacijska semantika procesov}
		\begin{figure}[tp]
			\parbox{\textwidth}{
				\centering
				\tiny
				\begin{minipage}[t]{0.4\textwidth}
					\centering
					\begin{align*}
					\shortintertext{\textbf{Posamezen proces}}
					\coopinfer{}{
						M \reduces N
					}{
						\tmrun M \reduces \tmrun N
					}
					\end{align*}
				\end{minipage}
				\qquad
				\begin{minipage}[t]{0.4\textwidth}
					\centering
					\begin{align*}
					\shortintertext{\textbf{Širitev prekinitve}}
					\tmopin{op}{V}{\tmrun M} &\reduces \tmrun {(\tmopin{op}{V}{M})}
					\\
					\tmopin{op}{V}{\tmpar P Q} &\reduces \tmpar {\tmopin{op}{V}{P}} {\tmopin{op}{V}{Q}}
					\\
					\tmopin{op}{V}{\tmopout{op'}{W}{P}} &\reduces \tmopout{op'}{W}{\tmopin{op}{V}{P}}
					\end{align*}
				\end{minipage}
			
				
				
				%%%%
				
				\begin{minipage}[t]{0.4\textwidth}
					\centering
					\begin{align*}
					\shortintertext{\textbf{dvig signala}}
					\tmrun {(\tmopout{op}{V}{M})}  &\reduces \tmopout{op}{V}{\tmrun M}
					\end{align*}
				\end{minipage}
				\qquad
				\begin{minipage}[t]{0.4\textwidth}
					\centering
					\begin{align*}
					\shortintertext{\textbf{oddajanje signala}}
					\tmpar{\tmopout{op}{V}{P}}{Q} &\reduces \tmopout{op}{V}{\tmpar{P}{\tmopin{op}{V}{Q}}}
					\\
					\tmpar{P}{\tmopout{op}{V}{Q}} &\reduces \tmopout{op}{V}{\tmpar{\tmopin{op}{V}{P}}{Q}}
					\end{align*}
				\end{minipage}
				
				%%%%
		
				\begin{align*}
				\shortintertext{\quad\textbf{Evaluation context rule}}
				\quad
				\coopinfer{}{
					P \reduces Q
				}{
					\F[P] \reduces \F[Q]
				}
				\end{align*}
				\vspace{-8ex}
				\begin{align*}
				\shortintertext{\textbf{where}\vspace{1ex}}
				\text{$\F$}
				\bnfis& [~]
				\bnfor \tmpar \F Q \bnfor\! \tmpar P \F
				\bnfor \tmopout{op}{V}{\F}
				\bnfor \tmopin{op}{V}{\F}
				\end{align*}
			} 
		\end{figure}
	\end{frame}



	\begin{frame}{tipi in operacije}
		\begin{figure}[tb]
			\parbox{\textwidth}{
				\centering
				\tiny
				\begin{align*}
				\text{Osnovni tipi vrednosti $\bar{A}$, $\bar{B}$}
				\bnfis & \tysym{int} \,\bnfor\! \tysym{bool} \,\bnfor\! \tyunit \,\bnfor\! \tyempty \, 
				          \bnfor\! \typrod{\bar{A}}{\bar{B}} \,\bnfor\! \tysum{\bar{A}}{\bar{B}}
				\\
				\text{Tipi vrednosti $A$, $B$}
				\bnfis & \bar{A} \, \bnfor\! \typrod{A}{B} \,\bnfor\! \tysum{A}{B} \,\bnfor\! \tyfun{A}{B} \,\bnfor\! \typromise{A}
				\\
				\text{Tip izračuna} \bnfis& \tycomp{A}
				\\
				\text{Tip procesa \tyC, \tyD}  \bnfis & \tyrun{A} \,\bnfor\! \typar{\tyC}{\tyD}
				\end{align*}
			} 
		\end{figure}
	
		\begin{figure}
			\centering
			\tiny
			\begin{align*}
			\intertext{Operacije}
			(op_1, A_{op_1}),\, (op_2, A_{op_2}),\, ... ,\, (op_n, A_{op_k})
			\end{align*}
			\vspace{-15ex}
		\end{figure}
	\end{frame}

	\begin{frame}{pravila za tipe vrednosti}
		\begin{figure}[tp]
			\centering
			\tiny
			\begin{mathpar}
				\coopinfer{}{
				}{
					\Gamma \types n : \tysym{int}
				}
				\qquad
				\coopinfer{}{
				}{
					\Gamma \types \true : \tysym{bool}
				}
				\qquad
				\coopinfer{}{
				}{
					\Gamma \types \false : \tysym{bool}
				}
				\quad
				\coopinfer{}{
				}{
					\Gamma, x \of A, \Gamma' \types x : A
				}
				\quad
				\coopinfer{}{
				}{
					\Gamma \types \tmunit : \tyunit
				}
				\\
				\coopinfer{}{
					\Gamma \types V : A \\
					\Gamma \types W : B
				}{
					\Gamma \types \tmpair{V}{W} : \typrod{A}{B}
				}
				\quad
				\coopinfer{}{
					\Gamma \types V : A
				}{
					\Gamma \types \tmpromise V : \typromise A
				}
				\quad
				\coopinfer{}{
					\Gamma \types V : A
				}{
					\Gamma \types \tminl[B]{V} : A + B
				}
				\quad
				\coopinfer{}{
					\Gamma \types W : B
				}{
					\Gamma \types \tminr[A]{W} : A + B
				}
				\\
				\coopinfer{}{
					\Gamma, x \of A \types M : B
				}{
					\Gamma \types \tmfun{x : A}{M} : \tyfun{A}{B}
				}
				\quad
				\coopinfer{}{
					\Gamma, x \of A \types M : B
				}{
					\Gamma \types \tmfunrec{f}{x : A}{M} : \tyfun{A}{B}
				}
			\end{mathpar}
		\end{figure}
	\end{frame}

	\begin{frame}{pravila za tipe računov}
		\begin{figure}[tp]
			\centering
			\tiny
			\begin{mathpar}
				\coopinfer{}{
					\Gamma \types V : X
				}{
					\Gamma \types \tmreturn{V} : X
				}
				\qquad
				\coopinfer{}{
					\Gamma \types M : X
					\\
					\Gamma, x \of X \types N : Y
				}{
					\Gamma \types
					\tmlet{x}{M}{N} : Y
				}
				\qquad
				\coopinfer{}{
					\Gamma \types V : \tyfun{X}{Y} \\
					\Gamma \types W : X
				}{
					\Gamma \types \tmapp{V}{W} : Y
				}
				\\
				\coopinfer{}{
					\Gamma \types V : \typrod{X}{Y} \\
					\Gamma, x \of X, y \of Y \types M : Z
				}{
					\Gamma \types \tmmatch{V}{\tmpair{x}{y} \mapsto M} : Z
				}
				\qquad
				\coopinfer{}{
					\Gamma \types V : \tyempty
				}{
					\Gamma \types \tmmatch[Z]{V}{} : Z
				}
				\\
				\coopinfer{}{
					\Gamma \types V : X + Y \\\\
					\Gamma, x \of X \types M : Z \\
					\Gamma, y \of Y \types N : Z \\
				}{
					\Gamma \types \tmmatch{V}{\tminl{x} \mapsto M, \tminr{y} \mapsto N} : Z
				}
				\\
				\coopinfer{}{
					\Gamma \types V : A_\op \\
					\Gamma \types M : X 
				}{
					\Gamma \types \tmopout{op}{V}{M} : X
				}
				\qquad
				\coopinfer{}{
					\Gamma \types V : A_\op \\
					\Gamma \types M : X 
				}{
					\Gamma \types \tmopin{op}{V}{M} : X
				}
				\\
				\coopinfer{}{
					\Gamma, x \of A_\op \types M : \typromise X \\
					\Gamma, p \of \typromise X \types N : Y 
				}{
					\Gamma \types \tmwith{op}{x}{M}{p}{N} : Y
				}
				\\
				\coopinfer{}{
					\Gamma \types V : \typromise X \\
					\Gamma, x \of X \types M : Y 
				}{
					\Gamma \types \tmawait{V}{x}{M} : Y
				}
			\end{mathpar}
		\end{figure}
	\end{frame}


	\begin{frame}{Pravila za tipe procesov}
		\begin{figure}[tp]
			\centering
			\small
			\begin{mathpar}
				\coopinfer{}{
					\Gamma \types M : \tycomp{A}
				}{
					\Gamma \types \tmrun{M} : \tyrun{A}
				}
				\quad
				\coopinfer{}{
					\Gamma \types P : \tyC \\
					\Gamma \types Q : \tyD
				}{
					\Gamma \types \tmpar{P}{Q} : \typar{\tyC}{\tyD}
				}
				\\
				\coopinfer{}{
					\Gamma \types V : A_\op \\
					\Gamma \types P : \tyC 
				}{
					\Gamma \types \tmopout{op}{V}{P} : \tyC
				}
				\quad
				\coopinfer{}{
					\Gamma \types V : A_\op \\
					\Gamma \types P : \tyC 
				}{
					\Gamma \types \tmopin{op}{V}{P} : \tyC
				}  
			\end{mathpar}
		\end{figure}
	\end{frame}

	\begin{frame}{Izpeljava tipov}
		TODO predvsem primer
	\end{frame}


	\begin{frame}{Rezultati}
		TODO
	\end{frame}

	
	\begin{frame}{Napredek}
		
		\begin{izrek}[o napredku]
			Če ima izraz $M$ v okolju $\Gamma$ tip $A$, je $M$ rezultat ali pa lahko naredi korak v izraz $M^*$.
		\end{izrek}
		
		\begin{proof}
			... 
			Dokazujemo z indukcijo na izpeljavo tipa tipa $A$.
			Zadnji 
		\end{proof}
		
	\end{frame}

	
		
	\begin{frame}{Ohranitev}
				
		\begin{izrek}[o ohranitvi]
			Če ima izraz $M$ v okolju $\Gamma$ tip $A$ in naredi korak v izraz $M^*$, ima $M^*$ v okolju $\Gamma$ tip $A$.
		\end{izrek}
		
		\begin{proof}
			%Left for the reader as an exercise :D
		\end{proof}
		
	\end{frame}



	\begin{frame}{Rekurzivne obljube}
		\begin{figure}[hp]
			\parbox{\textwidth}{
				\centering
				\tiny
				\begin{align*}
				\shortintertext{\textbf{Izračuni}}
				M, N
				\bnfis& ... \,\bnfor \tmwithrec{op}{f}{x \of A}{M \of \typromise{B}}{p}{N}                   
				\end{align*}
			} 
		\end{figure}
	
		\begin{figure}[tp]
			\centering
			\tiny
			\begin{align*}
			\shortintertext{\textbf{Operacijska semantika}}
			\tmopin{op}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmlet{p}{M[V/x]}{\tmopin{op}{V}{N}}
			\\
			\tmopin{op'}{V}{\tmwith{op}{x}{M}{p}{N}} &\reduces \tmwith{op}{x}{M}{p}{\tmopin{op'}{V}{N}}
			\quad {\color{rulenameColor}(\op \neq \op')}
			\end{align*}
		\end{figure}
		
		\begin{figure}[tp]
			\centering
			\tiny
			\textbf{Pravila za tipe računov}
			\begin{mathpar}
				\coopinfer{}{
					\Gamma, f \of \tyfun{A_\op}{\typromise{B}}, x \of A_\op \types M : \typromise B \\
					\Gamma, p \of \typromise B \types N : C 
				}{
					\Gamma \types \tmwithrec{op}{f}{x : A}{M : \typromise{B}}{p}{N} : C
				}
	
			\end{mathpar}
		\end{figure}
		
	\end{frame}




	\begin{frame}{Prenosljivi tipi}

		\begin{figure}[hp]
			\parbox{\textwidth}{
				\centering
				\tiny
				\begin{align*}
				\shortintertext{\textbf{Vrednosti}}
				V, W
				\bnfis & ... \,\bnfor\! \tmboxed{V}     
				\\[5ex]
				\shortintertext{\textbf{Izračuni}}
				M, N
				\bnfis & ... \,\bnfor\! \tmunbox{V}{u}{M}
				\end{align*}
			} 
		\end{figure}
		
		\begin{figure}[tp]
			\centering
			\tiny
			\begin{align*}
			\shortintertext{\textbf{Operacijska semantika}}
			\tmunbox{V}{u}{M} & \reduces M[V/u]
			\end{align*}
		\end{figure}
		
		\begin{figure}[tp]
			\centering
			\tiny
			\textbf{Pravila za tipe računov}
			TODO
		\end{figure}
		
	\end{frame}
	
	
	
	
	\begin{frame}{Implementacija}
		\begin{enumerate}
			\item sistem tipov
			%Je kakšen boljši razlog za uvedbo bidirectional type sistem v trenutni verziji kot malo boljši izpis napake?
			\item operacijska semantika
		\end{enumerate}
	\end{frame}
	
	
	
	
	\begin{frame}{Literatura}
		
		\bibliographystyle{fmf-sl}
		\bibliography{literatura}
		
		\phantom{\cite{aeff}}
	\end{frame}
	
	
\end{document}