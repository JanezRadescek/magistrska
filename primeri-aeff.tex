\section{Primeri v \aeff{}} \label{sec:primeri-aeff}

Poglejmo si sledeči sekvenčni sinhroni primer. Poračunati moramo zelo zahtevno in počasno točno funkcijo in prikazati njen rezultat na zaslonu. Ker je tako zelo počasna, preden se je dejansko lotimo, poračunamo še hitrejši približek. Pseudo kodo vidimo na programu~\ref{prog:primer-0}

\begin{lstlisting}[caption={Sinhron sekvečni primer.},label={prog:primer-0},float,floatplacement=h]
x' = priblizek(42)
prikazi_na_zaslon(x')
x = tocna_funkcija(42)
prikazi_na_zaslon(x)

kontinuacija()
\end{lstlisting}

Ta primer ima dve težavi, ki sta posledici sekvenčnega sinhronega izvajanja. Prvi problem je da, ker je program sekvenčni, ne moremo računati točne funkcije hkrati z približkom in posledično se program izvaja dlje časa. Drugi problem pa je, da dokler se bo računala točna funkcija, ne moremo izvajati kontinuacije, kar pomeni da se program ne more odzivati na uporabnikov vhod.  

Obema težavama se zlahka izognemo če program napišemo v jeziku \aeff, kot vidimo v programu~\ref{prog:primer-1}. Najprej v prvem procesu poračunamo približek in ga prikažemo. Nato s pomočjo efekta v drug proces pošljemo vhod točne funkcije. V drugem procesu prestrežemo število $42$, začnemo računati točno funkcijo in ko končamo pošljemo rezultat nazaj v glavni proces. Medtem ko se računa točna vrednost se glavni proces ne zaustavi, ampak nadaljuje z izvajanjem kontinuacije. Ko glavni proces prestreže rezultat, ga izpiše na zaslon in veže v spremenljivko p, da ga po potrebi lahko uporabi tudi kontinuacija.

\begin{lstlisting}[caption={Asinhron Vzporeden primer.},label={prog:primer-1},float,floatplacement=h]
operation call : int
operation result : int
 
run x' = priblizek(42)
	prikazi_na_zaslon(x')
	send call 42;
	promise (result x ->
		prikazi_na_zaslon(x);
		<x>
	) as p in
	kontinuacija()

run promise(call a ->
		let x = tocna_funkcija(a) in
		send result x;
		<()>
	) as _ in
	()
\end{lstlisting}
