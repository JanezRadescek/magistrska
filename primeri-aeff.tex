\section{Primeri v \aeff{}} \label{sec:primeri-aeff}

Poglejmo si sledeči sekvenčni sinhroni primer. Poračunati moramo zelo zahtevno in počasno točno funkcijo in prikazati njen rezultat na zaslonu. Ker je tako zelo počasna, preden se je dejansko lotimo, poračunamo še hitrejši približek. Pseudo kodo vidimo na programu~\ref{prog:primer-0}

\begin{lstlisting}[caption={Sinhron sekvečni primer.},label={prog:primer-0},float,floatplacement=h]
x' = priblizek(42)
zaslon(x')
x = funkcija(42)
zaslon(x)

kontinuacija1()
kontinuacija2(x)
\end{lstlisting}

Ta primer ima dve težavi, ki sta posledici sekvenčnega sinhronega izvajanja. Prvi problem je da, ker je program sekvenčni, ne moremo računati točne funkcije hkrati z približkom in posledično se program izvaja dlje časa. Drugi problem pa je, da dokler se bo računala točna funkcija, ne moremo izvajati prve kontinuacije, čeprav je neodvisna od točnega rezultata. Posledično se program ne more odzvati na potencialen uporabnikov vhod.  

Obema težavama se zlahka izognemo če program napišemo v jeziku \aeff, kot vidimo v programu~\ref{prog:primer-1}. Celoten program razdelimo v dva procesa. Posamezen proces se začne z besedo $\tmkw{run}$. Procesi se lahko izvajajo vzporedno. Najprej v prvem procesu poračunamo približek $\tmkw{let}\ x' = \text{priblizek}(42)$ in ga prikažemo na zaslon z $\text{zaslon}(x');$. Nato s pomočjo efekta $\tmkw{\uparrow}\, \text{call}\,42;$ v drug proces pošljemo število $42$. V drugem procesu prestrežemo število $42$ s pomočjo $\tmwith{call}{a}{M}{\_}{()}$ in jo vežemo v spremenljivko $a$. Nakar začnemo računati točno funkcijo z $\tmkw{let}\ x' = \text{funkcija}(42)$. Ko končamo, pošljemo rezultat nazaj v glavni proces z $\tmkw{\uparrow}\, \text{result}\,x$. Medtem ko se računa točna vrednost se glavni proces ne zaustavi, ampak nadaljuje z izvajanjem prve kontinuacije $\text{kontinuacija}1()$, ki je neodvisna od rezultata točne funkcije. Ko glavni proces prestreže rezultat z $$\tmwith{result}{x}{M}{p}{...}$$, ga izpiše na zaslon in veže v spremenljivko p, da ga po potrebi lahko uporabimo v drugi kontinuaciji. V primeru, da končamo s prvo kontinuacijo preden dobimo rezultat, ne smemo nadaljevati z drugo kontinuacijo sam le ta potrebuje rezultat. Blokada $\tmawait{p}{a}{...}$ blokira nadaljnje izvajanje, dokler se spremenljivka $p$ ne substituira z neko vrednostjo $\tmpromise{V}$. Takrat se bo $a$ v $\text{kontinuacija}2(a)$ substituiral z vrednostjo $V$ in izvajanje se bo nadaljevalo.

\begin{lstlisting}[caption={Asinhron Vzporeden primer.},label={prog:primer-1},float,floatplacement=h]
operation call : int
operation result : int
 
run let x' = priblizek(42) in
    zaslon(x');
    send call 42;
    promise (result x ->
    	zaslon(x);
    	<x>
    ) as p in
    kontinuacija1();
    await p until <a> in
    kontinuacija2(a)

run promise(call a ->
    	let x = funkcija(a) in
    	send result x;
    	<()>
    ) as _ in
    ()
\end{lstlisting}
