\section{Uvod} \label{sec:uvod}
%Napišite kratek zgodovinski in matematični uvod.  Pojasnite motivacijo za problem, kje
%nastopa, kje vse je bil obravnavan. Na koncu opišite tudi organizacijo dela -- kaj je v
%katerem razdelku.


Praktično vsak moderen programski jezik je ekvivalenten Turingovemu stroju. Kljub temu se lahko zelo razlikujejo v raznih objektivnih lastnostih, kot so poraba pomnilnika, hitrosti izvajanja, dolžina izvorne kode itd. Prav tako se lahko razlikujejo tudi v bolj subjektivnih lastnostih kot je programska paradigma, berljivost in razumljivost izvorne kode, enostavnost implementacije algoritmov, kvaliteti dokumentacije itd.

Eden izmed možnih pristop k pohitritvi izvajanja programa je vzporedno računanje. Namesto da korake v programu izvajamo enega za drugim, jih poskusimo čim več izvajati hkrati. Določeni koraki so lahko odvisni od drugih korakov in je zato zelo pomembno da jih izvedemo v pravem vrstnem redu. Sicer se lahko njihov pomen spremeni. Ugotoviti kateri koraki so med sabo odvisni in kateri ne je le redko enostavno. Zato je standarden pristop k temu, da programer korake razdeli v procese. Koraki znotraj istega procesa se smatrajo za odvisne, tudi če so neodvisni. Koraki iz različnih procesov se smatrajo za neodvisne (tudi če so odvisni!), razen kadar jih posebej označimo da so odvisni med sabo.

Na programerju je da se pri delitvi in označevanju ne zmoti. Zato je želeno od programskega jezika, da ima korake, ki naredijo ta postopek čim bolj enostaven in razumljiv.

Kljub temu, da sedaj načeloma lahko procese izvajamo hkrati, se mora izvajanje kakšnega procesa včasih začasno ustaviti, ker je nek korak v procesu odvisen od nekega drugega koraka v drugem procesu. Le to ima lahko dve negativni posledici. Lahko sproži verižno reakcijo, ki ustavi še več procesov. Lahko pa se je ustavil kritičen proces, za katerega si iz različni razlogov želimo, da se nebi ustavil ali pa vsaj minimalno.


Ta problem lahko deloma rešimo tako, da sprostimo predpostavko, da so vsi koraki znotraj procesa odvisni med sabo. Kadar bi se zaradi trenutnega koraka moral proces ustaviti, poskusimo izvajati preostale korake v procesu, kadar je to mogoče. Problematičen korak pa izvedemo šele ko so se izvedli vsi koraki od katerih je odvisen. Takemu izvajanju, kjer medtem, ko čakamo na nek dogodek, izvajamo nek drug del, pravimo asinhrono izvajanje. 

%Asinhrono izvajanje ni nujno povezano z vzporednim izvajanjem. 



Nekateri programski jeziki, predvsem starejše verzije, nimajo direktno podpore za vzporedno izvajanje programa. 
Veliko modernih jezikov, če ne drugega omogočajo tako imenovan POSIX. POSIX je aplikacijski vmesnik, ki na operacijskih sistemih, ki ga podpirajo, omogoča uporabo niti~\cite{posix}.
Drugi programski jeziki kot so C++, Java... imajo kot del standardne knjižnice konstrukte, ki jim omogočajo vzporedno izvajanje programa. Čeprav v ozadju mnogi jeziki uporabljajo POSIX, so detajli skriti in zato bolj naravni za programerja. 
Nekateri programski jeziki omogočajo mnoge konstrukte, ki jih povezujemo s vzporednim programiranjem, vendar direktno ne omogočajo vzporednega izvajanja. Na primer CPython ima tako imenovan GIL (global  interpreter lock)~\cite{gil}, ki preprečuje tolmaču, da bi izvajal korake iz več kot ene nit na enkrat.
Le redki programski jeziki, recimo Go, pa so bili zasnovani z vzporednim programiranjem v mislih in imajo zato konstrukte potrebne za vzporedno izvajanje vgrajene v jezik.

Asinhrono izvajanje programa podpirajo mnogi programski jeziki namenjeni izdelovanje spletnih aplikacij. Povezovanje z neko drugo napravo preko interneta je relativno počasno in zato je pomembno, da namesto, da čakamo, opravljamo medtem nekaj drugega. JavaScript je primer takega jezika. 



Eden izmed jezikov, ki podpira asinhrono izvajanje, je jezik \aeff{}. Jezik \aeff{} je statično tipiziran tolmačen funkcijski jezik. Program napisan v \aeff{} je razdeljen v procese. Procesi lahko med sabo komunicirajo s pomočjo učinkov. V trenutni verziji tolmač le simulira vzporedno izvajanje in posledično prednosti asinhronega in vzporednega izvajanja ne pridejo do izraza. To je izključno omejitev implementacije in bi se jo v prihodnosti lahko odpravilo.

\aeff{} sloni na \lae{}-računu~\cite{aeff}. Namen \lae{}-računa je pokazati, da v ozadju kombiniranja asinhronega vzporednega izvajanja z učinki stoji lepa teorija in so posledično koncepti uporabljeni v jeziku \aeff{} smiselni.


Najprej si bomo v poglavju \ref{sec:primeri-aeff} pogledali nekaj primerov napisanih v jeziku \aeff{}, na katerih bo prišlo do izraza asinhrono vzporedno izvajanje.
Nato si bomo v poglavju \ref{sec:lae} pogledali že obstoječ \lae{}-račun. V poglavju \ref{sec:razsirjen-lae} ga bomo razširili z prenosljivimi vrednostmi, rekurzivnimi obljubami in dinamičnimi procesi. V poglavju \ref{sec:impl} si bomo pogledali implementacijo \aeff{} in nekatere razlike med \aeff{} in \lae{}-računom. Obstoječ Hindley–Milnerjev sistem tipov bomo zamenjali z dvosmernim sistemom tipov in obstoječ tolmač spremenili, da omogoča nekoliko bolj optimalno izvajanje. Vse dele implementacije bomo prilagodili tudi za razširjen \lae-račun.
