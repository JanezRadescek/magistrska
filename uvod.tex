\section{Uvod} \label{sec:uvod}
%Napišite kratek zgodovinski in matematični uvod.  Pojasnite motivacijo za problem, kje
%nastopa, kje vse je bil obravnavan. Na koncu opišite tudi organizacijo dela -- kaj je v
%katerem razdelku.


Praktično vsak moderen programski jezik je ekvivalenten Turingovemu stroju. To pomeni, da kar je zmožen poračunati eden izmed njih, so zmožni poračunati tudi vsi ostali. Kljub temu pa se lahko zelo razlikujejo v raznih objektivnih lastnostih, kot so poraba pomnilnika, hitrosti izvajanja, dolžina izvorne kode itd. Prav tako se lahko razlikujejo tudi v bolj subjektivnih lastnostih, kot je programska paradigma, berljivost in razumljivost izvorne kode, enostavnost implementacije algoritmov itd.

Eden izmed možnih pristop k pohitritvi izvajanja programa je vzporedno računanje. Namesto da korake v programu izvajamo enega za drugim, jih poskusimo čim več izvajati hkrati. Določeni koraki so lahko odvisni od drugih korakov in je zato zelo pomembno, da jih izvedemo v pravem vrstnem redu. Sicer se lahko njihov pomen spremeni. Ugotoviti, kateri koraki so med sabo odvisni in kateri ne, je le redko enostavno. Zato je standarden pristop k temu, da programer korake razdeli v procese. Koraki znotraj istega procesa se smatrajo za odvisne, tudi če so neodvisni. Koraki iz različnih procesov se smatrajo za neodvisne (tudi če so odvisni.), razen kadar jih posebej označimo, da so odvisni med sabo.
Na programerju je, da se pri delitvi in označevanju ne zmoti. Zato je želeno od programskega jezika, da ima korake, ki naredijo ta postopek čim bolj enostaven in razumljiv.

Kljub temu, da sedaj načeloma lahko procese izvajamo hkrati, se mora izvajanje kakšnega procesa včasih začasno ustaviti, ker je nek korak v procesu odvisen od nekega drugega koraka v drugem procesu. Le to ima lahko dve negativni posledici. Lahko sproži verižno reakcijo, ki ustavi še več procesov. Lahko pa se je ustavil kritičen proces, za katerega si iz različni razlogov želimo, da se nebi ustavil ali pa vsaj le za zelo kratek čas.
Ta problem lahko deloma rešimo tako, da sprostimo predpostavko, da so vsi koraki znotraj procesa odvisni med sabo. Kadar bi se zaradi trenutnega koraka moral proces ustaviti, poskusimo izvajati preostale korake v procesu, kadar je to mogoče. Problematičen korak pa izvedemo šele ko so se izvedli vsi koraki od katerih je odvisen. Takemu izvajanju, kjer medtem, ko čakamo na nek dogodek, izvajamo nek drug del, pravimo asinhrono izvajanje. 

Eden izmed jezikov, ki podpira asinhrono izvajanje, je jezik \aeff{}. Jezik \aeff{} je statično tipiziran tolmačen funkcijski jezik. Program napisan v jeziku \aeff{} je razdeljen v procese, kar je osnova za potencialno vzporedno izvajanje. Procesi lahko med sabo komunicirajo s pomočjo učinkov. Prestrezanje učinkov je izvedeno asinhrono.
Jezik \aeff{} sloni na \lae{}-računu~\cite{aeff}. Namen \lae{}-računa je pokazati, da v ozadju kombiniranja asinhronega vzporednega izvajanja z učinki stoji lepa teorija in so posledično koncepti uporabljeni v jeziku \aeff{} smiselni.

Najprej si bomo v poglavju \ref{sec:primeri-aeff} pogledali primer, na katerem bomo pokazali, kako nam asinhrono vzporedno izvajanje lahko izboljša program v primerjavi z sinhronim zaporednim izvajanjem.
Nato si bomo v poglavju \ref{sec:lae} pogledali osnovno verzijo \lae{}-računa in dokazali izreka o napredku in ohranitvi. V poglavju \ref{sec:razsirjen-lae} bomo osnovno verzijo \lae{}-računa razširili z rekurzivnimi obljubami, tovori višjega reda in dinamičnimi procesi. Nakar bomo dokazali izreka o napredku in ohranitvi za razširjeno verzijo računa. V podpoglavju \ref{sec:implementacija} si bomo pogledali nekatere razlike med jezikom \aeff{} in \lae{}-računom.